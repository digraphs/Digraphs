#############################################################################
#W  digraph.xml
#Y  Copyright (C) 2014                                  James D. Mitchell
##
##  Licensing information can be found in the README file of this package.
##
#############################################################################
##

<#GAPDoc Label="EdgeOrbitsDigraph">
<ManSection>
  <Oper Name="EdgeOrbitsDigraph" Arg="G, edges[, n]"/>
  <Returns>
    A new digraph.
  </Returns>
  <Description>
    If <A>G</A> is a permutation group, <A>edges</A> is an edge or list of
    edges, and <A>n</A> is a non-negative integer such that <A>G</A> fixes
    <C>[1 .. <A>n</A>]</C> setwise, then 
    this operation returns a new digraph with <A>n</A> vertices and the union
    of the orbits of the edges in <A> edges </A> under the action of the
    permutation group <A>G</A>.  An edge in this context is simply a pair of
    positive integers.
    <P/>

    If the optional third argument <A>n</A> is not present, then the largest
    moved point of the permutation group <A>G</A> is used by default. 

    <Example><![CDATA[
gap> digraph := EdgeOrbitsDigraph(Group((1,3), (1,2)(3,4)), 
>                                 [[1, 2], [4, 5]], 5);
<digraph with 5 vertices, 12 edges>
gap> OutNeighbours(digraph);
[ [ 2, 4, 5 ], [ 1, 3, 5 ], [ 2, 4, 5 ], [ 1, 3, 5 ], [  ] ]
gap> RepresentativeOutNeighbours(digraph);
[ [ 2, 4, 5 ], [  ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphAddEdgeOrbit">
<ManSection>
  <Oper Name="DigraphAddEdgeOrbit" Arg="digraph, edge"/>
  <Returns>
    A new digraph.
  </Returns>
  <Description>
    This operation returns a new digraph with the same vertices and edges as
    <A>digraph</A> and with additional edges consisting of the orbit of the
    edge <A>edge</A> under the action of the <Ref Attr="DigraphGroup"/> of
    <A>digraph</A>.  If <A>edge</A> is already an edge in <A>digraph</A>, then
    <A>digraph</A> is returns unchanged.
    <P/>

    An edge is simply a pair of vertices of <A>digraph</A>.

    <Example><![CDATA[
gap> gr1 := CayleyDigraph(DihedralGroup(8));
<digraph with 8 vertices, 24 edges>
gap> gr2 := DigraphAddEdgeOrbit(gr1, [1, 8]);
<digraph with 8 vertices, 32 edges>
gap> DigraphEdges(gr1);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 8 ], [ 2, 6 ], 
  [ 3, 5 ], [ 3, 4 ], [ 3, 7 ], [ 4, 6 ], [ 4, 7 ], [ 4, 1 ], 
  [ 5, 3 ], [ 5, 2 ], [ 5, 8 ], [ 6, 4 ], [ 6, 5 ], [ 6, 2 ], 
  [ 7, 8 ], [ 7, 1 ], [ 7, 3 ], [ 8, 7 ], [ 8, 6 ], [ 8, 5 ] ]
gap> DigraphEdges(gr2);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 8 ], [ 2, 1 ], [ 2, 8 ], 
  [ 2, 6 ], [ 2, 3 ], [ 3, 5 ], [ 3, 4 ], [ 3, 7 ], [ 3, 2 ], 
  [ 4, 6 ], [ 4, 7 ], [ 4, 1 ], [ 4, 5 ], [ 5, 3 ], [ 5, 2 ], 
  [ 5, 8 ], [ 5, 4 ], [ 6, 4 ], [ 6, 5 ], [ 6, 2 ], [ 6, 7 ], 
  [ 7, 8 ], [ 7, 1 ], [ 7, 3 ], [ 7, 6 ], [ 8, 7 ], [ 8, 6 ], 
  [ 8, 5 ], [ 8, 1 ] ]
gap> gr3 := DigraphRemoveEdgeOrbit(gr2, [1, 8]);
<digraph with 8 vertices, 24 edges>
gap> gr3 = gr1;
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphRemoveEdgeOrbit">
<ManSection>
  <Oper Name="DigraphRemoveEdgeOrbit" Arg="digraph, edge"/>
  <Returns>
    A new digraph.
  </Returns>
  <Description>
    This operation returns a new digraph with the same vertices as
    <A>digraph</A> and with the orbit of the edge <A>edge</A> (under the action
    of the <Ref Attr="DigraphGroup"/> of <A>digraph</A>) removed.
    If <A>edge</A> is not an edge in <A>digraph</A>, then <A>digraph</A> is
    returned unchanged.
    <P/>
    
    An edge is simply a pair of vertices of <A>digraph</A>.

    <Example><![CDATA[
gap> gr1 := CayleyDigraph(DihedralGroup(8));
<digraph with 8 vertices, 24 edges>
gap> gr2 := DigraphAddEdgeOrbit(gr1, [1, 8]);
<digraph with 8 vertices, 32 edges>
gap> DigraphEdges(gr1);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 2, 1 ], [ 2, 8 ], [ 2, 6 ], 
  [ 3, 5 ], [ 3, 4 ], [ 3, 7 ], [ 4, 6 ], [ 4, 7 ], [ 4, 1 ], 
  [ 5, 3 ], [ 5, 2 ], [ 5, 8 ], [ 6, 4 ], [ 6, 5 ], [ 6, 2 ], 
  [ 7, 8 ], [ 7, 1 ], [ 7, 3 ], [ 8, 7 ], [ 8, 6 ], [ 8, 5 ] ]
gap> DigraphEdges(gr2);
[ [ 1, 2 ], [ 1, 3 ], [ 1, 4 ], [ 1, 8 ], [ 2, 1 ], [ 2, 8 ], 
  [ 2, 6 ], [ 2, 3 ], [ 3, 5 ], [ 3, 4 ], [ 3, 7 ], [ 3, 2 ], 
  [ 4, 6 ], [ 4, 7 ], [ 4, 1 ], [ 4, 5 ], [ 5, 3 ], [ 5, 2 ], 
  [ 5, 8 ], [ 5, 4 ], [ 6, 4 ], [ 6, 5 ], [ 6, 2 ], [ 6, 7 ], 
  [ 7, 8 ], [ 7, 1 ], [ 7, 3 ], [ 7, 6 ], [ 8, 7 ], [ 8, 6 ], 
  [ 8, 5 ], [ 8, 1 ] ]
gap> gr3 := DigraphRemoveEdgeOrbit(gr2, [1, 8]);
<digraph with 8 vertices, 24 edges>
gap> gr3 = gr1;
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>


<#GAPDoc Label="IsDigraph">
<ManSection>
  <Filt Name="IsDigraph" Type='Category'/>
  <Description>
    Every  digraph in  &Digraphs;  belongs  to  the  category
    <C>IsDigraph</C>.  Basic attributes and operations for digraphs
    are: <Ref Oper="DigraphVertices"/>, <Ref Attr="DigraphRange"/>, <Ref
      Attr="DigraphSource"/>, <Ref Attr="OutNeighbours"/>, and <Ref
      Attr="DigraphEdges"/>.
    </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsCayleyDigraph">
<ManSection>
  <Filt Name="IsCayleyDigraph" Type='Category'/>
  <Description>
    <C>IsCayleyDigraph</C> is a subcategory of <C>IsDigraph</C>. Digraphs that
    are Cayley digraphs of a group and that are constructed by the operation
    <Ref Oper="CayleyDigraph"/> are constructed in this category.
    </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsDigraphWithAdjacencyFunction">
<ManSection>
  <Filt Name="IsDigraphWithAdjacencyFunction" Type='Category'/>
  <Description>
    <C>IsCayleyDigraph</C> is a subcategory of <C>IsDigraph</C>. Digraphs that
    are <E>created</E> using an adjacency function are constructed in this
    category</Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphType">
<ManSection>
  <Var Name="DigraphType"/>
  <Var Name="DigraphFamily"/>
  <Description>
    The type of all digraphs is <C>DigraphType</C>.
    The family of all digraphs is <C>DigraphFamily</C>.
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphVertexLabels">
<ManSection>
  <Oper Name="DigraphVertexLabels" Arg="digraph"/>
  <Oper Name="SetDigraphVertexLabels" Arg="digraph, list"/>
  <Description>
    If <A>digraph</A> is a digraph, then <C>DigraphVertexLabels</C> returns a
    copy of the labels of the vertices in <A>digraph</A>.
    <C>SetDigraphVertexLabels</C> can be used to set the labels of the vertices
    in <A>digraph</A> to the list of
    arbitrary &GAP; objects <A>list</A>. <P/>

    The label of a vertex can be changed an arbitrary number of times. If no
    label has been set for the vertex <A>i</A>, then the default value is
    <A>i</A>. <P/>

    If <A>digraph</A> is a digraph created from a record with a component
    <C>vertices</C>, then the labels of the vertices are set to the value of
    this component.<P/>

    Induced subdigraphs, and other operations which create new digraphs from
    old ones, inherit their labels from their parents. 

    <Example><![CDATA[
gap> gr := Digraph([[3], [1, 3, 5], [1], [1, 2, 4], [2, 3, 5]]);
<digraph with 5 vertices, 11 edges>
gap> DigraphVertexLabels(gr);
[ 1 .. 5 ]
gap> gr := Digraph(["a", "b", "c"], [], []);
<digraph with 3 vertices, 0 edges>
gap> DigraphVertexLabels(gr);
[ "a", "b", "c" ]
gap> SetDigraphVertexLabel(gr, 2, "d");
gap> DigraphVertexLabels(gr);
[ "a", "d", "c" ]
gap> gr := InducedSubdigraph(gr, [1, 3]);
<digraph with 2 vertices, 0 edges>
gap> DigraphVertexLabels(gr);
[ "a", "c" ]]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphVertexLabel">
<ManSection>
  <Oper Name = "DigraphVertexLabel" Arg="digraph, i"/>
  <Oper Name ="SetDigraphVertexLabel" Arg="digraph, i, obj"/>
  <Description>
    If <A>digraph</A> is a digraph, then the first operation returns the label
    of the vertex <A>i</A>. The second operation can be used to set the label
    of the vertex <A>i</A> in <A>digraph</A> to the arbitrary &GAP; object
    <A>obj</A>.  <P/>

    The label of a vertex can be changed an arbitrary number of times. If no
    label has been set for the vertex <A>i</A>, then the default value is
    <A>i</A>. <P/>

    If <A>digraph</A> is a digraph created from a record with a component
    <C>vertices</C>, then the labels of the vertices are set to the value of
    this component.<P/>

    Induced subdigraphs, and other operations which create new digraphs from
    old ones, inherit their labels from their parents. 

    <Example><![CDATA[
gap> gr := Digraph([[3], [1, 3, 5], [1], [1, 2, 4], [2, 3, 5]]);
<digraph with 5 vertices, 11 edges>
gap> DigraphVertexLabel(gr, 3);
3
gap> gr := Digraph(["a", "b", "c"], [], []);
<digraph with 3 vertices, 0 edges>
gap> DigraphVertexLabel(gr, 2);
"b"
gap> SetDigraphVertexLabel(gr, 2, "d");
gap> DigraphVertexLabel(gr, 2);
"d"
gap> gr := InducedSubdigraph(gr, [1, 2]);
<digraph with 2 vertices, 0 edges>
gap> DigraphVertexLabel(gr, 2);
"d"]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="IsMultiDigraph">
<ManSection>
  <Prop Name="IsMultiDigraph" Arg="digraph"/>
  <Returns><K>true</K> or <K>false</K>.</Returns>
  <Description>
    A <E>multidigraph</E> is one that has at least two 
    edges with equal source and range. 
    
    <Example><![CDATA[
gap> gr := Digraph(["a", "b", "c"], ["a", "b", "b"], ["b", "c", "a"]);
<digraph with 3 vertices, 3 edges>
gap> IsMultiDigraph(gr);
false
gap> gr := Digraph(3, [1, 2, 3, 1, 1, 2], [1, 2, 3, 2, 3, 1]);
<digraph with 3 vertices, 6 edges>
gap> IsMultiDigraph(gr);
false
gap> gr := Digraph(3, [1, 2, 3, 1, 1, 2, 1], [1, 2, 3, 2, 3, 1, 2]);
<multidigraph with 3 vertices, 7 edges>
gap> IsMultiDigraph(gr);
true]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="Digraph">
<ManSection>
  <Oper Name = "Digraph" Arg = "obj[, source, range]"/>
  <Oper Name = "Digraph" Arg = "list, func" Label = "for a list and function"/>
  <Oper Name = "Digraph" Arg = "G, list, act, adj" Label = "for a group, list, function, and function"/>
  <Returns>A digraph.</Returns>
  <Description>
    <List>
      <Mark>for a list (i.e. an adjacency list)</Mark>
      <Item>
        if <A>obj</A> is a list of lists of positive integers in
        the range from <C>1</C> to <C>Length(<A>obj</A>)</C>, then this function
        returns the digraph with vertices
        <M>E ^ 0 = </M><C>[1 .. Length(<A>obj</A>)]</C>,
        and edges corresponding to the entries of <A>obj</A>. <P/>
        
        More precisely, there is an edge from vertex <C>i</C> to <C>j</C> if and
        only if <C>j</C> is in <C><A>obj</A>[i]</C>; the source of this edge is
        <C>i</C> and the range is <C>j</C>. If <C>j</C> occurs in
        <C><A>obj</A>[i]</C> with multiplicity <C>k</C>, then there are <C>k</C>
        edges from <C>i</C> to <C>j</C>.
      </Item>

      <Mark>for three lists</Mark>
      <Item>
        if <A>obj</A> is a duplicate-free list, and <A>source</A> and
        <A>range</A> are lists of equal length consisting of positive integers
        in the list <C>[1 .. Length(<A>obj</A>)]</C>, then this function
        returns a digraph with vertices
        <M>E ^ 0 = </M><C>[1 .. Length(<A>obj</A>)]</C>, and
        <C>Length(<A>source</A>)</C> edges.  For each <C>i</C> in
        <C>[1 .. Length(<A>source</A>)]</C> there exists an edge with source
        vertex <C>source[i]</C> and range vertex <C>range[i]</C>.
        See <Ref Attr="DigraphSource"/> and <Ref Attr="DigraphRange"/>.
        <P/>

        The vertices of the digraph will be labelled by the elements of
        <A>obj</A>.
      </Item>

      <Mark>for an integer, and two lists</Mark>
      <Item>
        if <A>obj</A> is an integer, and <A>source</A> and
        <A>range</A> are lists of equal length consisting of positive integers
        in the list <C>[1 .. <A>obj</A>]</C>, then this function
        returns a digraph with vertices
        <M>E ^ 0 = </M><C>[1 .. <A>obj</A>]</C>, and
        <C>Length(<A>source</A>)</C> edges.  For each <C>i</C> in
        <C>[1 .. Length(<A>source</A>)]</C> there exists an edge with source
        vertex <C>source[i]</C> and range vertex <C>range[i]</C>.
        See <Ref Attr="DigraphSource"/> and <Ref Attr="DigraphRange"/>.
      </Item>
      
      <Mark>for a list and a function</Mark>
      <Item>
        if <A>list</A> is a list and <A>func</A> is a function taking 2
        arguments that are elements of <A>list</A>, and <A>func</A> returns
        <K>true</K> or <K>false</K>, then this operation creates a digraph with
        vertices <C>[1 .. Length(<A>list</A>)]</C> and an edge from vertex
        <C>i</C> to vertex <C>j</C> if and only if
        <C><A>func</A>(<A>list</A>[i], <A>list</A>[j])</C> returns <K>true</K>.
      </Item>
      
      <Mark>for a group, a list, and two functions</Mark>
      <Item>
        The arguments will be <A>G, list, act, adj</A>. <P/>

        Let <A>G</A> be a group acting on the objects in <A>list</A> via
        the action <A>act</A>, and let <A>adj</A> be a function taking
        two objects from <A>list</A> as arguments and returning <C>true</C> or
        <C>false</C>. The function <A>adj</A> will describe the adjacency
        between objects from <A>list</A>, which is invariant under the action of
        <A>G</A>. This variant of the constructor returns a digraph with
        vertices the objects of <A>list</A> and directed edges <C>[x, y]</C>
        when <C>f(x, y)</C> is <C>true</C>. <P/>

        The action of the group <A>G</A> on the objects in <A>list</A> is stored
        in the attribute <Ref Attr="DigraphGroup"/>, and is used to speed up
        operations like <Ref Oper="DigraphDiameter"/>.
      </Item>

      <Mark>for a Grape package graph</Mark>
      <Item>
        if <A>obj</A> is a &Grape; package graph (i.e. a record for which the
        function <C>IsGraph</C> returns <K>true</K>), then this function returns
        a digraph isomorphic to <A>obj</A>.
      </Item>

      <Mark>for a binary relation</Mark>
      <Item>
        if <A>obj</A> is a binary relation on the points <C>[1 .. n]</C> for
        some posititve integer <M>n</M>, then this function returns the digraph
        defined by <A>obj</A>. Specifically, this function returns a digraph
        which has <M>n</M> vertices, and which has an edge with source <C>i</C>
        and range <C>j</C> if and only if <C>[i,j]</C> is a pair in
        the binary relation <A>obj</A>.
      </Item>
    </List>
  
    <Example><![CDATA[
gap> gr := Digraph([[2, 5, 8, 10], [2, 3, 4, 2, 5, 6, 8, 9, 10], 
> [1], [3, 5, 7, 8, 10], [2, 5, 7], [3, 6, 7, 9, 10], [1, 4],
> [1, 5, 9], [1, 2, 7, 8], [3, 5]]);
<multidigraph with 10 vertices, 38 edges>
gap> gr := Digraph(["a", "b", "c"], ["a"], ["b"]);
<digraph with 3 vertices, 1 edge>
gap> gr := Digraph(5, [1, 2, 2, 4, 1, 1], [2, 3, 5, 5, 1, 1]);
<multidigraph with 5 vertices, 6 edges>
gap> Petersen := Graph(SymmetricGroup(5), [[1, 2]], OnSets,
> function(x, y) return Intersection(x, y) = []; end);;
gap> Digraph(Petersen);
<digraph with 10 vertices, 30 edges>
gap> b := BinaryRelationOnPoints(
> [[3], [1, 3, 5], [1], [1, 2, 4], [2, 3, 5]]);
Binary Relation on 5 points
gap> gr := Digraph(b);
<digraph with 5 vertices, 11 edges>
gap> gr := Digraph([1 .. 10], ReturnTrue);
<digraph with 10 vertices, 100 edges>]]></Example>

      The next example illustrates the uses of the fourth and fifth variants of
      this constructor. The resulting digraph is a strongly regular graph, and
      it is actually the point graph of the van Lint-Schrijver partial
      geometry, <Cite Key="vanLintSchrijver1981"/>.  The algebraic description
      is taken from the seminal paper of Calderbank and Kantor <Cite
        Key="CalderbankKantor1986"/>.
<Example><![CDATA[
gap> f := GF(3^4);
GF(3^4)
gap> gamma := First(f, x -> Order(x) = 5);
Z(3^4)^64
gap> L := Union([Zero(f)], List(Group(gamma)));
[ 0*Z(3), Z(3)^0, Z(3^4)^16, Z(3^4)^32, Z(3^4)^48, Z(3^4)^64 ]
gap> omega := Union(List(L, x -> List(Difference(L, [x]), y -> x - y)));
[ Z(3)^0, Z(3), Z(3^4)^5, Z(3^4)^7, Z(3^4)^8, Z(3^4)^13, Z(3^4)^15, 
  Z(3^4)^16, Z(3^4)^21, Z(3^4)^23, Z(3^4)^24, Z(3^4)^29, Z(3^4)^31, 
  Z(3^4)^32, Z(3^4)^37, Z(3^4)^39, Z(3^4)^45, Z(3^4)^47, Z(3^4)^48, 
  Z(3^4)^53, Z(3^4)^55, Z(3^4)^56, Z(3^4)^61, Z(3^4)^63, Z(3^4)^64, 
  Z(3^4)^69, Z(3^4)^71, Z(3^4)^72, Z(3^4)^77, Z(3^4)^79 ]
gap> adj := function(x, y)
> return x - y in omega;
> end;
function( x, y ) ... end
gap> digraph := Digraph(AsList(f), adj);
<digraph with 81 vertices, 2430 edges>
gap> group := Group(Z(3));
<group with 1 generators>
gap> act := \*;
<Operation "*">
gap> digraph := Digraph(group, List(f), act, adj);
<digraph with 81 vertices, 2430 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="Graph">
<ManSection>
  <Oper Name="Graph" Arg="digraph"/>
  <Returns>A &Grape; package graph.</Returns>
  <Description>
    If <A>digraph</A> is a digraph without multiple edges, then this operation
    returns a &Grape; package graph that is isomorphic to <A>digraph</A>. <P/>

    If <A>digraph</A> is a multidigraph, then since &Grape; does not support
    multiple edges, the multiple edges will be reduced to a single edge in the
    result. In order words, for a multidigraph this operation will return the
    same as <C>Graph(DigraphRemoveAllMultipleEdges(</C><A>digraph</A><C>))</C>.
    
    <Example><![CDATA[
gap> Petersen := Graph(SymmetricGroup(5), [[1, 2]], OnSets,
> function(x, y) return Intersection(x, y) = []; end);
rec( adjacencies := [ [ 3, 5, 8 ] ], group := Group([ (1,2,3,5,7)
  (4,6,8,9,10), (2,4)(6,9)(7,10) ]), isGraph := true, 
  names := [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 1, 3 ], [ 4, 5 ], 
      [ 2, 4 ], [ 1, 5 ], [ 3, 5 ], [ 1, 4 ], [ 2, 5 ] ], 
  order := 10, representatives := [ 1 ], 
  schreierVector := [ -1, 1, 1, 2, 1, 1, 1, 1, 2, 2 ] )
gap> Digraph(Petersen);
<digraph with 10 vertices, 30 edges>
gap> Graph(last);
rec( adjacencies := [ [ 3, 5, 8 ] ], group := Group([ (1,2,3,5,7)
  (4,6,8,9,10), (2,4)(6,9)(7,10) ]), isGraph := true, 
  names := [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ], [ 1, 3 ], [ 4, 5 ], 
      [ 2, 4 ], [ 1, 5 ], [ 3, 5 ], [ 1, 4 ], [ 2, 5 ] ], 
  order := 10, representatives := [ 1 ], 
  schreierVector := [ -1, 1, 1, 2, 1, 1, 1, 1, 2, 2 ] )]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphByAdjacencyMatrix">
<ManSection>
  <Oper Name="DigraphByAdjacencyMatrix" Arg="adj"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>adj</A> is the adjacency matrix of a digraph in the sense of
    <Ref Attr="AdjacencyMatrix"/>, then this operation returns the digraph
    which is defined by <A>adj</A>. <P/>

    Alternatively, if <A>adj</A> is a square boolean matrix, then this
    operation returns the digraph with <C>Length(</C><A>adj</A><C>)</C>
    vertices which has the edge <C>[i,j]</C> if and only if
    <A>adj</A><C>[i][j]</C> is <K>true</K>. <P/>

    <Example><![CDATA[
gap> DigraphByAdjacencyMatrix([
> [0, 1, 0, 2, 0],
> [1, 1, 1, 0, 1],
> [0, 3, 2, 1, 1],
> [0, 0, 1, 0, 1],
> [2, 0, 0, 0, 0]]);
<multidigraph with 5 vertices, 18 edges>
gap> gr := DigraphByAdjacencyMatrix([
> [true, false, true],
> [false, false, true],
> [false, true, false]]);
<digraph with 3 vertices, 4 edges>
gap> OutNeighbours(gr);
[ [ 1, 3 ], [ 3 ], [ 2 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphByEdges">
<ManSection>
  <Oper Name="DigraphByEdges" Arg="edges[, n]"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>edges</A> is list of pairs of positive integers, then this function
    returns the digraph with the minimum number of vertices <C>m</C> such that
    its edges equal <A>edges</A>.<P/>

    If the optional second argument <A>n</A> is a positive integer with
    <C><A>n</A> >= m</C> (with <C>m</C> defined as above),
    then this function returns the digraph with <A>n</A> vertices and edges
    <A>edges</A>. <P/>

    See <Ref Attr="DigraphEdges"/>.
    
    <Example><![CDATA[
gap> DigraphByEdges(
> [[1, 3], [2, 1], [2, 3], [2, 5], [3, 6], 
>  [4, 6], [5, 2], [5, 4], [5, 6], [6, 6]]);
<digraph with 6 vertices, 10 edges>
gap> DigraphByEdges(
> [[1, 3], [2, 1], [2, 3], [2, 5], [3, 6], 
>  [4, 6], [5, 2], [5, 4], [5, 6], [6, 6]], 10);
<digraph with 10 vertices, 10 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphByInNeighbours">
<ManSection>
  <Oper Name="DigraphByInNeighbours" Arg="in"/>
  <Oper Name="DigraphByInNeighbors" Arg="in"/>
  <Returns>A digraph.</Returns>
  <Description>

  If <A>in</A> is a list of lists of positive integers in the range 
  <C>[1 .. Length(<A>in</A>)]</C>, then this function returns the
  digraph with vertices <M>E^0=</M><C>[1 .. Length(<A>in</A>)]</C>, and 
  edges corresponding to the entries of <A>in</A>. More precisely, there is an 
  edge with source vertex <C>i</C> and range vertex <C>j</C> if <C>i</C> is in 
  <C><A>in</A>[j]</C>. <P/>

  If <C>i</C> occurs in <C><A>in</A>[j]</C> with multiplicity <C>k</C>,
  then there are <C>k</C> multiple edges from <C>i</C> to <C>j</C>. <P/>

  See <Ref Attr="InNeighbours"/>.

    <Example><![CDATA[
gap> gr := DigraphByInNeighbours([
> [2, 5, 8, 10], [2, 3, 4, 5, 6, 8, 9, 10], 
> [1], [3, 5, 7, 8, 10], [2, 5, 7], [3, 6, 7, 9, 10], [1, 4], 
> [1, 5, 9], [1, 2, 7, 8], [3, 5]]);
<digraph with 10 vertices, 37 edges>
gap> gr := DigraphByInNeighbours([[2, 3, 2], [1], [1, 2, 3]]);
<multidigraph with 3 vertices, 7 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="AsDigraph">
<ManSection>
  <Oper Name="AsDigraph" Arg="trans[, n]"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>trans</A> is a transformation and <A>n</A> is a non-negative integer,
    then this function returns the functional digraph with <A>n</A> 
    vertices defined by <A>trans</A>. See <Ref Prop="IsFunctionalDigraph"/>.
    
    Specifically, the graph has  <A>n</A> edges: for each vertex <M>x</M>, 
    there is a unique edge with source <M>x</M>; this edge has range 
    <M>x</M>^<A>trans</A>.
    <P/>

    If the optional second argument <A>n</A> is not supplied, then the degree
    of the transformation <A>trans</A> is used by default.
    
    <Example><![CDATA[
gap> f := Transformation([7, 10, 10, 1, 7, 9, 10, 4, 2, 3]);
Transformation( [ 7, 10, 10, 1, 7, 9, 10, 4, 2, 3 ] )
gap> AsDigraph(f); 
<digraph with 10 vertices, 10 edges>
gap> AsDigraph(f, 4); 
<digraph with 4 vertices, 4 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphCopy">
<ManSection>
  <Oper Name="DigraphCopy" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    This function returns a new copy of <A>digraph</A>, retaining none of the
    attributes or properties of <A>digraph</A>.
<Example><![CDATA[
gap> gr := CycleDigraph(10);
<digraph with 10 vertices, 10 edges>
gap> DigraphCopy(gr) = gr;
true
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomDigraph">
<ManSection>
  <Oper Name="RandomDigraph" Arg="n[, p]"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a positive integer, then this function returns a random 
    digraph with <A>n</A> vertices and without multiple edges. The result
    may or may not have loops.<P/>

    If the optional second argument <A>p</A> is a float with value 
    <M>0 \leq </M> <A> p </A> <M> \leq 1</M>, then an edge will exist between each 
    pair of vertices with probability approximately <A>p</A>.
    If <A>p</A> is not specified, then a random probability will be assumed
    (chosen with uniform probability).
    <Log><![CDATA[
gap> RandomDigraph(1000);
<digraph with 1000 vertices, 364444 edges>
gap> RandomDigraph(10000, 0.023);
<digraph with 10000 vertices, 2300438 edges>
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomMultiDigraph">
<ManSection>
  <Oper Name="RandomMultiDigraph" Arg="n[, m]"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a positive integer, then this function returns a random 
    digraph with <A>n</A> vertices. If the optional second argument 
    <A>m</A> is a positive integer, then the digraph will have <A>m</A>
    edges. If <A>m</A> is not specified, then the number of edges will be
    chosen randomly (with uniform probability) from the range 
    <C>[1 .. </C><M>{n \choose 2}</M><C>]</C>.
    <P/>

    The method used by this function chooses each edge from the set of 
    all possible edges with uniform probability. No effort is made to avoid
    creating multiple edges, so it is possible (but not guaranteed) that the
    result will have multiple edges. The result may or may not have loops.<P/>
    <Log><![CDATA[
gap> RandomMultiDigraph(1000);
<multidigraph with 1000 vertices, 216659 edges>
gap> RandomMultiDigraph(1000, 950);
<multidigraph with 1000 vertices, 950 edges>
]]></Log>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="RandomTournament">
<ManSection>
  <Oper Name="RandomTournament" Arg="n"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a non-negative integer, this function returns a random
    tournament with <A>n</A> vertices. See <Ref Prop="IsTournament"/>. <P/>
    <Example><![CDATA[
gap> RandomTournament(10);
<digraph with 10 vertices, 45 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="ChainDigraph">
<ManSection>
  <Oper Name="ChainDigraph" Arg="n"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a positive integer, this function returns a chain 
    with <A>n</A> vertices and <C><A>n</A> - 1</C> edges.
    Specifically,
    for each vertex <C>i</C> (with <C>i</C> &lt; <C>n</C>), there is a directed 
    edge with source <C>i</C> and range <C>i + 1</C>. <P/>
    
    The <Ref Oper="DigraphReflexiveTransitiveClosure"/> of a chain represents a
    total order.<P/>
    <Example><![CDATA[
gap> ChainDigraph(42);
<digraph with 42 vertices, 41 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="CompleteDigraph">
<ManSection>
  <Oper Name="CompleteDigraph" Arg="n"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a non-negative integer, this function returns the complete 
    digraph with <A>n</A> vertices. See <Ref Prop="IsCompleteDigraph"/>. <P/>
    <Example><![CDATA[
gap> CompleteDigraph(20);
<digraph with 20 vertices, 380 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="CompleteBipartiteDigraph">
<ManSection>
  <Oper Name="CompleteBipartiteDigraph" Arg="m, n"/>
  <Returns>A digraph.</Returns>
  <Description>
    A complete bipartite digraph is a digraph whose vertices
    can be partitioned into two non-empty vertex sets, such there exists
    a unique edge with source <C>i</C> and range <C>j</C> if and only if
    <C>i</C> and <C>j</C> lie in different vertex sets. <P/>

    If <A>m</A> and <A>n</A> are positive integers, this function 
    returns the complete bipartite digraph with vertex sets of sizes
    <A>m</A> (containing the vertices <C>[1 .. m]</C>) and
    <A>n</A> (containing the vertices <C>[m + 1 .. m + n]</C>). 
    <Example><![CDATA[
gap> CompleteBipartiteDigraph(2, 3);
<digraph with 5 vertices, 12 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="EmptyDigraph">
<ManSection>
  <Oper Name="EmptyDigraph" Arg="n"/>
  <Oper Name="NullDigraph" Arg="n"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a non-negative integer, this function returns the
    <E>empty</E> or <E>null</E> digraph with <A>n</A> vertices. An empty
    digraph is one with no edges. 
    <P/>

    <C>NullDigraph</C> is a synonym for <C>EmptyDigraph</C>.

    <Example><![CDATA[
gap> EmptyDigraph(20);
<digraph with 20 vertices, 0 edges>
gap> NullDigraph(10);
<digraph with 10 vertices, 0 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="CycleDigraph">
<ManSection>
  <Oper Name="CycleDigraph" Arg="n"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> is a positive integer, this function returns a <E>cycle</E>
    digraph with <A>n</A> vertices and <A>n</A> edges. Specifically,
    for each vertex <C>i</C> (with <C>i</C> &lt; <C>n</C>), there is a directed 
    edge with source <C>i</C> and range <C>i + 1</C>. In addition, there is
    an edge with source <C>n</C> and range <C>1</C>. <P/>
    <Example><![CDATA[
gap> CycleDigraph(1);
<digraph with 1 vertex, 1 edge>
gap> CycleDigraph(123);
<digraph with 123 vertices, 123 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="CayleyDigraph">
<ManSection>
  <Oper Name="CayleyDigraph" Arg="G[, gens]"/>
  <Returns>A digraph.</Returns>
  <Description>
    Let <A>G</A> be any group and let <A>gens</A> be a list of elements of
    <A>G</A>. This function returns the Cayley graph of the group with respect
    <A>gens</A>. The vertices are the elements of <A>G</A>. There exists an edge
    from the vertex <C>u</C> to the vertex <C>v</C> if and only if there exists
    a generator <C>g</C> in <A>gens</A> such that <C>x * g = y</C>. <P/>

    If the optional second argument <A>gens</A> is not present, then the
    generators of <A>G</A> are used by default.
    <Example><![CDATA[
gap> G := DihedralGroup(8);
<pc group of size 8 with 3 generators>
gap> CayleyDigraph(G);
<digraph with 8 vertices, 24 edges>
gap> G := DihedralGroup(IsPermGroup, 8);
Group([ (1,2,3,4), (2,4) ])
gap> CayleyDigraph(G);
<digraph with 8 vertices, 16 edges>
gap> CayleyDigraph(G, [()]);  
<digraph with 8 vertices, 8 edges>]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="LineUndirectedDigraph">
<ManSection>
  <Oper Name="LineUndirectedDigraph" Arg="digraph"/>
  <Oper Name="EdgeUndirectedDigraph" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    Given a symmetric digraph <A>digraph</A>, the operation returns the
    symmetric digraph obtained by associating a vertex with each edge of
    <A>digraph</A>, ignoring directions and multiplicites, and adding an edge
    between two vertices if and only if the corresponding edges have a vertex in
    common. 
    <Example><![CDATA[
gap> LineUndirectedDigraph(CompleteDigraph(3));
<digraph with 3 vertices, 6 edges>
gap> LineUndirectedDigraph(DigraphSymmetricClosure(ChainDigraph(3)));
<digraph with 2 vertices, 2 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="LineDigraph">
<ManSection>
  <Oper Name="LineDigraph" Arg="digraph"/>
  <Oper Name="EdgeDigraph" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    Given a digraph <A>digraph</A>, the operation returns the digraph
    obtained by associating a vertex with each edge of <A>digraph</A>, and
    creating an edge from a vertex <K>v</K> to a vertex <K>u</K> if and only
    if the terminal vertex of the edge associated with <K>v</K> is the start
    vertex of the edge associated with <K>u</K>.  
    <Example><![CDATA[
gap> LineDigraph(CompleteDigraph(3));
<digraph with 6 vertices, 12 edges>
gap> LineDigraph(ChainDigraph(3));
<digraph with 2 vertices, 1 edge>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DoubleDigraph">
<ManSection>
  <Oper Name="DoubleDigraph" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    Let <A>digraph</A> be a digraph with vertex set <C>V</C>. This function returns the
    double digraph of <A>digraph</A>. The vertex set of the double digraph is the orginal vertex
    set together with a duplicate. The edges are <C>[u_1,v_2]</C> and <C>[u_2,v_1]</C> if and
    only if <C>[u,v]</C> is an edge in <A>digraph</A>, together with the original edges and
    their duplicates.
    <Example><![CDATA[
gap> out := [[2],[3],[1]];
[ [ 2 ], [ 3 ], [ 1 ] ]
gap> gamma := Digraph(out);
<digraph with 3 vertices, 3 edges>
gap> DoubleDigraph(gamma);
<digraph with 6 vertices, 12 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="BipartiteDoubleDigraph">
<ManSection>
  <Oper Name="BipartiteDoubleDigraph" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    Let <A>digraph</A> be a digraph with vertex set <C>V</C>. This function returns the
    bipartite double digraph of <A>digraph</A>. The vertex set of the double digraph is the orginal vertex
    set together with a duplicate. The edges are <C>[u_1,v_2]</C> and <C>[u_2,v_1]</C> if and
    only if <C>[u,v]</C> is an edge in <A>digraph</A>. The resulting graph is bipartite, since the
    orignal edges are not included in the resulting digraph.
    <Example><![CDATA[
gap> out := [[2],[3],[1]];
[ [ 2 ], [ 3 ], [ 1 ] ]
gap> gamma := Digraph(out);
<digraph with 3 vertices, 3 edges>
gap> BipartiteDoubleDigraph(gamma);
<digraph with 6 vertices, 6 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DistanceDigraph">
<ManSection>
  <Oper Name="DistanceDigraph" Arg="digraph, i"
        Label="for digraph and int"/>
  <Oper Name="DistanceDigraph" Arg="digraph, list"
        Label="for digraph and list"/>
  <Returns>A digraph.</Returns>
  <Description>
    The first argument is a digraph, the second argument is a non-negative
    integer or a list of positive integers. This operation returns a digraph on
    the same set of vertices as <A>digraph</A>, with two vertices being adjacent
    if and only if the distance between them in <A>digraph</A> equals <A>i</A>
    or is a number in <A>list</A>.  See <Ref Oper="DigraphShortestDistance"
    Label="for a digraph and two vertices"/>. <P/>

    <Example><![CDATA[
gap> out := [ [ 16, 18, 25 ], [ 17, 20, 25 ], [ 16, 21, 28 ],
>   [ 17, 19, 28 ], [ 17, 24, 26 ], [ 18, 22, 26 ],
>   [ 18, 19, 23 ], [ 19, 27, 29 ], [ 20, 21, 23 ],
>   [ 21, 26, 29 ], [ 20, 22, 27 ], [ 22, 28, 30 ],
>   [ 23, 24, 30 ], [ 16, 24, 27 ], [ 25, 29, 30 ],
>   [ 1, 3, 14 ], [ 2, 4, 5 ], [ 1, 6, 7 ], [ 4, 7, 8 ],
>   [ 2, 9, 11 ], [ 3, 9, 10 ], [ 6, 11, 12 ], [ 7, 9, 13 ],
>   [ 5, 13, 14 ], [ 1, 2, 15 ], [ 5, 6, 10 ], [ 8, 11, 14 ],
>   [ 3, 4, 12 ], [ 8, 10, 15 ], [ 12, 13, 15 ] ];;
gap> digraph := Digraph(out);
<digraph with 30 vertices, 90 edges>
gap> DistanceDigraph(digraph,1);
<digraph with 30 vertices, 90 edges>
gap> DistanceDigraph(digraph,[1,2]);
<digraph with 30 vertices, 270 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="DigraphAddAllLoops">
<ManSection>
  <Oper Name="DigraphAddAllLoops" Arg="digraph"/>
  <Returns>A digraph.</Returns>
  <Description>
    For a digraph <A>digraph</A> this operation return a copy of <A>digraph</A>
    such that a loop is added for every vertex which did not have a loop in 
    <A>digraph</A>. 
    <Example><![CDATA[
gap> gr := EmptyDigraph(13);
<digraph with 13 vertices, 0 edges>
gap> gr := DigraphAddAllLoops(gr);    
<digraph with 13 vertices, 13 edges>
gap> OutNeighbours(gr);
[ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ], [ 8 ], [ 9 ], 
  [ 10 ], [ 11 ], [ 12 ], [ 13 ] ]
gap> gr := Digraph([ [1, 2, 3], [1, 3], [1] ]);
<digraph with 3 vertices, 6 edges>
gap> gr := DigraphAddAllLoops(gr);    
<digraph with 3 vertices, 8 edges>
gap> OutNeighbours(gr);
[ [ 1, 2, 3 ], [ 1, 3, 2 ], [ 1, 3 ] ]
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>

<#GAPDoc Label="JohnsonDigraph">
<ManSection>
  <Oper Name="JohnsonDigraph" Arg="n, k"/>
  <Returns>A digraph.</Returns>
  <Description>
    If <A>n</A> and <A>k</A> are non-negative integers, then this operation
    returns a symmetric digraph which corresponds to the undirected <E>Johnson
    graph</E> <M>J(n, k)</M>. <P/>

    The <E>Johnson graph</E> <M>J(n, k)</M> has vertices given by all the
    <A>k</A>-subsets of the range <C>[1 .. <A>k</A>]</C>, and two vertices are
    connected by an edge iff their intersection has size <M><A>k</A> - 1</M>.

    <Example><![CDATA[
gap> gr := JohnsonDigraph(3, 1);
<digraph with 3 vertices, 6 edges>
gap> OutNeighbours(gr);
[ [ 2, 3 ], [ 1, 3 ], [ 1, 2 ] ]
gap> gr := JohnsonDigraph(4, 2);
<digraph with 6 vertices, 24 edges>
gap> OutNeighbours(gr);
[ [ 2, 3, 4, 5 ], [ 1, 3, 4, 6 ], [ 1, 2, 5, 6 ], [ 1, 2, 5, 6 ], 
  [ 1, 3, 4, 6 ], [ 2, 3, 4, 5 ] ]
gap> JohnsonDigraph(1,0);
<digraph with 1 vertex, 0 edges>
]]></Example>
  </Description>
</ManSection>
<#/GAPDoc>
