<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (digraphs) - Chapter 7: Homomorphisms</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap7"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap7_mj.html">[MathJax on]</a></p>
<p><a id="X84975388859F203D" name="X84975388859F203D"></a></p>
<div class="ChapSects"><a href="chap7.html#X84975388859F203D">7 <span class="Heading">Homomorphisms</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X8200192B80AD2071">7.1 <span class="Heading">Acting on digraphs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X808972017C486F1F">7.1-1 OnDigraphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7AFBA7608498F9CE">7.1-2 OnMultiDigraphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7F6A97E6870CDDA3">7.1-3 OnTuplesDigraphs</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X7E48B9F87A0F22D4">7.2 <span class="Heading">Isomorphisms and canonical labellings</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X83E593F3855B122E">7.2-1 DigraphsUseNauty</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X858C32127A190175">7.2-2 AutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7E7B0D88865A89F6">7.2-3 BlissAutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X857758B18144C0CD">7.2-4 NautyAutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X877732B1783C391B">7.2-5 AutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7DA2C4FE837FFE01">7.2-6 AutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7D676FE67A6684FF">7.2-7 BlissCanonicalLabelling</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X87DA265D803DB337">7.2-8 BlissCanonicalLabelling</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X877B1D377EC197D7">7.2-9 BlissCanonicalDigraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X803ACEDA7BBAC5B3">7.2-10 DigraphGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8096C5287E459279">7.2-11 DigraphOrbits</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8386028782F2D3FF">7.2-12 DigraphOrbitReps</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8657604E87A25E5F">7.2-13 DigraphSchreierVector</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X78913684795FB256">7.2-14 DigraphStabilizer</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7B4F24B283C9EE28">7.2-15 IsIsomorphicDigraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7D4A1FA8868DA930">7.2-16 IsIsomorphicDigraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8219FE6C839D9457">7.2-17 IsomorphismDigraphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7ED93C0F86D9D34F">7.2-18 IsomorphismDigraphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7E1C806D81DFE15E">7.2-19 RepresentativeOutNeighbours</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X80183D4A7C51365A">7.2-20 IsDigraphIsomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7F16B8B3825A627A">7.2-21 IsDigraphColouring</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7D4378F27B49C9AC">7.2-22 MaximalCommonSubdigraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7B99C75B8021FCDA">7.2-23 MinimalCommonSuperdigraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap7.html#X7E1A02FE8384C03C">7.3 <span class="Heading">Homomorphisms of digraphs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X79ABF0E783FD67C7">7.3-1 HomomorphismDigraphsFinder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X85E9B019877AD7FE">7.3-2 DigraphHomomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X8653EDA183E06D05">7.3-3 HomomorphismsDigraphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X82D0FCD87D47ACA8">7.3-4 DigraphMonomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X84B4BDB984C2A9A8">7.3-5 MonomorphismsDigraphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7CB5AD9F861684FD">7.3-6 DigraphEpimorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7DFB1F5D873937B3">7.3-7 EpimorphismsDigraphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7AD04CC186E86CCA">7.3-8 DigraphEmbedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X82EBDF137EEDC5FD">7.3-9 EmbeddingsDigraphs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X80FE9FCB79718A61">7.3-10 IsDigraphHomomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7D6B5A0887903810">7.3-11 IsDigraphEmbedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7F80709A80CBFA98">7.3-12 DigraphsRespectsColouring</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7E93B268823F6478">7.3-13 GeneratorsOfEndomorphismMonoid</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X86D0A74B83D6B9A7">7.3-14 DigraphColouring</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7AB7200D831013C1">7.3-15 DigraphGreedyColouring</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7F9CB3B27B9590DB">7.3-16 DigraphWelshPowellOrder</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X807D49358529A37C">7.3-17 ChromaticNumber</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X863487EF7D64EF56">7.3-18 DigraphCore</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7EEA340C81FCA52D">7.3-19 LatticeDigraphEmbedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap7.html#X7E183D4979D324EF">7.3-20 IsLatticeHomomorphism</a></span>
</div></div>
</div>

<h3>7 <span class="Heading">Homomorphisms</span></h3>

<p><a id="X8200192B80AD2071" name="X8200192B80AD2071"></a></p>

<h4>7.1 <span class="Heading">Acting on digraphs</span></h4>

<p><a id="X808972017C486F1F" name="X808972017C486F1F"></a></p>

<h5>7.1-1 OnDigraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OnDigraphs</code>( <var class="Arg">digraph</var>, <var class="Arg">perm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OnDigraphs</code>( <var class="Arg">digraph</var>, <var class="Arg">trans</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A digraph.</p>

<p>If <var class="Arg">digraph</var> is a digraph, and the second argument <var class="Arg">perm</var> is a <em>permutation</em> of the vertices of <var class="Arg">digraph</var>, then this operation returns a digraph constructed by relabelling the vertices of <var class="Arg">digraph</var> according to <var class="Arg">perm</var>. Note that for an automorphism <code class="code">f</code> of a digraph, we have <code class="code">OnDigraphs(<var class="Arg">digraph</var>, f) = </code><var class="Arg">digraph</var>.</p>

<p>If the second argument is a <em>transformation</em> <var class="Arg">trans</var> of the vertices of <var class="Arg">digraph</var>, then this operation returns a digraph constructed by transforming the source and range of each edge according to <var class="Arg">trans</var>. Thus a vertex which does not appear in the image of <var class="Arg">trans</var> will be isolated in the returned digraph, and the returned digraph may contain multiple edges, even if <var class="Arg">digraph</var> does not. If <var class="Arg">trans</var> is mathematically a permutation, then the result coincides with <code class="code">OnDigraphs(<var class="Arg">digraph</var>, AsPermutation(<var class="Arg">trans</var>))</code>.</p>

<p>The <code class="func">DigraphVertexLabels</code> (<a href="chap5.html#X7E51F2FE87140B32"><span class="RefLink">5.1-10</span></a>) of <var class="Arg">digraph</var> will not be retained in the returned digraph.</p>

<p>If <var class="Arg">digraph</var> belongs to <code class="func">IsMutableDigraph</code> (<a href="chap3.html#X7D7EDF83820ED6F5"><span class="RefLink">3.1-2</span></a>), then relabelling of the vertices is performed directly on <var class="Arg">digraph</var>. If <var class="Arg">digraph</var> belongs to <code class="func">IsImmutableDigraph</code> (<a href="chap3.html#X7CAFAA89804F80BD"><span class="RefLink">3.1-3</span></a>), an immutable copy of <var class="Arg">digraph</var> with the vertices relabelled is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3], [1, 3, 5], [1], [1, 2, 4], [2, 3, 5]]);</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">new := OnDigraphs(D, (1, 2));</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(new);</span>
[ [ 2, 3, 5 ], [ 3 ], [ 2 ], [ 2, 1, 4 ], [ 1, 3, 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [], [2]]);</span>
&lt;immutable digraph with 3 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := Transformation([1, 2, 1]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">new := OnDigraphs(D, t);</span>
&lt;immutable multidigraph with 3 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(new);</span>
[ [ 2, 2 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(DigraphEdges(D),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> e -&gt; IsDigraphEdge(new, [e[1] ^ t, e[2] ^ t]));</span>
true
</pre></div>

<p><a id="X7AFBA7608498F9CE" name="X7AFBA7608498F9CE"></a></p>

<h5>7.1-2 OnMultiDigraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OnMultiDigraphs</code>( <var class="Arg">digraph</var>, <var class="Arg">pair</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OnMultiDigraphs</code>( <var class="Arg">digraph</var>, <var class="Arg">perm1</var>, <var class="Arg">perm2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A digraph.</p>

<p>If <var class="Arg">digraph</var> is a digraph, and <var class="Arg">pair</var> is a pair consisting of a permutation of the vertices and a permutation of the edges of <var class="Arg">digraph</var>, then this operation returns a digraph constructed by relabelling the vertices and edges of <var class="Arg">digraph</var> according to <var class="Arg">perm[1]</var> and <var class="Arg">perm[2]</var>, respectively.</p>

<p>In its second form, <code class="code">OnMultiDigraphs</code> returns a digraph with vertices and edges permuted by <var class="Arg">perm1</var> and <var class="Arg">perm2</var>, respectively.</p>

<p>Note that <code class="code">OnDigraphs(<var class="Arg">digraph</var>, perm)=OnMultiDigraphs(<var class="Arg">digraph</var>, [perm, ()])</code> where <code class="code">perm</code> is a permutation of the vertices of <var class="Arg">digraph</var>. If you are only interested in the action of a permutation on the vertices of a digraph, then you can use <code class="code">OnDigraphs</code> instead of <code class="code">OnMultiDigraphs</code>. If <var class="Arg">digraph</var> belongs to <code class="func">IsMutableDigraph</code> (<a href="chap3.html#X7D7EDF83820ED6F5"><span class="RefLink">3.1-2</span></a>), then relabelling of the vertices is performed directly on <var class="Arg">digraph</var>. If <var class="Arg">digraph</var> belongs to <code class="func">IsImmutableDigraph</code> (<a href="chap3.html#X7CAFAA89804F80BD"><span class="RefLink">3.1-3</span></a>), an immutable copy of <var class="Arg">digraph</var> with the vertices relabelled is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D1 := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6, 3], [], [3], [9, 10], [9], [],  [], [10, 4, 10], [], []]);</span>
&lt;immutable multidigraph with 10 vertices, 10 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := BlissCanonicalLabelling(D1);</span>
[ (1,7)(3,6)(4,10)(5,9), () ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D2 := OnMultiDigraphs(D1, p);</span>
&lt;immutable multidigraph with 10 vertices, 10 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(D2);</span>
[ [  ], [  ], [  ], [  ], [  ], [ 6 ], [ 6, 3, 6 ], [ 4, 10, 4 ], 
  [ 5 ], [ 5, 4 ] ]</pre></div>

<p><a id="X7F6A97E6870CDDA3" name="X7F6A97E6870CDDA3"></a></p>

<h5>7.1-3 OnTuplesDigraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OnTuplesDigraphs</code>( <var class="Arg">list</var>, <var class="Arg">perm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OnSetsDigraphs</code>( <var class="Arg">list</var>, <var class="Arg">perm</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list or set of digraphs.</p>

<p>If <var class="Arg">list</var> is a list of digraphs, and <var class="Arg">perm</var> is a <em>permutation</em> of the vertices of the digraphs in <var class="Arg">list</var>, then <code class="func">OnTuplesDigraphs</code> returns a new list constructed by applying <var class="Arg">perm</var> via <code class="func">OnDigraphs</code> (<a href="chap7.html#X808972017C486F1F"><span class="RefLink">7.1-1</span></a>) to a copy (with the same mutability) of each entry of <var class="Arg">list</var> in turn.</p>

<p>More precisely, <code class="code">OnTuplesDigraphs(<var class="Arg">list</var>,<var class="Arg">perm</var>)</code> is a list of length <code class="code">Length(<var class="Arg">list</var>)</code>, whose <code class="code">i</code>-th entry is <code class="code">OnDigraphs(DigraphCopy(<var class="Arg">list</var>[i]), <var class="Arg">perm</var>)</code>.</p>

<p>If <var class="Arg">list</var> is moreover a <strong class="pkg">GAP</strong> set (i.e. a duplicate-free sorted list), then <code class="func">OnSetsDigraphs</code> returns the sorted output of <code class="func">OnTuplesDigraphs</code>, which is therefore again a set.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">list := [CycleDigraph(IsMutableDigraph, 6),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            DigraphReverse(CycleDigraph(6))];</span>
[ &lt;mutable digraph with 6 vertices, 6 edges&gt;, 
  &lt;immutable digraph with 6 vertices, 6 edges&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := (1, 6)(2, 5)(3, 4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result_tuples := OnTuplesDigraphs(list, p);</span>
[ &lt;mutable digraph with 6 vertices, 6 edges&gt;, 
  &lt;immutable digraph with 6 vertices, 6 edges&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result_tuples[2] = OnDigraphs(list[2], p);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result_tuples = list;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result_tuples = Reversed(list);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result_sets := OnSetsDigraphs(list, p);</span>
[ &lt;immutable digraph with 6 vertices, 6 edges&gt;, 
  &lt;mutable digraph with 6 vertices, 6 edges&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">result_sets = list;</span>
true</pre></div>

<p><a id="X7E48B9F87A0F22D4" name="X7E48B9F87A0F22D4"></a></p>

<h4>7.2 <span class="Heading">Isomorphisms and canonical labellings</span></h4>

<p>From version 0.11.0 of <strong class="pkg">Digraphs</strong> it is possible to use either <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> or <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> (via <span class="URL"><a href="https://github.com/gap-packages/NautyTracesInterface">NautyTracesInterface</a></span>) to calculate canonical labellings and automorphism groups of digraphs; see <a href="chapBib.html#biBJK07">[JK07]</a> and <a href="chapBib.html#biBMP14">[MP14]</a> for more details about <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> and <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span>, respectively.</p>

<p><a id="X83E593F3855B122E" name="X83E593F3855B122E"></a></p>

<h5>7.2-1 DigraphsUseNauty</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphsUseNauty</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphsUseBliss</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: Nothing.</p>

<p>These functions can be used to specify whether <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> or <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> should be used by default by <strong class="pkg">Digraphs</strong>. If <span class="URL"><a href="https://github.com/gap-packages/NautyTracesInterface">NautyTracesInterface</a></span> is not available, then these functions do nothing. Otherwise, by calling <code class="code">DigraphsUseNauty</code> subsequent computations will default to using <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> rather than <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span>, where possible.</p>

<p>You can call these functions at any point in a <strong class="pkg">GAP</strong> session, as many times as you like, it is guaranteed that existing digraphs remain valid, and that comparison of existing digraphs and newly created digraphs via <code class="func">IsIsomorphicDigraph</code> (<a href="chap7.html#X7B4F24B283C9EE28"><span class="RefLink">7.2-15</span></a>), <code class="func">IsIsomorphicDigraph</code> (<a href="chap7.html#X7D4A1FA8868DA930"><span class="RefLink">7.2-16</span></a>), <code class="func">IsomorphismDigraphs</code> (<a href="chap7.html#X8219FE6C839D9457"><span class="RefLink">7.2-17</span></a>), and <code class="func">IsomorphismDigraphs</code> (<a href="chap7.html#X7ED93C0F86D9D34F"><span class="RefLink">7.2-18</span></a>) are also valid.</p>

<p>It is also possible to compute the automorphism group of a specific digraph using both <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> and <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> using <code class="func">NautyAutomorphismGroup</code> (<a href="chap7.html#X857758B18144C0CD"><span class="RefLink">7.2-4</span></a>) and <code class="func">BlissAutomorphismGroup</code> (<a href="chap7.html#X7E7B0D88865A89F6"><span class="RefLink">7.2-3</span></a>), respectively.</p>

<p><a id="X858C32127A190175" name="X858C32127A190175"></a></p>

<h5>7.2-2 AutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismGroup</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A permutation group.</p>

<p>If <var class="Arg">digraph</var> is a digraph, then this attribute contains the group of automorphisms of <var class="Arg">digraph</var>. An <em>automorphism</em> of <var class="Arg">digraph</var> is an isomorphism from <var class="Arg">digraph</var> to itself. See <code class="func">IsomorphismDigraphs</code> (<a href="chap7.html#X8219FE6C839D9457"><span class="RefLink">7.2-17</span></a>) for more information about isomorphisms of digraphs.</p>

<p>If <var class="Arg">digraph</var> is not a multidigraph then the automorphism group is returned as a group of permutations on the set of vertices of <var class="Arg">digraph</var>.</p>

<p>If <var class="Arg">digraph</var> is a multidigraph then the automorphism group is returned as the direct product of a group of permutations on the set of vertices of <var class="Arg">digraph</var> with a group of permutations on the set of edges of <var class="Arg">digraph</var>. These groups can be accessed using <code class="func">Projection</code> (<a href="https://www.gap-system.org/Manuals/doc/ref/chap32_mj.html#X8769E8DA80BC96C1"><span class="RefLink">Reference: Projection for a domain and a positive integer</span></a>) on the returned group.</p>

<p>By default, the automorphism group is found using <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> by Tommi Junttila and Petteri Kaski. If <span class="URL"><a href="https://github.com/gap-packages/NautyTracesInterface">NautyTracesInterface</a></span> is available, then <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> by Brendan Mckay and Adolfo Piperno can be used instead; see <code class="func">BlissAutomorphismGroup</code> (<a href="chap7.html#X7E7B0D88865A89F6"><span class="RefLink">7.2-3</span></a>), <code class="func">NautyAutomorphismGroup</code> (<a href="chap7.html#X857758B18144C0CD"><span class="RefLink">7.2-4</span></a>), <code class="func">DigraphsUseBliss</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>), and <code class="func">DigraphsUseNauty</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>).</p>

<p>If the argument <var class="Arg">digraph</var> is mutable, then the return value of this attribute is recomputed every time it is called.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">johnson := DigraphFromGraph6String("E}lw");</span>
&lt;immutable symmetric digraph with 6 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AutomorphismGroup(johnson);</span>
Group([ (3,4), (2,3)(4,5), (1,2)(5,6) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cycle := CycleDigraph(9);</span>
&lt;immutable cycle digraph with 9 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AutomorphismGroup(cycle);</span>
Group([ (1,2,3,4,5,6,7,8,9) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCyclic(G) and Size(G) = 9;</span>
true</pre></div>

<p><a id="X7E7B0D88865A89F6" name="X7E7B0D88865A89F6"></a></p>

<h5>7.2-3 BlissAutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlissAutomorphismGroup</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlissAutomorphismGroup</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex_colours</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlissAutomorphismGroup</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex_colours</var>, <var class="Arg">edge_colours</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A permutation group.</p>

<p>If <var class="Arg">digraph</var> is a digraph, then this attribute contains the group of automorphisms of <var class="Arg">digraph</var> as calculated using <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> by Tommi Junttila and Petteri Kaski.</p>

<p>The attribute <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X858C32127A190175"><span class="RefLink">7.2-2</span></a>) and operation <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X877732B1783C391B"><span class="RefLink">7.2-5</span></a>) returns the value of either <code class="code">BlissAutomorphismGroup</code> or <code class="func">NautyAutomorphismGroup</code> (<a href="chap7.html#X857758B18144C0CD"><span class="RefLink">7.2-4</span></a>). These groups are, of course, equal but their generating sets may differ.</p>

<p>The attribute <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X7DA2C4FE837FFE01"><span class="RefLink">7.2-6</span></a>) returns the value of <code class="code">BlissAutomorphismGroup</code> as it is not implemented for <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> The requirements for the optional arguments <var class="Arg">vertex_colours</var> and <var class="Arg">edge_colours</var> are documented in <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X7DA2C4FE837FFE01"><span class="RefLink">7.2-6</span></a>). See also <code class="func">DigraphsUseBliss</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>), and <code class="func">DigraphsUseNauty</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>).</p>

<p>If the argument <var class="Arg">digraph</var> is mutable, then the return value of this attribute is recomputed every time it is called.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := BlissAutomorphismGroup(JohnsonDigraph(5, 2));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSymmetricGroup(G);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(G);</span>
120</pre></div>

<p><a id="X857758B18144C0CD" name="X857758B18144C0CD"></a></p>

<h5>7.2-4 NautyAutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NautyAutomorphismGroup</code>( <var class="Arg">digraph</var>[, <var class="Arg">vert_colours</var>] )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A permutation group.</p>

<p>If <var class="Arg">digraph</var> is a digraph, then this attribute contains the group of automorphisms of <var class="Arg">digraph</var> as calculated using <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> by Brendan Mckay and Adolfo Piperno via <span class="URL"><a href="https://github.com/gap-packages/NautyTracesInterface">NautyTracesInterface</a></span>. The attribute <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X858C32127A190175"><span class="RefLink">7.2-2</span></a>) and operation <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X877732B1783C391B"><span class="RefLink">7.2-5</span></a>) returns the value of either <code class="code">NautyAutomorphismGroup</code> or <code class="func">BlissAutomorphismGroup</code> (<a href="chap7.html#X7E7B0D88865A89F6"><span class="RefLink">7.2-3</span></a>). These groups are, of course, equal but their generating sets may differ.</p>

<p>See also <code class="func">DigraphsUseBliss</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>), and <code class="func">DigraphsUseNauty</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>).</p>

<p>If the argument <var class="Arg">digraph</var> is mutable, then the return value of this attribute is recomputed every time it is called.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NautyAutomorphismGroup(JohnsonDigraph(5, 2));</span>
Group([ (3,4)(6,7)(8,9), (2,3)(5,6)(9,10), (2,5)(3,6)(4,7),
 (1,2)(6,8)(7,9) ])</pre></div>

<p><a id="X877732B1783C391B" name="X877732B1783C391B"></a></p>

<h5>7.2-5 AutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismGroup</code>( <var class="Arg">digraph</var>, <var class="Arg">vert_colours</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A permutation group.</p>

<p>This operation computes the automorphism group of a vertex-coloured digraph. A vertex-coloured digraph can be specified by its underlying digraph <var class="Arg">digraph</var> and its colouring <var class="Arg">vert_colours</var>. Let <code class="code">n</code> be the number of vertices of <var class="Arg">digraph</var>. The colouring <var class="Arg">vert_colours</var> may have one of the following two forms:</p>


<ul>
<li><p>a list of <code class="code">n</code> integers, where <var class="Arg">vert_colours</var><code class="code">[i]</code> is the colour of vertex <code class="code">i</code>, using the colours <code class="code">[1 .. m]</code> for some <code class="code">m &lt;= n</code>; or</p>

</li>
<li><p>a list of non-empty disjoint lists whose union is <code class="code">DigraphVertices(<var class="Arg">digraph</var>)</code>, such that <var class="Arg">vert_colours</var><code class="code">[i]</code> is the list of all vertices with colour <code class="code">i</code>.</p>

</li>
</ul>
<p>The <em>automorphism group</em> of a coloured digraph <var class="Arg">digraph</var> with colouring <var class="Arg">vert_colours</var> is the group consisting of its automorphisms; an <em>automorphism</em> of <var class="Arg">digraph</var> is an isomorphism of coloured digraphs from <var class="Arg">digraph</var> to itself. This group is equal to the subgroup of <code class="code">AutomorphismGroup(<var class="Arg">digraph</var>)</code> consisting of those automorphisms that preserve the colouring specified by <var class="Arg">vert_colours</var>. See <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X858C32127A190175"><span class="RefLink">7.2-2</span></a>), and see <code class="func">IsomorphismDigraphs</code> (<a href="chap7.html#X7ED93C0F86D9D34F"><span class="RefLink">7.2-18</span></a>) for more information about isomorphisms of coloured digraphs.</p>

<p>If <var class="Arg">digraph</var> is not a multidigraph then the automorphism group is returned as a group of permutations on the set of vertices of <var class="Arg">digraph</var>.</p>

<p>If <var class="Arg">digraph</var> is a multidigraph then the automorphism group is returned as the direct product of a group of permutations on the set of vertices of <var class="Arg">digraph</var> with a group of permutations on the set of edges of <var class="Arg">digraph</var>. These groups can be accessed using <code class="func">Projection</code> (<a href="https://www.gap-system.org/Manuals/doc/ref/chap32_mj.html#X8769E8DA80BC96C1"><span class="RefLink">Reference: Projection for a domain and a positive integer</span></a>) on the returned group.</p>

<p>By default, the automorphism group is found using <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> by Tommi Junttila and Petteri Kaski. If <span class="URL"><a href="https://github.com/gap-packages/NautyTracesInterface">NautyTracesInterface</a></span> is available, then <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> by Brendan Mckay and Adolfo Piperno can be used instead; see <code class="func">BlissAutomorphismGroup</code> (<a href="chap7.html#X7E7B0D88865A89F6"><span class="RefLink">7.2-3</span></a>), <code class="func">NautyAutomorphismGroup</code> (<a href="chap7.html#X857758B18144C0CD"><span class="RefLink">7.2-4</span></a>), <code class="func">DigraphsUseBliss</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>), and <code class="func">DigraphsUseNauty</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cycle := CycleDigraph(9);</span>
&lt;immutable cycle digraph with 9 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := AutomorphismGroup(cycle);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCyclic(G) and Size(G) = 9;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colours := [[1, 4, 7], [2, 5, 8], [3, 6, 9]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := AutomorphismGroup(cycle, colours);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(H);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H = AutomorphismGroup(cycle, [1, 2, 3, 1, 2, 3, 1, 2, 3]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H = SubgroupByProperty(G, p -&gt; OnTuplesSets(colours, p) = colours);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTrivial(AutomorphismGroup(cycle, [1, 1, 2, 2, 2, 2, 2, 2, 2]));</span>
true</pre></div>

<p><a id="X7DA2C4FE837FFE01" name="X7DA2C4FE837FFE01"></a></p>

<h5>7.2-6 AutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismGroup</code>( <var class="Arg">digraph</var>, <var class="Arg">vert_colours</var>, <var class="Arg">edge_colours</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A permutation group.</p>

<p>This operation computes the automorphism group of a vertex- and/or edge-coloured digraph. A coloured digraph can be specified by its underlying digraph <var class="Arg">digraph</var> and colourings <var class="Arg">vert_colours</var>, <var class="Arg">edge_colours</var>. Let <code class="code">n</code> be the number of vertices of <var class="Arg">digraph</var>. The colourings must have the following forms:</p>


<ul>
<li><p><var class="Arg">vert_colours</var> must be <code class="keyw">fail</code> or a list of <code class="code">n</code> integers, where <var class="Arg">vert_colours</var><code class="code">[i]</code> is the colour of vertex <code class="code">i</code>, using the colours <code class="code">[1 .. m]</code> for some <code class="code">m &lt;= n</code>;</p>

</li>
<li><p><var class="Arg">edge_colours</var> must be <code class="keyw">fail</code> or a list of <code class="code">n</code> lists of integers of the same shape as <code class="code">OutNeighbours(digraph)</code>, where <var class="Arg">edge_colours</var><code class="code">[i][j]</code> is the colour of the edge <code class="code">OutNeighbours(digraph)[i][j]</code>, using the colours <code class="code">[1 .. k]</code> for some <code class="code">k &lt;= n</code>;</p>

</li>
</ul>
<p>Giving <var class="Arg">vert_colours</var> [<var class="Arg">edge_colours</var>] as <code class="code">fail</code> is equivalent to setting all vertices [edges] to be the same colour.</p>

<p>Unlike <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X858C32127A190175"><span class="RefLink">7.2-2</span></a>), it is possible to obtain the automorphism group of an edge-coloured multidigraph (see <code class="func">IsMultiDigraph</code> (<a href="chap6.html#X7BB84CFC7E8B2B26"><span class="RefLink">6.2-11</span></a>)) when no two edges share the same source, range, and colour. The <em>automorphism group</em> of a vertex/edge-coloured digraph <var class="Arg">digraph</var> with colouring <var class="Arg">c</var> is the group consisting of its vertex/edge-colour preserving automorphisms; an <em>automorphism</em> of <var class="Arg">digraph</var> is an isomorphism of vertex/edge-coloured digraphs from <var class="Arg">digraph</var> to itself. This group is equal to the subgroup of <code class="code">AutomorphismGroup(<var class="Arg">digraph</var>)</code> consisting of those automorphisms that preserve the colouring specified by <var class="Arg">colours</var>. See <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X858C32127A190175"><span class="RefLink">7.2-2</span></a>), and see <code class="func">IsomorphismDigraphs</code> (<a href="chap7.html#X7ED93C0F86D9D34F"><span class="RefLink">7.2-18</span></a>) for more information about isomorphisms of coloured digraphs.</p>

<p>If <var class="Arg">digraph</var> is not a multidigraph then the automorphism group is returned as a group of permutations on the set of vertices of <var class="Arg">digraph</var>.</p>

<p>If <var class="Arg">digraph</var> is a multidigraph then the automorphism group is returned as the direct product of a group of permutations on the set of vertices of <var class="Arg">digraph</var> with a group of permutations on the set of edges of <var class="Arg">digraph</var>. These groups can be accessed using <code class="func">Projection</code> (<a href="https://www.gap-system.org/Manuals/doc/ref/chap32_mj.html#X8769E8DA80BC96C1"><span class="RefLink">Reference: Projection for a domain and a positive integer</span></a>) on the returned group.</p>

<p>By default, the automorphism group is found using <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> by Tommi Junttila and Petteri Kaski. If <span class="URL"><a href="https://github.com/gap-packages/NautyTracesInterface">NautyTracesInterface</a></span> is available, then <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> by Brendan Mckay and Adolfo Piperno can be used instead; see <code class="func">BlissAutomorphismGroup</code> (<a href="chap7.html#X7E7B0D88865A89F6"><span class="RefLink">7.2-3</span></a>), <code class="func">NautyAutomorphismGroup</code> (<a href="chap7.html#X857758B18144C0CD"><span class="RefLink">7.2-4</span></a>), <code class="func">DigraphsUseBliss</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>), and <code class="func">DigraphsUseNauty</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cycle := CycleDigraph(12);</span>
&lt;immutable cycle digraph with 12 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vert_colours := List([1 .. 12], x -&gt; x mod 3 + 1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edge_colours := List([1 .. 12], x -&gt; [x mod 2 + 1]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(AutomorphismGroup(cycle));</span>
12
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(AutomorphismGroup(cycle, vert_colours));</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(AutomorphismGroup(cycle, fail, edge_colours));</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(AutomorphismGroup(cycle, vert_colours, edge_colours));</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsTrivial(AutomorphismGroup(cycle,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">vert_colours, List([1 .. 12], x -&gt; [x mod 4 + 1])));</span>
true
</pre></div>

<p><a id="X7D676FE67A6684FF" name="X7D676FE67A6684FF"></a></p>

<h5>7.2-7 BlissCanonicalLabelling</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlissCanonicalLabelling</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NautyCanonicalLabelling</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A permutation, or a list of two permutations.</p>

<p>A function <span class="SimpleMath">ρ</span> that maps a digraph to a digraph is a <em>canonical representative map</em> if the following two conditions hold for all digraphs <span class="SimpleMath">G</span> and <span class="SimpleMath">H</span>:</p>


<ul>
<li><p><span class="SimpleMath">ρ(G)</span> and <span class="SimpleMath">G</span> are isomorphic as digraphs; and</p>

</li>
<li><p><span class="SimpleMath">ρ(G)=ρ(H)</span> if and only if <span class="SimpleMath">G</span> and <span class="SimpleMath">H</span> are isomorphic as digraphs.</p>

</li>
</ul>
<p>A <em>canonical labelling</em> of a digraph <span class="SimpleMath">G</span> (under <span class="SimpleMath">ρ</span>) is an isomorphism of <span class="SimpleMath">G</span> onto its <em>canonical representative</em>, <span class="SimpleMath">ρ(G)</span>. See <code class="func">IsomorphismDigraphs</code> (<a href="chap7.html#X8219FE6C839D9457"><span class="RefLink">7.2-17</span></a>) for more information about isomorphisms of digraphs.</p>

<p><code class="code">BlissCanonicalLabelling</code> returns a canonical labelling of the digraph <var class="Arg">digraph</var> found using <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> by Tommi Junttila and Petteri Kaski. <code class="code">NautyCanonicalLabelling</code> returns a canonical labelling of the digraph <var class="Arg">digraph</var> found using <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> by Brendan McKay and Adolfo Piperno. Note that the canonical labellings returned by <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> and <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> are not usually the same (and may depend of the version used).</p>

<p><code class="code">BlissCanonicalLabelling</code> can only be computed if <var class="Arg">digraph</var> has no multiple edges; see <code class="func">IsMultiDigraph</code> (<a href="chap6.html#X7BB84CFC7E8B2B26"><span class="RefLink">6.2-11</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph1 := DigraphFromDiSparse6String(".ImNS_AiB?qRN");</span>
&lt;immutable digraph with 10 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BlissCanonicalLabelling(digraph1);</span>
(1,9,5,7)(3,6,4,10)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := (1, 2, 7, 5)(3, 9)(6, 10, 8);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph2 := OnDigraphs(digraph1, p);</span>
&lt;immutable digraph with 10 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph1 = digraph2;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnDigraphs(digraph1, BlissCanonicalLabelling(digraph1)) =</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   OnDigraphs(digraph2, BlissCanonicalLabelling(digraph2));</span>
true</pre></div>

<p><a id="X87DA265D803DB337" name="X87DA265D803DB337"></a></p>

<h5>7.2-8 BlissCanonicalLabelling</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlissCanonicalLabelling</code>( <var class="Arg">digraph</var>, <var class="Arg">colours</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NautyCanonicalLabelling</code>( <var class="Arg">digraph</var>, <var class="Arg">colours</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A permutation.</p>

<p>A function <span class="SimpleMath">ρ</span> that maps a coloured digraph to a coloured digraph is a <em>canonical representative map</em> if the following two conditions hold for all coloured digraphs <span class="SimpleMath">G</span> and <span class="SimpleMath">H</span>:</p>


<ul>
<li><p><span class="SimpleMath">ρ(G)</span> and <span class="SimpleMath">G</span> are isomorphic as coloured digraphs; and</p>

</li>
<li><p><span class="SimpleMath">ρ(G)=ρ(H)</span> if and only if <span class="SimpleMath">G</span> and <span class="SimpleMath">H</span> are isomorphic as coloured digraphs.</p>

</li>
</ul>
<p>A <em>canonical labelling</em> of a coloured digraph <span class="SimpleMath">G</span> (under <span class="SimpleMath">ρ</span>) is an isomorphism of <span class="SimpleMath">G</span> onto its <em>canonical representative</em>, <span class="SimpleMath">ρ(G)</span>. See <code class="func">IsomorphismDigraphs</code> (<a href="chap7.html#X7ED93C0F86D9D34F"><span class="RefLink">7.2-18</span></a>) for more information about isomorphisms of coloured digraphs.</p>

<p>A coloured digraph can be specified by its underlying digraph <var class="Arg">digraph</var> and its colouring <var class="Arg">colours</var>. Let <code class="code">n</code> be the number of vertices of <var class="Arg">digraph</var>. The colouring <var class="Arg">colours</var> may have one of the following two forms:</p>


<ul>
<li><p>a list of <code class="code">n</code> integers, where <var class="Arg">colours</var><code class="code">[i]</code> is the colour of vertex <code class="code">i</code>, using the colours <code class="code">[1 .. m]</code> for some <code class="code">m &lt;= n</code>; or</p>

</li>
<li><p>a list of non-empty disjoint lists whose union is <code class="code">DigraphVertices(<var class="Arg">digraph</var>)</code>, such that <var class="Arg">colours</var><code class="code">[i]</code> is the list of all vertices with colour <code class="code">i</code>.</p>

</li>
</ul>
<p>If <var class="Arg">digraph</var> and <var class="Arg">colours</var> together form a coloured digraph, <code class="code">BlissCanonicalLabelling</code> returns a canonical labelling of the digraph <var class="Arg">digraph</var> found using <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> by Tommi Junttila and Petteri Kaski. Similarly, <code class="code">NautyCanonicalLabelling</code> returns a canonical labelling of the digraph <var class="Arg">digraph</var> found using <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> by Brendan McKay and Adolfo Piperno. Note that the canonical labellings returned by <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> and <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> are not usually the same (and may depend of the version used).</p>

<p><code class="code">BlissCanonicalLabelling</code> can only be computed if <var class="Arg">digraph</var> has no multiple edges; see <code class="func">IsMultiDigraph</code> (<a href="chap6.html#X7BB84CFC7E8B2B26"><span class="RefLink">6.2-11</span></a>). The canonical labelling of <var class="Arg">digraph</var> is given as a permutation of its vertices. The canonical representative of <var class="Arg">digraph</var> can be created from <var class="Arg">digraph</var> and its canonical labelling <code class="code">p</code> by using the operation <code class="func">OnDigraphs</code> (<a href="chap7.html#X808972017C486F1F"><span class="RefLink">7.1-1</span></a>):</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnDigraphs(digraph, p);</span></pre></div>

<p>The colouring of the canonical representative can easily be constructed. A vertex <code class="code">v</code> (in <var class="Arg">digraph</var>) has colour <code class="code">i</code> if and only if the vertex <code class="code">v ^ p</code> (in the canonical representative) has colour <code class="code">i</code>, where <code class="code">p</code> is the permutation of the canonical labelling that acts on the vertices of <var class="Arg">digraph</var>. In particular, if <var class="Arg">colours</var> has the first form that is described above, then the colouring of the canonical representative is given by:</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(DigraphVertices(digraph), i -&gt; colours[i / p]);</span></pre></div>

<p>On the other hand, if <var class="Arg">colours</var> has the second form above, then the canonical representative has colouring:</p>


<div class="example"><pre><span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnTuplesSets(colours, p);</span></pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph := DigraphFromDiSparse6String(".ImNS_AiB?qRN");</span>
&lt;immutable digraph with 10 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colours := [[1, 2, 8, 9, 10], [3, 4, 5, 6, 7]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := BlissCanonicalLabelling(digraph, colours);</span>
(1,5,8,4,10,3,9)(6,7)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnDigraphs(digraph, p);</span>
&lt;immutable digraph with 10 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnTuplesSets(colours, p);</span>
[ [ 1, 2, 3, 4, 5 ], [ 6, 7, 8, 9, 10 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colours := [1, 1, 1, 1, 2, 3, 1, 3, 2, 1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := BlissCanonicalLabelling(digraph, colours);</span>
(1,6,9,7)(3,4,5,8,10)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnDigraphs(digraph, p);</span>
&lt;immutable digraph with 10 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(DigraphVertices(digraph), i -&gt; colours[i / p]);</span>
[ 1, 1, 1, 1, 1, 1, 2, 2, 3, 3 ]</pre></div>

<p><a id="X877B1D377EC197D7" name="X877B1D377EC197D7"></a></p>

<h5>7.2-9 BlissCanonicalDigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlissCanonicalDigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NautyCanonicalDigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A digraph.</p>

<p>The attribute <code class="code">BlissCanonicalLabelling</code> returns the canonical representative found by applying <code class="func">BlissCanonicalLabelling</code> (<a href="chap7.html#X7D676FE67A6684FF"><span class="RefLink">7.2-7</span></a>). The digraph returned is canonical in the sense that</p>


<ul>
<li><p><code class="code">BlissCanonicalDigraph(<var class="Arg">digraph</var>)</code> and <var class="Arg">digraph</var> are isomorphic as digraphs; and</p>

</li>
<li><p>If <code class="code">gr</code> is any digraph then <code class="code">BlissCanonicalDigraph(gr)</code> and <code class="code">BlissCanonicalDigraph(<var class="Arg">digraph</var>)</code> are equal if and only if <code class="code">gr</code> and <var class="Arg">digraph</var> are isomorphic as digraphs.</p>

</li>
</ul>
<p>Analogously, the attribute <code class="code">NautyCanonicalLabelling</code> returns the canonical representative found by applying <code class="func">NautyCanonicalLabelling</code> (<a href="chap7.html#X7D676FE67A6684FF"><span class="RefLink">7.2-7</span></a>).</p>

<p>If the argument <var class="Arg">digraph</var> is mutable, then the return value of this attribute is recomputed every time it is called.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph := Digraph([[1], [2, 3], [3], [1, 2, 3]]);</span>
&lt;immutable digraph with 4 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">canon := BlissCanonicalDigraph(digraph);</span>
&lt;immutable digraph with 4 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(canon);</span>
[ [ 1 ], [ 2 ], [ 3, 2 ], [ 1, 3, 2 ] ]
</pre></div>

<p><a id="X803ACEDA7BBAC5B3" name="X803ACEDA7BBAC5B3"></a></p>

<h5>7.2-10 DigraphGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphGroup</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A permutation group.</p>

<p>If <var class="Arg">digraph</var> is immutable and was created knowing a subgroup of its automorphism group, then this group is stored in the attribute <code class="code">DigraphGroup</code>. If <var class="Arg">digraph</var> is mutable, or was not created knowing a subgroup of its automorphism group, then <code class="code">DigraphGroup</code> returns the entire automorphism group of <var class="Arg">digraph</var>. Note that if <var class="Arg">digraph</var> is mutable, then the automorphism group is recomputed every time this function is called.</p>

<p>Note that certain other constructor operations such as <code class="func">CayleyDigraph</code> (<a href="chap3.html#X7FCADADC7EC28478"><span class="RefLink">3.1-12</span></a>), <code class="func">BipartiteDoubleDigraph</code> (<a href="chap3.html#X7C6E6CB284982C7A"><span class="RefLink">3.3-43</span></a>), and <code class="func">DoubleDigraph</code> (<a href="chap3.html#X7FB8B48C87C0ED16"><span class="RefLink">3.3-42</span></a>), may not require a group as one of the arguments, but use the standard constructor method using a group, and hence set the <code class="code">DigraphGroup</code> attribute for the resulting digraph.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := 4;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">adj := function(x, y)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return (((x - y) mod n) = 1) or (((x - y) mod n) = n - 1);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group := CyclicGroup(IsPermGroup, n);</span>
Group([ (1,2,3,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, group, [1 .. n], \^, adj);</span>
&lt;mutable digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasDigraphGroup(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGroup(D);</span>
Group([ (2,4), (1,2)(3,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutomorphismGroup(D);</span>
Group([ (2,4), (1,2)(3,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(group, [1 .. n], \^, adj);</span>
&lt;immutable digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasDigraphGroup(D);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGroup(D);</span>
Group([ (1,2,3,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DoubleDigraph(D);</span>
&lt;immutable digraph with 8 vertices, 32 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasDigraphGroup(D);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGroup(D);</span>
Group([ (1,2,3,4)(5,6,7,8), (1,5)(2,6)(3,7)(4,8) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutomorphismGroup(D) =</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Group([(6, 8), (5, 7), (4, 6), (3, 5), (2, 4),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">       (1, 2)(3, 4)(5, 6)(7, 8)]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 3], [], []]);</span>
&lt;immutable digraph with 3 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasDigraphGroup(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasAutomorphismGroup(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGroup(D);</span>
Group([ (2,3) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasAutomorphismGroup(D);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group := DihedralGroup(8);</span>
&lt;pc group of size 8 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CayleyDigraph(group);</span>
&lt;immutable digraph with 8 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasDigraphGroup(D);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup(DigraphGroup(D));</span>
[ (1,2)(3,5)(4,6)(7,8), (1,7,4,3)(2,5,6,8), (1,4)(2,6)(3,7)(5,8) ]</pre></div>

<p><a id="X8096C5287E459279" name="X8096C5287E459279"></a></p>

<h5>7.2-11 DigraphOrbits</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphOrbits</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An immutable list of lists of integers.</p>

<p><code class="code">DigraphOrbits</code> returns the orbits of the action of the <code class="func">DigraphGroup</code> (<a href="chap7.html#X803ACEDA7BBAC5B3"><span class="RefLink">7.2-10</span></a>) on the set of vertices of <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Group([(2, 3)(7, 8, 9), (1, 2, 3)(4, 5, 6)(8, 9)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := EdgeOrbitsDigraph(G, [1, 2]);</span>
&lt;immutable digraph with 9 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOrbits(D);</span>
[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphMutableCopy(D);</span>
&lt;mutable digraph with 9 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOrbits(D);</span>
[ [ 1, 2, 3 ], [ 4, 5, 6, 7, 8, 9 ] ]
</pre></div>

<p><a id="X8386028782F2D3FF" name="X8386028782F2D3FF"></a></p>

<h5>7.2-12 DigraphOrbitReps</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphOrbitReps</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An immutable list of integers.</p>

<p><code class="code">DigraphOrbitReps</code> returns a list of orbit representatives of the action of the <code class="func">DigraphGroup</code> (<a href="chap7.html#X803ACEDA7BBAC5B3"><span class="RefLink">7.2-10</span></a>) on the set of vertices of <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CayleyDigraph(AlternatingGroup(4));</span>
&lt;immutable digraph with 12 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOrbitReps(D);</span>
[ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphMutableCopy(D);</span>
&lt;mutable digraph with 12 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOrbitReps(D);</span>
[ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;IGO??S?`?_@?a?CK?O");</span>
&lt;immutable digraph with 10 vertices, 14 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOrbitReps(D);</span>
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOrbitReps(DigraphMutableCopy(D));</span>
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
</pre></div>

<p><a id="X8657604E87A25E5F" name="X8657604E87A25E5F"></a></p>

<h5>7.2-13 DigraphSchreierVector</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphSchreierVector</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An immutable list of integers.</p>

<p><code class="code">DigraphSchreierVector</code> returns the so-called <em>Schreier vector</em> of the action of the <code class="func">DigraphGroup</code> (<a href="chap7.html#X803ACEDA7BBAC5B3"><span class="RefLink">7.2-10</span></a>) on the set of vertices of <var class="Arg">digraph</var>. The Schreier vector is a list <code class="code">sch</code> of integers with length <code class="code">DigraphNrVertices(<var class="Arg">digraph</var>)</code> where:</p>


<dl>
<dt><strong class="Mark"><code class="code">sch[i] &lt; 0:</code></strong></dt>
<dd><p>implies that <code class="code">i</code> is an orbit representative and <code class="code">DigraphOrbitReps(<var class="Arg">digraph</var>)[-sch[i]] = i</code>.</p>

</dd>
<dt><strong class="Mark"><code class="code">sch[i] &gt; 0:</code></strong></dt>
<dd><p>implies that <code class="code">i / gens[sch[i]]</code> is one step closer to the root (or representative) of the tree, where <code class="code">gens</code> is the generators of <code class="code">DigraphGroup(<var class="Arg">digraph</var>)</code>.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := 4;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">adj := function(x, y)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     return (((x - y) mod n) = 1) or (((x - y) mod n) = n - 1);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">group := CyclicGroup(IsPermGroup, n);</span>
Group([ (1,2,3,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, group, [1 .. n], \^, adj);</span>
&lt;mutable digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sch := DigraphSchreierVector(D);</span>
[ -1, 2, 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CayleyDigraph(AlternatingGroup(4));</span>
&lt;immutable digraph with 12 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sch := DigraphSchreierVector(D);</span>
[ -1, 2, 2, 1, 1, 2, 1, 2, 2, 1, 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOrbitReps(D);</span>
[ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := GeneratorsOfGroup(DigraphGroup(D));</span>
[ (1,7,5)(2,10,9)(3,4,11)(6,8,12), (1,3,2)(4,5,6)(7,9,8)(10,11,12) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">10 / gens[sch[10]];</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">7 / gens[sch[7]];</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">5 / gens[sch[5]];</span>
7</pre></div>

<p><a id="X78913684795FB256" name="X78913684795FB256"></a></p>

<h5>7.2-14 DigraphStabilizer</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphStabilizer</code>( <var class="Arg">digraph</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A permutation group.</p>

<p><code class="code">DigraphStabilizer</code> returns the stabilizer of the vertex <var class="Arg">v</var> under of the action of the <code class="func">DigraphGroup</code> (<a href="chap7.html#X803ACEDA7BBAC5B3"><span class="RefLink">7.2-10</span></a>) on the set of vertices of <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;GYHPQgWTIIPW");</span>
&lt;immutable digraph with 8 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStabilizer(D, 8);</span>
Group(())
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStabilizer(D, 2);</span>
Group(())
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphMutableCopy(D);</span>
&lt;mutable digraph with 8 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStabilizer(D, 8);</span>
Group(())
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStabilizer(D, 2);</span>
Group(())
</pre></div>

<p><a id="X7B4F24B283C9EE28" name="X7B4F24B283C9EE28"></a></p>

<h5>7.2-15 IsIsomorphicDigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIsomorphicDigraph</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This operation returns <code class="keyw">true</code> if there exists an isomorphism from the digraph <var class="Arg">digraph1</var> to the digraph <var class="Arg">digraph2</var>. See <code class="func">IsomorphismDigraphs</code> (<a href="chap7.html#X8219FE6C839D9457"><span class="RefLink">7.2-17</span></a>) for more information about isomorphisms of digraphs.</p>

<p>By default, an isomorphism is found using the canonical labellings of the digraphs obtained from <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> by Tommi Junttila and Petteri Kaski. If <span class="URL"><a href="https://github.com/gap-packages/NautyTracesInterface">NautyTracesInterface</a></span> is available, then <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> by Brendan Mckay and Adolfo Piperno can be used instead; see <code class="func">DigraphsUseBliss</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>), and <code class="func">DigraphsUseNauty</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph1 := CycleDigraph(4);</span>
&lt;immutable cycle digraph with 4 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph2 := CycleDigraph(5);</span>
&lt;immutable cycle digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicDigraph(digraph1, digraph2);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph2 := DigraphReverse(digraph1);</span>
&lt;immutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicDigraph(digraph1, digraph2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph1 := Digraph([[3], [], []]);</span>
&lt;immutable digraph with 3 vertices, 1 edge&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph2 := Digraph([[], [], [2]]);</span>
&lt;immutable digraph with 3 vertices, 1 edge&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicDigraph(digraph1, digraph2);</span>
true</pre></div>

<p><a id="X7D4A1FA8868DA930" name="X7D4A1FA8868DA930"></a></p>

<h5>7.2-16 IsIsomorphicDigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIsomorphicDigraph</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var>, <var class="Arg">colours1</var>, <var class="Arg">colours2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This operation tests for isomorphism of coloured digraphs. A coloured digraph can be specified by its underlying digraph <var class="Arg">digraph1</var> and its colouring <var class="Arg">colours1</var>. Let <code class="code">n</code> be the number of vertices of <var class="Arg">digraph1</var>. The colouring <var class="Arg">colours1</var> may have one of the following two forms:</p>


<ul>
<li><p>a list of <code class="code">n</code> integers, where <var class="Arg">colours</var><code class="code">[i]</code> is the colour of vertex <code class="code">i</code>, using the colours <code class="code">[1 .. m]</code> for some <code class="code">m &lt;= n</code>; or</p>

</li>
<li><p>a list of non-empty disjoint lists whose union is <code class="code">DigraphVertices(<var class="Arg">digraph</var>)</code>, such that <var class="Arg">colours</var><code class="code">[i]</code> is the list of all vertices with colour <code class="code">i</code>.</p>

</li>
</ul>
<p>If <var class="Arg">digraph1</var> and <var class="Arg">digraph2</var> are digraphs without multiple edges, and <var class="Arg">colours1</var> and <var class="Arg">colours2</var> are colourings of <var class="Arg">digraph1</var> and <var class="Arg">digraph2</var>, respectively, then this operation returns <code class="keyw">true</code> if there exists an isomorphism between these two coloured digraphs. See <code class="func">IsomorphismDigraphs</code> (<a href="chap7.html#X7ED93C0F86D9D34F"><span class="RefLink">7.2-18</span></a>) for more information about isomorphisms of coloured digraphs.</p>

<p>By default, an isomorphism is found using the canonical labellings of the digraphs obtained from <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> by Tommi Junttila and Petteri Kaski. If <span class="URL"><a href="https://github.com/gap-packages/NautyTracesInterface">NautyTracesInterface</a></span> is available, then <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> by Brendan Mckay and Adolfo Piperno can be used instead; see <code class="func">DigraphsUseBliss</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>), and <code class="func">DigraphsUseNauty</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph1 := ChainDigraph(4);</span>
&lt;immutable chain digraph with 4 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph2 := ChainDigraph(3);</span>
&lt;immutable chain digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicDigraph(digraph1, digraph2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [[1, 4], [2, 3]], [[1, 2], [3]]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph2 := DigraphReverse(digraph1);</span>
&lt;immutable digraph with 4 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicDigraph(digraph1, digraph2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 1, 1, 1], [1, 1, 1, 1]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicDigraph(digraph1, digraph2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 2, 2, 1], [1, 2, 2, 1]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicDigraph(digraph1, digraph2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 1, 2, 2], [1, 1, 2, 2]);</span>
false</pre></div>

<p><a id="X8219FE6C839D9457" name="X8219FE6C839D9457"></a></p>

<h5>7.2-17 IsomorphismDigraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismDigraphs</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A permutation, or a pair of permutations, or <code class="keyw">fail</code>.</p>

<p>This operation returns an isomorphism between the digraphs <var class="Arg">digraph1</var> and <var class="Arg">digraph2</var> if one exists, else this operation returns <code class="keyw">fail</code>.</p>

<p>An <em>isomorphism</em> from a digraph <var class="Arg">digraph1</var> to a digraph <var class="Arg">digraph2</var> is a bijection <code class="code">p</code> from the vertices of <var class="Arg">digraph1</var> to the vertices of <var class="Arg">digraph2</var> with the following property: for all vertices <code class="code">i</code> and <code class="code">j</code> of <var class="Arg">digraph1</var>, <code class="code">[i, j]</code> is an edge of <var class="Arg">digraph1</var> if and only if <code class="code">[i ^ p, j ^ p]</code> is an edge of <var class="Arg">digraph2</var>.</p>

<p>If there exists such an isomorphism, then this operation returns one. The form of this isomorphism is a permutation <code class="code">p</code> of the vertices of <var class="Arg">digraph1</var> such that</p>

<p><code class="code">OnDigraphs(<var class="Arg">digraph1</var>, p) = digraph2</code>. By default, an isomorphism is found using the canonical labellings of the digraphs obtained from <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> by Tommi Junttila and Petteri Kaski. If <span class="URL"><a href="https://github.com/gap-packages/NautyTracesInterface">NautyTracesInterface</a></span> is available, then <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> by Brendan Mckay and Adolfo Piperno can be used instead; see <code class="func">DigraphsUseBliss</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>), and <code class="func">DigraphsUseNauty</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph1 := CycleDigraph(4);</span>
&lt;immutable cycle digraph with 4 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph2 := CycleDigraph(5);</span>
&lt;immutable cycle digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismDigraphs(digraph1, digraph2);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph1 := CompleteBipartiteDigraph(10, 5);</span>
&lt;immutable complete bipartite digraph with bicomponent sizes 10 and 5&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph2 := CompleteBipartiteDigraph(5, 10);</span>
&lt;immutable complete bipartite digraph with bicomponent sizes 5 and 10&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := IsomorphismDigraphs(digraph1, digraph2);</span>
(1,6,11)(2,7,12)(3,8,13)(4,9,14)(5,10,15)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnDigraphs(digraph1, p) = digraph2;</span>
true
</pre></div>

<p><a id="X7ED93C0F86D9D34F" name="X7ED93C0F86D9D34F"></a></p>

<h5>7.2-18 IsomorphismDigraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismDigraphs</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var>, <var class="Arg">colours1</var>, <var class="Arg">colours2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A permutation, or <code class="keyw">fail</code>.</p>

<p>This operation searches for an isomorphism between coloured digraphs. A coloured digraph can be specified by its underlying digraph <var class="Arg">digraph1</var> and its colouring <var class="Arg">colours1</var>. Let <code class="code">n</code> be the number of vertices of <var class="Arg">digraph1</var>. The colouring <var class="Arg">colours1</var> may have one of the following two forms:</p>


<ul>
<li><p>a list of <code class="code">n</code> integers, where <var class="Arg">colours</var><code class="code">[i]</code> is the colour of vertex <code class="code">i</code>, using the colours <code class="code">[1 .. m]</code> for some <code class="code">m &lt;= n</code>; or</p>

</li>
<li><p>a list of non-empty disjoint lists whose union is <code class="code">DigraphVertices(<var class="Arg">digraph</var>)</code>, such that <var class="Arg">colours</var><code class="code">[i]</code> is the list of all vertices with colour <code class="code">i</code>.</p>

</li>
</ul>
<p>An <em>isomorphism</em> between coloured digraphs is an isomorphism between the underlying digraphs that preserves the colourings. See <code class="func">IsomorphismDigraphs</code> (<a href="chap7.html#X8219FE6C839D9457"><span class="RefLink">7.2-17</span></a>) for more information about isomorphisms of digraphs. More precisely, let <code class="code">f</code> be an isomorphism of digraphs from the digraph <var class="Arg">digraph1</var> (with colouring <var class="Arg">colours1</var>) to the digraph <var class="Arg">digraph2</var> (with colouring <var class="Arg">colours2</var>), and let <code class="code">p</code> be the permutation of the vertices of <var class="Arg">digraph1</var> that corresponds to <code class="code">f</code>. Then <code class="code">f</code> preserves the colourings of <var class="Arg">digraph1</var> and <var class="Arg">digraph2</var> – and hence is an isomorphism of coloured digraphs – if <code class="code"><var class="Arg">colours1</var>[i] = <var class="Arg">colours2</var>[i ^ p]</code> for all vertices <code class="code">i</code> in <var class="Arg">digraph1</var>.</p>

<p>This operation returns such an isomorphism if one exists, else it returns <code class="keyw">fail</code>.</p>

<p>By default, an isomorphism is found using the canonical labellings of the digraphs obtained from <span class="URL"><a href="http://www.tcs.tkk.fi/Software/bliss/">bliss</a></span> by Tommi Junttila and Petteri Kaski. If <span class="URL"><a href="https://github.com/gap-packages/NautyTracesInterface">NautyTracesInterface</a></span> is available, then <span class="URL"><a href="https://pallini.di.uniroma1.it/">nauty</a></span> by Brendan Mckay and Adolfo Piperno can be used instead; see <code class="func">DigraphsUseBliss</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>), and <code class="func">DigraphsUseNauty</code> (<a href="chap7.html#X83E593F3855B122E"><span class="RefLink">7.2-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph1 := ChainDigraph(4);</span>
&lt;immutable chain digraph with 4 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph2 := ChainDigraph(3);</span>
&lt;immutable chain digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismDigraphs(digraph1, digraph2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [[1, 4], [2, 3]], [[1, 2], [3]]);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph2 := DigraphReverse(digraph1);</span>
&lt;immutable digraph with 4 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colours1 := [1, 1, 1, 1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colours2 := [1, 1, 1, 1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := IsomorphismDigraphs(digraph1, digraph2, colours1, colours2);</span>
(1,4)(2,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnDigraphs(digraph1, p) = digraph2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(DigraphVertices(digraph1), i -&gt; colours1[i ^ p]) = colours2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colours1 := [1, 1, 2, 2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">colours2 := [2, 2, 1, 1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := IsomorphismDigraphs(digraph1, digraph2, colours1, colours2);</span>
(1,4)(2,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OnDigraphs(digraph1, p) = digraph2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(DigraphVertices(digraph1), i -&gt; colours1[i ^ p]) = colours2;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsomorphismDigraphs(digraph1, digraph2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 1, 2, 2], [1, 1, 2, 2]);</span>
fail</pre></div>

<p><a id="X7E1C806D81DFE15E" name="X7E1C806D81DFE15E"></a></p>

<h5>7.2-19 RepresentativeOutNeighbours</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RepresentativeOutNeighbours</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An immutable list of lists.</p>

<p>This function returns the list <code class="code">out</code> of <em>out-neighbours</em> of each representative of the orbits of the action of <code class="func">DigraphGroup</code> (<a href="chap7.html#X803ACEDA7BBAC5B3"><span class="RefLink">7.2-10</span></a>) on the vertex set of the digraph <var class="Arg">digraph</var>.</p>

<p>More specifically, if <code class="code">reps</code> is the list of orbit representatives, then a vertex <code class="code">j</code> appears in <code class="code">out[i]</code> each time there exists an edge with source <code class="code">reps[i]</code> and range <code class="code">j</code> in <var class="Arg">digraph</var>.</p>

<p>If <code class="func">DigraphGroup</code> (<a href="chap7.html#X803ACEDA7BBAC5B3"><span class="RefLink">7.2-10</span></a>) is trivial, then <code class="func">OutNeighbours</code> (<a href="chap5.html#X7E9880767AE68E00"><span class="RefLink">5.2-6</span></a>) is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [2, 1, 3, 4, 5], [3, 5], [2], [1, 2, 3, 5], [1, 2, 3, 4]]);</span>
&lt;immutable digraph with 5 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGroup(D);</span>
Group(())
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentativeOutNeighbours(D);</span>
[ [ 2, 1, 3, 4, 5 ], [ 3, 5 ], [ 2 ], [ 1, 2, 3, 5 ], [ 1, 2, 3, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [2, 1, 3, 4, 5], [3, 5], [2], [1, 2, 3, 5], [1, 2, 3, 4]]);</span>
&lt;mutable digraph with 5 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGroup(D);</span>
Group(())
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RepresentativeOutNeighbours(D);</span>
[ [ 2, 1, 3, 4, 5 ], [ 3, 5 ], [ 2 ], [ 1, 2, 3, 5 ], [ 1, 2, 3, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;GYHPQgWTIIPW");</span>
&lt;immutable digraph with 8 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DigraphGroup(D);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfGroup(G);</span>
[ (1,2)(3,4)(5,6)(7,8), (1,3,2,4)(5,7,6,8), (1,5)(2,6)(3,8)(4,7) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Set(RepresentativeOutNeighbours(D), Set);</span>
[ [ 2, 3, 5 ] ]</pre></div>

<p><a id="X80183D4A7C51365A" name="X80183D4A7C51365A"></a></p>

<h5>7.2-20 IsDigraphIsomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphIsomorphism</code>( <var class="Arg">src</var>, <var class="Arg">ran</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphIsomorphism</code>( <var class="Arg">src</var>, <var class="Arg">ran</var>, <var class="Arg">x</var>, <var class="Arg">col1</var>, <var class="Arg">col2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphAutomorphism</code>( <var class="Arg">digraph</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphAutomorphism</code>( <var class="Arg">digraph</var>, <var class="Arg">x</var>, <var class="Arg">col</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p><code class="code">IsDigraphIsomorphism</code> returns <code class="keyw">true</code> if the permutation or transformation <var class="Arg">x</var> is an isomorphism from the digraph <var class="Arg">src</var> to the digraph <var class="Arg">ran</var>.</p>

<p><code class="code">IsDigraphAutomorphism</code> returns <code class="keyw">true</code> if the permutation or transformation <var class="Arg">x</var> is an automorphism of the digraph <var class="Arg">digraph</var>.</p>

<p>A permutation or transformation <var class="Arg">x</var> is an <em>isomorphism</em> from a digraph <var class="Arg">src</var> to a digraph <var class="Arg">ran</var> if the following hold:</p>


<ul>
<li><p><var class="Arg">x</var> is a bijection from the vertices of <var class="Arg">src</var> to those of <var class="Arg">ran</var>;</p>

</li>
<li><p><code class="code">[u ^ <var class="Arg">x</var>, v ^ <var class="Arg">x</var>]</code> is an edge of <var class="Arg">ran</var> if and only if <code class="code">[u, v]</code> is an edge of <var class="Arg">src</var>; and</p>

</li>
<li><p><var class="Arg">x</var> fixes every <code class="code">i</code> which is not a vertex of <var class="Arg">src</var>.</p>

</li>
</ul>
<p>See also <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X858C32127A190175"><span class="RefLink">7.2-2</span></a>).</p>

<p>If <var class="Arg">col1</var> and <var class="Arg">col2</var>, or <var class="Arg">col</var>, are given, then they must represent vertex colourings; see <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X877732B1783C391B"><span class="RefLink">7.2-5</span></a>) for details of the permissible values for these arguments. The homomorphism must then also have the property:</p>


<ul>
<li><p><code class="code">col1[i] = col2[i ^ x]</code> for all vertices <code class="code">i</code> of <var class="Arg">src</var>, for <code class="code">IsDigraphIsomorphism</code>.</p>

</li>
<li><p><code class="code">col[i] = col[i ^ x]</code> for all vertices <code class="code">i</code> of <var class="Arg">digraph</var>, for <code class="code">IsDigraphAutomorphism</code>.</p>

</li>
</ul>
<p>For some digraphs, it can be faster to use <code class="code">IsDigraphAutomorphism</code> than to test membership in the automorphism group of <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">src := Digraph([[1], [1, 2], [1, 3]]);</span>
&lt;immutable digraph with 3 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphAutomorphism(src, (1, 2, 3));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphAutomorphism(src, (2, 3));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphAutomorphism(src, (2, 3), [2, 1, 1]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphAutomorphism(src, (2, 3), [2, 2, 1]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphAutomorphism(src, (2, 3)(4, 5));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphAutomorphism(src, (1, 4));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphAutomorphism(src, ());</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ran := Digraph([[2, 1], [2], [2, 3]]);</span>
&lt;immutable digraph with 3 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphIsomorphism(src, ran, (1, 2));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphIsomorphism(ran, src, (1, 2));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphIsomorphism(ran, src, (1, 2));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphIsomorphism(src, Digraph([[3], [1, 3], [2]]), (1, 2, 3));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphIsomorphism(src, ran, (1, 2), [1, 2, 3], [2, 1, 3]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphIsomorphism(src, ran, (1, 2), [1, 2, 2], [2, 1, 3]);</span>
false
</pre></div>

<p><a id="X7F16B8B3825A627A" name="X7F16B8B3825A627A"></a></p>

<h5>7.2-21 IsDigraphColouring</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphColouring</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphColouring</code>( <var class="Arg">digraph</var>, <var class="Arg">t</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>The operation <code class="code">IsDigraphColouring</code> verifies whether or not the list <var class="Arg">list</var> describes a proper colouring of the digraph <var class="Arg">digraph</var>.</p>

<p>A list <var class="Arg">list</var> describes a <em>proper colouring</em> of a digraph <var class="Arg">digraph</var> if <var class="Arg">list</var> consists of positive integers, the length of <var class="Arg">list</var> equals the number of vertices in <var class="Arg">digraph</var>, and for any vertices <code class="code">u, v</code> of <var class="Arg">digraph</var> if <code class="code">u</code> and <code class="code">v</code> are adjacent, then <code class="code"><var class="Arg">list</var>[u] &gt;&lt; <var class="Arg">list</var>[v]</code>.</p>

<p>A transformation <var class="Arg">t</var> describes a proper colouring of a digraph <var class="Arg">digraph</var>, if <code class="code">ImageListOfTransformation(<var class="Arg">t</var>, DigraphNrVertices(<var class="Arg">digraph</var>))</code> is a proper colouring of <var class="Arg">digraph</var>.</p>

<p>See also <code class="func">IsDigraphHomomorphism</code> (<a href="chap7.html#X80FE9FCB79718A61"><span class="RefLink">7.3-10</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := JohnsonDigraph(5, 3);</span>
&lt;immutable symmetric digraph with 10 vertices, 60 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphColouring(D, [1, 2, 3, 3, 2, 1, 4, 5, 6, 7]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphColouring(D, [1, 2, 3, 3, 2, 1, 2, 5, 6, 7]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphColouring(D, [1, 2, 3, 3, 2, 1, 2, 5, 6, -1]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphColouring(D, [1, 2, 3]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphColouring(D, IdentityTransformation);</span>
true
</pre></div>

<p><a id="X7D4378F27B49C9AC" name="X7D4378F27B49C9AC"></a></p>

<h5>7.2-22 MaximalCommonSubdigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MaximalCommonSubdigraph</code>( <var class="Arg">D1</var>, <var class="Arg">D2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list containing a digraph and two transformations.</p>

<p>If <var class="Arg">D1</var> and <var class="Arg">D2</var> are digraphs without multiple edges, then <code class="code">MaximalCommonSubdigraph</code> returns a maximal common subgraph <code class="code">M</code> of <var class="Arg">D1</var> and <var class="Arg">D2</var> with the maximum number of vertices. So <code class="code">M</code> is a digraph which embeds into both <var class="Arg">D1</var> and <var class="Arg">D2</var> and has the largest number of vertices among such digraphs. It returns a list <code class="code">[M, t1, t2]</code> where <code class="code">M</code> is the maximal common subdigraph and <code class="code">t1, t2</code> are transformations embedding <code class="code">M</code> into <var class="Arg">D1</var> and <var class="Arg">D2</var> respectively.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MaximalCommonSubdigraph(PetersenGraph(), CompleteDigraph(10));</span>
[ &lt;immutable digraph with 2 vertices, 2 edges&gt;, 
  IdentityTransformation, IdentityTransformation ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MaximalCommonSubdigraph(PetersenGraph(),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">DigraphSymmetricClosure(CycleDigraph(5)));</span>
[ &lt;immutable digraph with 5 vertices, 10 edges&gt;, 
  IdentityTransformation, IdentityTransformation ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MaximalCommonSubdigraph(NullDigraph(0), CompleteDigraph(10));</span>
[ &lt;immutable empty digraph with 0 vertices&gt;, IdentityTransformation, 
  IdentityTransformation ]
</pre></div>

<p><a id="X7B99C75B8021FCDA" name="X7B99C75B8021FCDA"></a></p>

<h5>7.2-23 MinimalCommonSuperdigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MinimalCommonSuperdigraph</code>( <var class="Arg">D1</var>, <var class="Arg">D2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list containing a digraph and two transformations.</p>

<p>If <var class="Arg">D1</var> and <var class="Arg">D2</var> are digraphs without multiple edges, then <code class="code">MinimalCommonSuperdigraph</code> returns a minimal common superdigraph <code class="code">M</code> of <var class="Arg">D1</var> and <var class="Arg">D2</var> with the minimum number of vertices. So <code class="code">M</code> is a digraph into which both <var class="Arg">D1</var> and <var class="Arg">D2</var> embed and has the smallest number of vertices among such digraphs. It returns a list <code class="code">[M, t1, t2]</code> where <code class="code">M</code> is the minimal common superdigraph and <code class="code">t1, t2</code> are transformations embedding <var class="Arg">D1</var> and <var class="Arg">D2</var> respectively into <code class="code">M</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimalCommonSuperdigraph(PetersenGraph(), CompleteDigraph(10));</span>
[ &lt;immutable digraph with 18 vertices, 118 edges&gt;, 
  IdentityTransformation, 
  Transformation( [ 1, 2, 11, 12, 13, 14, 15, 16, 17, 18, 11, 12, 13,
      14, 15, 16, 17, 18 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimalCommonSuperdigraph(PetersenGraph(),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">DigraphSymmetricClosure(CycleDigraph(5)));</span>
[ &lt;immutable digraph with 10 vertices, 30 edges&gt;, 
  IdentityTransformation, IdentityTransformation ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimalCommonSuperdigraph(NullDigraph(0), CompleteDigraph(10));</span>
[ &lt;immutable digraph with 10 vertices, 90 edges&gt;, 
  IdentityTransformation, IdentityTransformation ]
</pre></div>

<p><a id="X7E1A02FE8384C03C" name="X7E1A02FE8384C03C"></a></p>

<h4>7.3 <span class="Heading">Homomorphisms of digraphs</span></h4>

<p>The following methods exist to find homomorphisms between digraphs. If an argument to one of these methods is a digraph with multiple edges, then the multiplicity of edges will be ignored in order to perform the calculation; the digraph will be treated as if it has no multiple edges.</p>

<p><a id="X79ABF0E783FD67C7" name="X79ABF0E783FD67C7"></a></p>

<h5>7.3-1 HomomorphismDigraphsFinder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HomomorphismDigraphsFinder</code>( <var class="Arg">D1</var>, <var class="Arg">D2</var>, <var class="Arg">hook</var>, <var class="Arg">user_param</var>, <var class="Arg">max_results</var>, <var class="Arg">hint</var>, <var class="Arg">injective</var>, <var class="Arg">image</var>, <var class="Arg">partial_map</var>, <var class="Arg">colors1</var>, <var class="Arg">colors2</var>[, <var class="Arg">order</var>, <var class="Arg">aut_grp</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: The argument <var class="Arg">user_param</var>.</p>

<p>This function finds homomorphisms from the digraph <var class="Arg">D1</var> to the digraph <var class="Arg">D2</var> subject to the conditions imposed by the other arguments as described below.</p>

<p>If <code class="code">f</code> and <code class="code">g</code> are homomorphisms found by <code class="code">HomomorphismDigraphsFinder</code>, then <code class="code">f</code> cannot be obtained from <code class="code">g</code> by right multiplying by an automorphism of <var class="Arg">D2</var> in <var class="Arg">aut_grp</var>.</p>


<dl>
<dt><strong class="Mark"><var class="Arg">hook</var></strong></dt>
<dd><p>This argument should be a function or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">hook</var> is a function, then it must have two arguments <var class="Arg">user_param</var> (see below) and a transformation <code class="code">t</code>. The function <code class="code"><var class="Arg">hook</var>(<var class="Arg">user_param</var>, t)</code> is called every time a new homomorphism <code class="code">t</code> is found by <code class="code">HomomorphismDigraphsFinder</code>. If the function returns <code class="keyw">true</code>, then <code class="code">HomomorphismDigraphsFinder</code> stops and does not find any further homomorphisms. This feature might be useful if you are searching for a homomorphism that satisfies some condition that you cannot specify via the other arguments to <code class="code">HomomorphismDigraphsFinder</code>.</p>

<p>If <var class="Arg">hook</var> is <code class="keyw">fail</code>, then a default function is used which simply adds every new homomorphism found by <code class="code">HomomorphismDigraphsFinder</code> to <var class="Arg">user_param</var>, which must be a mutable list in this case.</p>

</dd>
<dt><strong class="Mark"><var class="Arg">user_param</var></strong></dt>
<dd><p>If <var class="Arg">hook</var> is a function, then <var class="Arg">user_param</var> can be any <strong class="pkg">GAP</strong> object. The object <var class="Arg">user_param</var> is used as the first argument of the function <var class="Arg">hook</var>. For example, <var class="Arg">user_param</var> might be a transformation semigroup, and <code class="code"><var class="Arg">hook</var>(<var class="Arg">user_param</var>, t)</code> might set <var class="Arg">user_param</var> to be the closure of <var class="Arg">user_param</var> and <code class="code">t</code>.</p>

<p>If the value of <var class="Arg">hook</var> is <code class="keyw">fail</code>, then the value of <var class="Arg">user_param</var> must be a mutable list.</p>

</dd>
<dt><strong class="Mark"><var class="Arg">max_results</var></strong></dt>
<dd><p>This argument should be a positive integer or <code class="keyw">infinity</code>. <code class="code">HomomorphismDigraphsFinder</code> will return after it has found <var class="Arg">max_results</var> homomorphisms or the search is complete, whichever happens first.</p>

</dd>
<dt><strong class="Mark"><var class="Arg">hint</var></strong></dt>
<dd><p>This argument should be a positive integer or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">hint</var> is a positive integer, then only homorphisms of rank <var class="Arg">hint</var> are found.</p>

<p>If <var class="Arg">hint</var> is <code class="keyw">fail</code>, then no restriction is put on the rank of homomorphisms found.</p>

</dd>
<dt><strong class="Mark"><var class="Arg">injective</var></strong></dt>
<dd><p>This argument should be <code class="code">0</code>, <code class="code">1</code>, or <code class="code">2</code>. If it is <code class="code">2</code>, then only embeddings are found, if it is <code class="code">1</code>, then only injective homomorphisms are found, and if it is <code class="code">0</code> there are no restrictions imposed by this argument.</p>

<p>For backwards compatibility, <var class="Arg">injective</var> can also be <code class="keyw">false</code> or <code class="keyw">true</code> which correspond to the values <code class="code">0</code> and <code class="code">1</code> described in the previous paragraph, respectively.</p>

</dd>
<dt><strong class="Mark"><var class="Arg">image</var></strong></dt>
<dd><p>This argument should be a subset of the vertices of the graph <var class="Arg">D2</var>. <code class="code">HomomorphismDigraphsFinder</code> only finds homomorphisms from <var class="Arg">D1</var> to the subgraph of <var class="Arg">D2</var> induced by the vertices <var class="Arg">image</var>.</p>

</dd>
<dt><strong class="Mark"><var class="Arg">partial_map</var></strong></dt>
<dd><p>This argument should be a partial map from <var class="Arg">D1</var> to <var class="Arg">D2</var>, that is, a (not necessarily dense) list of vertices of the digraph <var class="Arg">D2</var> of length no greater than the number vertices in the digraph <var class="Arg">D1</var>. <code class="code">HomomorphismDigraphsFinder</code> only finds homomorphisms extending <var class="Arg">partial_map</var> (if any).</p>

</dd>
<dt><strong class="Mark"><var class="Arg">colors1</var></strong></dt>
<dd><p>This should be a list representing possible colours of vertices in the digraph <var class="Arg">D1</var>; see <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X877732B1783C391B"><span class="RefLink">7.2-5</span></a>) for details of the permissible values for this argument.</p>

</dd>
<dt><strong class="Mark"><var class="Arg">colors2</var></strong></dt>
<dd><p>This should be a list representing possible colours of vertices in the digraph <var class="Arg">D2</var>; see <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X877732B1783C391B"><span class="RefLink">7.2-5</span></a>) for details of the permissible values for this argument.</p>

</dd>
<dt><strong class="Mark"><var class="Arg">order</var></strong></dt>
<dd><p>The optional argument <var class="Arg">order</var> specifies the order the vertices in <var class="Arg">D1</var> appear in the search for homomorphisms. The value of this parameter can have a large impact on the runtime of the function. It seems in many cases to be a good idea for this to be the <code class="func">DigraphWelshPowellOrder</code> (<a href="chap7.html#X7F9CB3B27B9590DB"><span class="RefLink">7.3-16</span></a>), i.e. vertices ordered from highest to lowest degree.</p>

</dd>
<dd><p>The optional argument <var class="Arg">aut_grp</var> should be a subgroup of the automorphism group of <var class="Arg">D2</var>. This function returns unique representatives of the homomorphisms found up to right multiplication by <var class="Arg">aut_grp</var>. If this argument is not specific, it defaults to the full automorphism group of <var class="Arg">D2</var>, which may be costly to calculate.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(10);</span>
&lt;immutable chain digraph with 10 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphSymmetricClosure(D);</span>
&lt;immutable symmetric digraph with 10 vertices, 18 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismDigraphsFinder(D, D, fail, [], infinity, 2, 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4], [], fail, fail);</span>
[ Transformation( [ 3, 4, 3, 4, 3, 4, 3, 4, 3, 4 ] ), 
  Transformation( [ 4, 3, 4, 3, 4, 3, 4, 3, 4, 3 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D2 := CompleteDigraph(6);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismDigraphsFinder(D, D2, fail, [], 1, fail, 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1 .. 6], [1, 2, 1], fail, fail);</span>
[ Transformation( [ 1, 2, 1, 3, 4, 5, 6, 1, 2, 1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function(user_param, t)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Add(user_param, t * user_param[1]);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismDigraphsFinder(D, D2, func, [Transformation([2, 2])],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">3, fail, 0, [1 .. 6], [1, 2, 1], fail, fail);</span>
[ Transformation( [ 2, 2 ] ), 
  Transformation( [ 2, 2, 2, 3, 4, 5, 6, 2, 2, 2 ] ), 
  Transformation( [ 2, 2, 2, 3, 4, 5, 6, 2, 2, 3 ] ), 
  Transformation( [ 2, 2, 2, 3, 4, 5, 6, 2, 2, 4 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismDigraphsFinder(NullDigraph(2), NullDigraph(3), fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[], infinity, fail, 1, [1, 2, 3], fail, fail, fail, fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Group(()));</span>
[ IdentityTransformation, Transformation( [ 1, 3, 3 ] ), 
  Transformation( [ 2, 1 ] ), Transformation( [ 2, 3, 3 ] ), 
  Transformation( [ 3, 1, 3 ] ), Transformation( [ 3, 2, 3 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismDigraphsFinder(NullDigraph(2), NullDigraph(3), fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[], infinity, fail, 1, [1, 2, 3], fail, fail, fail, fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Group((1, 2)));</span>
[ IdentityTransformation, Transformation( [ 1, 3, 3 ] ), 
  Transformation( [ 3, 1, 3 ] ) ]</pre></div>

<p><a id="X85E9B019877AD7FE" name="X85E9B019877AD7FE"></a></p>

<h5>7.3-2 DigraphHomomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphHomomorphism</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transformation, or <code class="keyw">fail</code>.</p>

<p>A homomorphism from <var class="Arg">digraph1</var> to <var class="Arg">digraph2</var> is a mapping from the vertex set of <var class="Arg">digraph1</var> to a subset of the vertices of <var class="Arg">digraph2</var>, such that every pair of vertices <code class="code">[i,j]</code> which has an edge <code class="code">i-&gt;j</code> is mapped to a pair of vertices <code class="code">[a,b]</code> which has an edge <code class="code">a-&gt;b</code>. Note that non-adjacent vertices can still be mapped to adjacent vertices.</p>

<p><code class="code">DigraphHomomorphism</code> returns a single homomorphism between <var class="Arg">digraph1</var> and <var class="Arg">digraph2</var> if it exists, otherwise it returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr1 := ChainDigraph(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr2 := Digraph([[3, 5], [2], [3, 1], [], [4]]);</span>
&lt;immutable digraph with 5 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphHomomorphism(gr1, gr1);</span>
IdentityTransformation
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">map := DigraphHomomorphism(gr1, gr2);</span>
Transformation( [ 3, 1, 5, 4, 5 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphHomomorphism(gr1, gr2, map);</span>
true
</pre></div>

<p><a id="X8653EDA183E06D05" name="X8653EDA183E06D05"></a></p>

<h5>7.3-3 HomomorphismsDigraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HomomorphismsDigraphs</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HomomorphismsDigraphsRepresentatives</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of transformations.</p>

<p><code class="code">HomomorphismsDigraphsRepresentatives</code> finds every <code class="func">DigraphHomomorphism</code> (<a href="chap7.html#X85E9B019877AD7FE"><span class="RefLink">7.3-2</span></a>) between <var class="Arg">digraph1</var> and <var class="Arg">digraph2</var>, up to right multiplication by an element of the <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X858C32127A190175"><span class="RefLink">7.2-2</span></a>) of <var class="Arg">digraph2</var>. In other words, every homomorphism <code class="code">f</code> between <var class="Arg">digraph1</var> and <var class="Arg">digraph2</var> can be written as the composition <code class="code">f = g * x</code>, where <code class="code">g</code> is one of the <code class="code">HomomorphismsDigraphsRepresentatives</code> and <code class="code">x</code> is an automorphism of <var class="Arg">digraph2</var>.</p>

<p><code class="code">HomomorphismsDigraphs</code> returns all homomorphisms between <var class="Arg">digraph1</var> and <var class="Arg">digraph2</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr1 := ChainDigraph(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr2 := Digraph([[3, 5], [2], [3, 1], [], [4]]);</span>
&lt;immutable digraph with 5 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismsDigraphs(gr1, gr2);</span>
[ Transformation( [ 1, 3, 1 ] ), Transformation( [ 1, 3, 3 ] ), 
  Transformation( [ 1, 5, 4, 4, 5 ] ), Transformation( [ 2, 2, 2 ] ), 
  Transformation( [ 3, 1, 3 ] ), Transformation( [ 3, 1, 5, 4, 5 ] ), 
  Transformation( [ 3, 3, 1 ] ), Transformation( [ 3, 3, 3 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismsDigraphsRepresentatives(gr1, CompleteDigraph(3));</span>
[ Transformation( [ 2, 1 ] ), Transformation( [ 2, 1, 2 ] ) ]
</pre></div>

<p><a id="X82D0FCD87D47ACA8" name="X82D0FCD87D47ACA8"></a></p>

<h5>7.3-4 DigraphMonomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphMonomorphism</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transformation, or <code class="keyw">fail</code>.</p>

<p><code class="code">DigraphMonomorphism</code> returns a single <em>injective</em> <code class="func">DigraphHomomorphism</code> (<a href="chap7.html#X85E9B019877AD7FE"><span class="RefLink">7.3-2</span></a>) between <var class="Arg">digraph1</var> and <var class="Arg">digraph2</var> if one exists, otherwise it returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr1 := ChainDigraph(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr2 := Digraph([[3, 5], [2], [3, 1], [], [4]]);</span>
&lt;immutable digraph with 5 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphMonomorphism(gr1, gr1);</span>
IdentityTransformation
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphMonomorphism(gr1, gr2);</span>
Transformation( [ 3, 1, 5, 4, 5 ] )
</pre></div>

<p><a id="X84B4BDB984C2A9A8" name="X84B4BDB984C2A9A8"></a></p>

<h5>7.3-5 MonomorphismsDigraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MonomorphismsDigraphs</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MonomorphismsDigraphsRepresentatives</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of transformations.</p>

<p>These operations behave the same as <code class="func">HomomorphismsDigraphs</code> (<a href="chap7.html#X8653EDA183E06D05"><span class="RefLink">7.3-3</span></a>) and <code class="func">HomomorphismsDigraphsRepresentatives</code> (<a href="chap7.html#X8653EDA183E06D05"><span class="RefLink">7.3-3</span></a>), except they only return <em>injective</em> homomorphisms.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr1 := ChainDigraph(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr2 := Digraph([[3, 5], [2], [3, 1], [], [4]]);</span>
&lt;immutable digraph with 5 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MonomorphismsDigraphs(gr1, gr2);</span>
[ Transformation( [ 1, 5, 4, 4, 5 ] ), 
  Transformation( [ 3, 1, 5, 4, 5 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MonomorphismsDigraphsRepresentatives(gr1, CompleteDigraph(3));</span>
[ Transformation( [ 2, 1 ] ) ]
</pre></div>

<p><a id="X7CB5AD9F861684FD" name="X7CB5AD9F861684FD"></a></p>

<h5>7.3-6 DigraphEpimorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphEpimorphism</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transformation, or <code class="keyw">fail</code>.</p>

<p><code class="code">DigraphEpimorphism</code> returns a single <em>surjective</em> <code class="func">DigraphHomomorphism</code> (<a href="chap7.html#X85E9B019877AD7FE"><span class="RefLink">7.3-2</span></a>) between <var class="Arg">digraph1</var> and <var class="Arg">digraph2</var> if one exists, otherwise it returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr1 := DigraphReverse(ChainDigraph(4));</span>
&lt;immutable digraph with 4 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr2 := DigraphRemoveEdge(CompleteDigraph(3), [1, 2]);</span>
&lt;immutable digraph with 3 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEpimorphism(gr2, gr1);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEpimorphism(gr1, gr2);</span>
Transformation( [ 3, 1, 2, 3 ] )
</pre></div>

<p><a id="X7DFB1F5D873937B3" name="X7DFB1F5D873937B3"></a></p>

<h5>7.3-7 EpimorphismsDigraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismsDigraphs</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismsDigraphsRepresentatives</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of transformations.</p>

<p>These operations behave the same as <code class="func">HomomorphismsDigraphs</code> (<a href="chap7.html#X8653EDA183E06D05"><span class="RefLink">7.3-3</span></a>) and <code class="func">HomomorphismsDigraphsRepresentatives</code> (<a href="chap7.html#X8653EDA183E06D05"><span class="RefLink">7.3-3</span></a>), except they only return <em>surjective</em> homomorphisms.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr1 := DigraphReverse(ChainDigraph(4));</span>
&lt;immutable digraph with 4 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr2 := DigraphSymmetricClosure(CycleDigraph(3));</span>
&lt;immutable symmetric digraph with 3 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EpimorphismsDigraphsRepresentatives(gr1, gr2);</span>
[ Transformation( [ 3, 1, 2, 1 ] ), Transformation( [ 3, 1, 2, 3 ] ), 
  Transformation( [ 2, 1, 2, 3 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EpimorphismsDigraphs(gr1, gr2);</span>
[ Transformation( [ 1, 2, 1, 3 ] ), Transformation( [ 1, 2, 3, 1 ] ), 
  Transformation( [ 1, 2, 3, 2 ] ), Transformation( [ 1, 3, 1, 2 ] ), 
  Transformation( [ 1, 3, 2, 1 ] ), Transformation( [ 1, 3, 2, 3 ] ), 
  Transformation( [ 2, 1, 2, 3 ] ), Transformation( [ 2, 1, 3, 1 ] ), 
  Transformation( [ 2, 1, 3, 2 ] ), Transformation( [ 2, 3, 1, 2 ] ), 
  Transformation( [ 2, 3, 1, 3 ] ), Transformation( [ 2, 3, 2, 1 ] ), 
  Transformation( [ 3, 1, 2, 1 ] ), Transformation( [ 3, 1, 2, 3 ] ), 
  Transformation( [ 3, 1, 3, 2 ] ), Transformation( [ 3, 2, 1, 2 ] ), 
  Transformation( [ 3, 2, 1, 3 ] ), Transformation( [ 3, 2, 3, 1 ] ) ]
</pre></div>

<p><a id="X7AD04CC186E86CCA" name="X7AD04CC186E86CCA"></a></p>

<h5>7.3-8 DigraphEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphEmbedding</code>( <var class="Arg">digraph1</var>, <var class="Arg">digraph2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transformation, or <code class="keyw">fail</code>.</p>

<p>An embedding of a digraph <var class="Arg">digraph1</var> into another digraph <var class="Arg">digraph2</var> is a <code class="func">DigraphMonomorphism</code> (<a href="chap7.html#X82D0FCD87D47ACA8"><span class="RefLink">7.3-4</span></a>) from <var class="Arg">digraph1</var> to <var class="Arg">digraph2</var> which has the additional property that a pair of vertices <code class="code">[i, j]</code> which have no edge <code class="code">i -&gt; j</code> in <var class="Arg">digraph1</var> are mapped to a pair of vertices <code class="code">[a, b]</code> which have no edge <code class="code">a-&gt;b</code> in <var class="Arg">digraph2</var>.</p>

<p>In other words, an embedding <code class="code">t</code> is an isomorphism from <var class="Arg">digraph1</var> to the <code class="func">InducedSubdigraph</code> (<a href="chap3.html#X83C51DA182CCEA2F"><span class="RefLink">3.3-3</span></a>) of <var class="Arg">digraph2</var> on the image of <code class="code">t</code>.</p>

<p><code class="code">DigraphEmbedding</code> returns a single embedding if one exists, otherwise it returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := ChainDigraph(3);</span>
&lt;immutable chain digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEmbedding(gr, CompleteDigraph(4));</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEmbedding(gr, Digraph([[3], [1, 4], [1], [3]]));</span>
Transformation( [ 2, 4, 3, 4 ] )
</pre></div>

<p><a id="X82EBDF137EEDC5FD" name="X82EBDF137EEDC5FD"></a></p>

<h5>7.3-9 EmbeddingsDigraphs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EmbeddingsDigraphs</code>( <var class="Arg">D1</var>, <var class="Arg">D2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EmbeddingsDigraphsRepresentatives</code>( <var class="Arg">D1</var>, <var class="Arg">D2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of transformations.</p>

<p>These operations behave the same as <code class="func">HomomorphismsDigraphs</code> (<a href="chap7.html#X8653EDA183E06D05"><span class="RefLink">7.3-3</span></a>) and <code class="func">HomomorphismsDigraphsRepresentatives</code> (<a href="chap7.html#X8653EDA183E06D05"><span class="RefLink">7.3-3</span></a>), except they only return embeddings of <var class="Arg">D1</var> into <var class="Arg">D2</var>.</p>

<p>See also <code class="func">IsDigraphEmbedding</code> (<a href="chap7.html#X7D6B5A0887903810"><span class="RefLink">7.3-11</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D1 := NullDigraph(2);</span>
&lt;immutable empty digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D2 := CycleDigraph(5);</span>
&lt;immutable cycle digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EmbeddingsDigraphsRepresentatives(D1, D2);</span>
[ Transformation( [ 1, 3, 3 ] ), Transformation( [ 1, 4, 3, 4 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EmbeddingsDigraphs(D1, D2);</span>
[ Transformation( [ 1, 3, 3 ] ), Transformation( [ 1, 4, 3, 4 ] ), 
  Transformation( [ 2, 4, 4, 5, 1 ] ), 
  Transformation( [ 2, 5, 4, 5, 1 ] ), 
  Transformation( [ 3, 1, 5, 1, 2 ] ), 
  Transformation( [ 3, 5, 5, 1, 2 ] ), 
  Transformation( [ 4, 1, 1, 2, 3 ] ), 
  Transformation( [ 4, 2, 1, 2, 3 ] ), 
  Transformation( [ 5, 2, 2, 3, 4 ] ), 
  Transformation( [ 5, 3, 2, 3, 4 ] ) ]
</pre></div>

<p><a id="X80FE9FCB79718A61" name="X80FE9FCB79718A61"></a></p>

<h5>7.3-10 IsDigraphHomomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphHomomorphism</code>( <var class="Arg">src</var>, <var class="Arg">ran</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphHomomorphism</code>( <var class="Arg">src</var>, <var class="Arg">ran</var>, <var class="Arg">x</var>, <var class="Arg">col1</var>, <var class="Arg">col2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphEpimorphism</code>( <var class="Arg">src</var>, <var class="Arg">ran</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphEpimorphism</code>( <var class="Arg">src</var>, <var class="Arg">ran</var>, <var class="Arg">x</var>, <var class="Arg">col1</var>, <var class="Arg">col2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphMonomorphism</code>( <var class="Arg">src</var>, <var class="Arg">ran</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphMonomorphism</code>( <var class="Arg">src</var>, <var class="Arg">ran</var>, <var class="Arg">x</var>, <var class="Arg">col1</var>, <var class="Arg">col2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphEndomorphism</code>( <var class="Arg">digraph</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphEndomorphism</code>( <var class="Arg">digraph</var>, <var class="Arg">x</var>, <var class="Arg">col</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p><code class="code">IsDigraphHomomorphism</code> returns <code class="keyw">true</code> if the permutation or transformation <var class="Arg">x</var> is a homomorphism from the digraph <var class="Arg">src</var> to the digraph <var class="Arg">ran</var>.</p>

<p><code class="code">IsDigraphEpimorphism</code> returns <code class="keyw">true</code> if the permutation or transformation <var class="Arg">x</var> is a surjective homomorphism from the digraph <var class="Arg">src</var> to the digraph <var class="Arg">ran</var>.</p>

<p><code class="code">IsDigraphMonomorphism</code> returns <code class="keyw">true</code> if the permutation or transformation <var class="Arg">x</var> is an injective homomorphism from the digraph <var class="Arg">src</var> to the digraph <var class="Arg">ran</var>.</p>

<p><code class="code">IsDigraphEndomorphism</code> returns <code class="keyw">true</code> if the permutation or transformation <var class="Arg">x</var> is an endomorphism of the digraph <var class="Arg">digraph</var>.</p>

<p>A permutation or transformation <var class="Arg">x</var> is a <em>homomorphism</em> from a digraph <var class="Arg">src</var> to a digraph <var class="Arg">ran</var> if the following hold:</p>


<ul>
<li><p><code class="code">[u ^ <var class="Arg">x</var>, v ^ <var class="Arg">x</var>]</code> is an edge of <var class="Arg">ran</var> whenever <code class="code">[u, v]</code> is an edge of <var class="Arg">src</var>; and</p>

</li>
<li><p><var class="Arg">x</var> fixes every <code class="code">i</code> which is not a vertex of <var class="Arg">src</var>.</p>

</li>
</ul>
<p>See also <code class="func">GeneratorsOfEndomorphismMonoid</code> (<a href="chap7.html#X7E93B268823F6478"><span class="RefLink">7.3-13</span></a>).</p>

<p>If <var class="Arg">col1</var> and <var class="Arg">col2</var>, or <var class="Arg">col</var>, are given, then they must represent vertex colourings; see <code class="func">AutomorphismGroup</code> (<a href="chap7.html#X877732B1783C391B"><span class="RefLink">7.2-5</span></a>) for details of the permissible values for these argument. The homomorphism must then also have the property:</p>


<ul>
<li><p><code class="code">col[i] = col[i ^ x]</code> for all vertices <code class="code">i</code> of <var class="Arg">digraph</var>, in the case of <code class="code">IsDigraphEndomorphism</code>.</p>

</li>
<li><p><code class="code">col1[i] = col2[i ^ x]</code> for all vertices <code class="code">i</code> of <var class="Arg">src</var>, in the cases of the other operations.</p>

</li>
</ul>
<p>See also <code class="func">DigraphsRespectsColouring</code> (<a href="chap7.html#X7F80709A80CBFA98"><span class="RefLink">7.3-12</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">src := Digraph([[1], [1, 2], [1, 3]]);</span>
&lt;immutable digraph with 3 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ran := Digraph([[1], [1, 2]]);</span>
&lt;immutable digraph with 2 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphHomomorphism(src, ran, Transformation([1, 2, 2]));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphHomomorphism(src, ran, Transformation([2, 1, 2]));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphHomomorphism(src, ran, Transformation([3, 3, 3]));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphHomomorphism(src, src, Transformation([3, 3, 3]));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphHomomorphism(src, ran, Transformation([1, 2, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         [1, 2, 2], [1, 2]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphHomomorphism(src, ran, Transformation([1, 2, 2]),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         [2, 1, 1], [1, 2]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEndomorphism(src, Transformation([3, 3, 3]));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEndomorphism(src, Transformation([3, 3, 3]), [1, 1, 1]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEndomorphism(src, Transformation([3, 3, 3]), [1, 1, 2]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEpimorphism(src, ran, Transformation([3, 3, 3]));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphMonomorphism(src, ran, Transformation([1, 2, 2]));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEpimorphism(src, ran, Transformation([1, 2, 2]));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphMonomorphism(ran, src, ());</span>
true</pre></div>

<p><a id="X7D6B5A0887903810" name="X7D6B5A0887903810"></a></p>

<h5>7.3-11 IsDigraphEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphEmbedding</code>( <var class="Arg">src</var>, <var class="Arg">ran</var>, <var class="Arg">x</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphEmbedding</code>( <var class="Arg">src</var>, <var class="Arg">ran</var>, <var class="Arg">x</var>, <var class="Arg">col1</var>, <var class="Arg">col2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p><code class="code">IsDigraphEmbedding</code> returns <code class="keyw">true</code> if the permutation or transformation <var class="Arg">x</var> is a embedding of the digraph <var class="Arg">src</var> into the digraph <var class="Arg">ran</var>, while respecting the colourings <var class="Arg">col1</var> and <var class="Arg">col2</var> if given.</p>

<p>A permutation or transformation <var class="Arg">x</var> is a <em>embedding</em> of a digraph <var class="Arg">src</var> into a digraph <var class="Arg">ran</var> if <var class="Arg">x</var> is a monomorphism from <var class="Arg">src</var> to <var class="Arg">ran</var> and the inverse of <var class="Arg">x</var> is a monomorphism from the subdigraph of <var class="Arg">ran</var> induced by the image of <var class="Arg">x</var> to <var class="Arg">src</var>. See also <code class="func">IsDigraphHomomorphism</code> (<a href="chap7.html#X80FE9FCB79718A61"><span class="RefLink">7.3-10</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">src := Digraph([[1], [1, 2]]);</span>
&lt;immutable digraph with 2 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ran := Digraph([[1], [1, 2], [1, 3]]);</span>
&lt;immutable digraph with 3 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphMonomorphism(src, ran, ());</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEmbedding(src, ran, ());</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEmbedding(src, ran, (), [2, 1], [2, 1, 1]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEmbedding(src, ran, (), [2, 1], [1, 2, 1]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ran := Digraph([[1, 2], [1, 2], [1, 3]]);</span>
&lt;immutable digraph with 3 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphMonomorphism(src, ran, IdentityTransformation);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEmbedding(src, ran, IdentityTransformation);</span>
false</pre></div>

<p><a id="X7F80709A80CBFA98" name="X7F80709A80CBFA98"></a></p>

<h5>7.3-12 DigraphsRespectsColouring</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphsRespectsColouring</code>( <var class="Arg">src</var>, <var class="Arg">ran</var>, <var class="Arg">x</var>, <var class="Arg">col1</var>, <var class="Arg">col2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>The operation <code class="code">DigraphsRespectsColouring</code> verifies whether or not the permutation or transformation <var class="Arg">x</var> respects the vertex colourings <var class="Arg">col1</var> and <var class="Arg">col2</var> of the digraphs <var class="Arg">src</var> and <var class="Arg">range</var>. That is, <code class="code">DigraphsRespectsColouring</code> returns <code class="keyw">true</code> if and only if for all vertices <code class="code">i</code> of <var class="Arg">src</var>, <code class="code">col1[i] = col2[i ^ x]</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">src := Digraph([[1], [1, 2]]);</span>
&lt;immutable digraph with 2 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ran := Digraph([[1], [1, 2], [1, 3]]);</span>
&lt;immutable digraph with 3 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphsRespectsColouring(src, ran, (1, 2), [2, 1], [1, 2, 1]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphsRespectsColouring(src, ran, (1, 2), [2, 1], [2, 1, 1]);</span>
false
</pre></div>

<p><a id="X7E93B268823F6478" name="X7E93B268823F6478"></a></p>

<h5>7.3-13 GeneratorsOfEndomorphismMonoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeneratorsOfEndomorphismMonoid</code>( <var class="Arg">digraph</var>[, <var class="Arg">colors</var>][, <var class="Arg">limit</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeneratorsOfEndomorphismMonoidAttr</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of transformations.</p>

<p>An endomorphism of <var class="Arg">digraph</var> is a homomorphism <code class="func">DigraphHomomorphism</code> (<a href="chap7.html#X85E9B019877AD7FE"><span class="RefLink">7.3-2</span></a>) from <var class="Arg">digraph</var> back to itself. <code class="code">GeneratorsOfEndomorphismMonoid</code>, called with a single argument, returns a generating set for the monoid of all endomorphisms of <var class="Arg">digraph</var>. If <var class="Arg">digraph</var> belongs to <code class="func">IsImmutableDigraph</code> (<a href="chap3.html#X7CAFAA89804F80BD"><span class="RefLink">3.1-3</span></a>), then the value of <code class="code">GeneratorsOfEndomorphismMonoid</code> will not be recomputed on future calls.</p>

<p>If the <var class="Arg">colors</var> argument is specified, then <code class="code">GeneratorsOfEndomorphismMonoid</code> will return a generating set for the monoid of endomorphisms which respect the given colouring. The colouring <var class="Arg">colors</var> can be in one of two forms:</p>


<ul>
<li><p>A list of positive integers of size the number of vertices of <var class="Arg">digraph</var>, where <var class="Arg">colors</var><code class="code">[i]</code> is the colour of vertex <code class="code">i</code>.</p>

</li>
<li><p>A list of lists, such that <var class="Arg">colors</var><code class="code">[i]</code> is a list of all vertices with colour <code class="code">i</code>.</p>

</li>
</ul>
<p>If the <var class="Arg">limit</var> argument is specified, then it will return only the first <var class="Arg">limit</var> homomorphisms, where <var class="Arg">limit</var> must be a positive integer or <code class="code">infinity</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(List([1 .. 3], x -&gt; [1 .. 3]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfEndomorphismMonoid(gr);</span>
[ Transformation( [ 1, 3, 2 ] ), Transformation( [ 2, 1 ] ), 
  IdentityTransformation, Transformation( [ 1, 2, 1 ] ), 
  Transformation( [ 1, 2, 2 ] ), Transformation( [ 1, 1, 2 ] ), 
  Transformation( [ 1, 1, 1 ] ) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfEndomorphismMonoid(gr, 3);</span>
[ Transformation( [ 1, 3, 2 ] ), Transformation( [ 2, 1 ] ), 
  IdentityTransformation ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := CompleteDigraph(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfEndomorphismMonoid(gr);</span>
[ Transformation( [ 2, 3, 1 ] ), Transformation( [ 2, 1 ] ), 
  IdentityTransformation ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfEndomorphismMonoid(gr, [1, 2, 2]);</span>
[ Transformation( [ 1, 3, 2 ] ), IdentityTransformation ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfEndomorphismMonoid(gr, [[1], [2, 3]]);</span>
[ Transformation( [ 1, 3, 2 ] ), IdentityTransformation ]
</pre></div>

<p><a id="X86D0A74B83D6B9A7" name="X86D0A74B83D6B9A7"></a></p>

<h5>7.3-14 DigraphColouring</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphColouring</code>( <var class="Arg">digraph</var>, <var class="Arg">n</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transformation, or <code class="keyw">fail</code>.</p>

<p>A <em>proper colouring</em> of a digraph is a labelling of its vertices in such a way that adjacent vertices have different labels. A <em>proper <code class="code">n</code>-colouring</em> is a proper colouring that uses exactly <code class="code">n</code> colours. Equivalently, a proper (<code class="code">n</code>-)colouring of a digraph can be defined to be a <code class="func">DigraphEpimorphism</code> (<a href="chap7.html#X7CB5AD9F861684FD"><span class="RefLink">7.3-6</span></a>) from a digraph onto the complete digraph (with <code class="code">n</code> vertices); see <code class="func">CompleteDigraph</code> (<a href="chap3.html#X812417E278198D9C"><span class="RefLink">3.5-11</span></a>). Note that a digraph with loops (<code class="func">DigraphHasLoops</code> (<a href="chap6.html#X7D92935C7D535187"><span class="RefLink">6.2-1</span></a>)) does not have a proper <code class="code">n</code>-colouring for any value <code class="code">n</code>.</p>

<p>If <var class="Arg">digraph</var> is a digraph and <var class="Arg">n</var> is a non-negative integer, then <code class="code">DigraphColouring(<var class="Arg">digraph</var>, <var class="Arg">n</var>)</code> returns an epimorphism from <var class="Arg">digraph</var> onto the complete digraph with <var class="Arg">n</var> vertices if one exists, else it returns <code class="keyw">fail</code>.</p>

<p>See also <code class="func">DigraphGreedyColouring</code> (<a href="chap7.html#X7AB7200D831013C1"><span class="RefLink">7.3-15</span></a>) and</p>

<p>Note that a digraph with at least two vertices has a 2-colouring if and only if it is bipartite, see <code class="func">IsBipartiteDigraph</code> (<a href="chap6.html#X860CFB0C8665F356"><span class="RefLink">6.2-3</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphColouring(CompleteDigraph(5), 4);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphColouring(ChainDigraph(10), 1);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(10);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := DigraphColouring(D, 2);</span>
Transformation( [ 1, 2, 1, 2, 1, 2, 1, 2, 1, 2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphColouring(D, t); </span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGreedyColouring(D);</span>
Transformation( [ 2, 1, 2, 1, 2, 1, 2, 1, 2, 1 ] )
</pre></div>

<p><a id="X7AB7200D831013C1" name="X7AB7200D831013C1"></a></p>

<h5>7.3-15 DigraphGreedyColouring</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphGreedyColouring</code>( <var class="Arg">digraph</var>, <var class="Arg">order</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphGreedyColouring</code>( <var class="Arg">digraph</var>, <var class="Arg">func</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphGreedyColouring</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A transformation, or <code class="keyw">fail</code>.</p>

<p>A <em>proper colouring</em> of a digraph is a labelling of its vertices in such a way that adjacent vertices have different labels. Note that a digraph with loops (<code class="func">DigraphHasLoops</code> (<a href="chap6.html#X7D92935C7D535187"><span class="RefLink">6.2-1</span></a>)) does not have any proper colouring.</p>

<p>If <var class="Arg">digraph</var> is a digraph and <var class="Arg">order</var> is a dense list consisting of all of the vertices of <var class="Arg">digraph</var> (in any order), then <code class="code">DigraphGreedyColouring</code> uses a greedy algorithm with the specified order to obtain some proper colouring of <var class="Arg">digraph</var>, which may not use the minimal number of colours.</p>

<p>If <var class="Arg">digraph</var> is a digraph and <var class="Arg">func</var> is a function whose argument is a digraph, and that returns a dense list <var class="Arg">order</var>, then <code class="code">DigraphGreedyColouring(<var class="Arg">digraph</var>, <var class="Arg">func</var>)</code> returns <code class="code">DigraphGreedyColouring(<var class="Arg">digraph</var>, <var class="Arg">func</var>(<var class="Arg">digraph</var>))</code>.</p>

<p>If the optional second argument (either a list or a function), is not specified, then <code class="func">DigraphWelshPowellOrder</code> (<a href="chap7.html#X7F9CB3B27B9590DB"><span class="RefLink">7.3-16</span></a>) is used by default.</p>

<p>See also <code class="func">DigraphColouring</code> (<a href="chap7.html#X86D0A74B83D6B9A7"><span class="RefLink">7.3-14</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGreedyColouring(ChainDigraph(10));</span>
Transformation( [ 2, 1, 2, 1, 2, 1, 2, 1, 2, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGreedyColouring(ChainDigraph(10), [1 .. 10]);</span>
Transformation( [ 1, 2, 1, 2, 1, 2, 1, 2, 1, 2 ] )
</pre></div>

<p><a id="X7F9CB3B27B9590DB" name="X7F9CB3B27B9590DB"></a></p>

<h5>7.3-16 DigraphWelshPowellOrder</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphWelshPowellOrder</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of the vertices.</p>

<p><code class="code">DigraphWelshPowellOrder</code> returns a list of all of the vertices of the digraph <var class="Arg">digraph</var> ordered according to the sum of the number of out- and in-neighbours, from highest to lowest.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphWelshPowellOrder(Digraph([[4], [9], [9], [], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                    [4, 6, 9], [1], [], [], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                    [4, 5], [4, 5]]));</span>
[ 5, 9, 4, 1, 6, 10, 2, 3, 7, 8 ]
</pre></div>

<p><a id="X807D49358529A37C" name="X807D49358529A37C"></a></p>

<h5>7.3-17 ChromaticNumber</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ChromaticNumber</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A non-negative integer.</p>

<p>A <em>proper colouring</em> of a digraph is a labelling of its vertices in such a way that adjacent vertices have different labels. Equivalently, a proper digraph colouring can be defined to be a <code class="func">DigraphEpimorphism</code> (<a href="chap7.html#X7CB5AD9F861684FD"><span class="RefLink">7.3-6</span></a>) from a digraph onto a complete digraph.</p>

<p>If <var class="Arg">digraph</var> is a digraph without loops (see <code class="func">DigraphHasLoops</code> (<a href="chap6.html#X7D92935C7D535187"><span class="RefLink">6.2-1</span></a>), then <code class="code">ChromaticNumber</code> returns the least non-negative integer <code class="code">n</code> such that there is a proper colouring of <var class="Arg">digraph</var> with <code class="code">n</code> colours. In other words, for a digraph with at least one vertex, <code class="code">ChromaticNumber</code> returns the least number <code class="code">n</code> such that <code class="code">DigraphColouring(<var class="Arg">digraph</var>, n)</code> does not return <code class="keyw">fail</code>. See <code class="func">DigraphColouring</code> (<a href="chap7.html#X86D0A74B83D6B9A7"><span class="RefLink">7.3-14</span></a>).</p>

<p>It is possible to select the algorithm to compute the chromatic number via the use of value options. The permitted algorithms and values to pass as options are:</p>


<ul>
<li><p><code class="code">lawler</code> - Lawler's Algorithm <a href="chapBib.html#biBLaw1976">[Law76]</a></p>

</li>
<li><p><code class="code">byskov</code> - Byskov's Algorithm <a href="chapBib.html#biBBys2002">[Bys02]</a></p>

</li>
</ul>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChromaticNumber(NullDigraph(10));</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChromaticNumber(CompleteDigraph(10));</span>
10
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChromaticNumber(CompleteBipartiteDigraph(5, 5));</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChromaticNumber(Digraph([[], [3], [5], [2, 3], [4]]));</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChromaticNumber(NullDigraph(0));</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := PetersenGraph(IsMutableDigraph);</span>
&lt;mutable digraph with 10 vertices, 30 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChromaticNumber(D);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChromaticNumber(CompleteDigraph(10) : lawler);</span>
10
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ChromaticNumber(CompleteDigraph(10) : byskov);</span>
10
</pre></div>

<p><a id="X863487EF7D64EF56" name="X863487EF7D64EF56"></a></p>

<h5>7.3-18 DigraphCore</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphCore</code>( <var class="Arg">D</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of positive integers.</p>

<p>If <var class="Arg">D</var> is a digraph, then <code class="code">DigraphCore</code> returns a list of vertices corresponding to the <code class="code">core</code> of <var class="Arg">D</var>. In particular, the subdigraph of <var class="Arg">D</var> induced by this list is isomorphic to the core of <var class="Arg">D</var>.</p>

<p>The <em>core</em> of a digraph <code class="code">D</code> is the minimal subdigraph <var class="Arg">C</var> of <code class="code">D</code> which is a homomorphic image of <code class="code">D</code>. The core of a digraph is unique up to isomorphism.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphSymmetricClosure(CycleDigraph(8));</span>
&lt;immutable symmetric digraph with 8 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphCore(D);</span>
[ 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := PetersenGraph();</span>
&lt;immutable digraph with 10 vertices, 30 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphCore(D);</span>
[ 1 .. 10 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3], [3], [4], [5], [2]]);</span>
&lt;mutable digraph with 5 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphCore(D);</span>
[ 2, 3, 4, 5 ]
</pre></div>

<p><a id="X7EEA340C81FCA52D" name="X7EEA340C81FCA52D"></a></p>

<h5>7.3-19 LatticeDigraphEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LatticeDigraphEmbedding</code>( <var class="Arg">L1</var>, <var class="Arg">L2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A transformation, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">L1</var> and <var class="Arg">L2</var> are lattice digraphs (<code class="func">IsLatticeDigraph</code> (<a href="chap6.html#X78D3E17B7F737516"><span class="RefLink">6.3-3</span></a>) returns <code class="keyw">true</code>, then <code class="code">LatticeDigraphEmbedding</code> returns a single <em>injective</em> <code class="func">DigraphHomomorphism</code> (<a href="chap7.html#X85E9B019877AD7FE"><span class="RefLink">7.3-2</span></a>) between <var class="Arg">L1</var> and <var class="Arg">L2</var>, with the property that it is a <em>lattice homomorphism</em>. If no such homomorphism exists, <code class="keyw">fail</code> is returned.</p>

<p>A <em>lattice homomorphism</em> is a digraph homomorphism which respects meets and joins of every pair of vertices. Note that every injective lattice homomorphism <code class="code">map</code> is an embedding, in the sense that the inverse of <code class="code">map</code> is a lattice homomorphism also.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphReflexiveTransitiveClosure(ChainDigraph(5));</span>
&lt;immutable preorder digraph with 5 vertices, 15 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L1 := DigraphReflexiveTransitiveClosure(ChainDigraph(5));</span>
&lt;immutable preorder digraph with 5 vertices, 15 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L2 := DigraphReflexiveTransitiveClosure(ChainDigraph(6));</span>
&lt;immutable preorder digraph with 6 vertices, 21 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LatticeDigraphEmbedding(L1, L2);</span>
IdentityTransformation
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LatticeDigraphEmbedding(L2, L1);</span>
fail
</pre></div>

<p><a id="X7E183D4979D324EF" name="X7E183D4979D324EF"></a></p>

<h5>7.3-20 IsLatticeHomomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLatticeHomomorphism</code>( <var class="Arg">L1</var>, <var class="Arg">L2</var>, <var class="Arg">map</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLatticeEpimorphism</code>( <var class="Arg">L1</var>, <var class="Arg">L2</var>, <var class="Arg">map</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLatticeEmbedding</code>( <var class="Arg">L1</var>, <var class="Arg">L2</var>, <var class="Arg">map</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLatticeMonomorphism</code>( <var class="Arg">L1</var>, <var class="Arg">L2</var>, <var class="Arg">map</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLatticeEndomorphism</code>( <var class="Arg">L</var>, <var class="Arg">map</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>Each of the function described in this section (except <code class="code">IsLatticeEndomorphism</code>) takes a pair of digraphs <var class="Arg">L1</var> and <var class="Arg">L2</var>, and a transformation <var class="Arg">map</var>, returning <code class="keyw">true</code> if <var class="Arg">map</var> is a <em>lattice homomorphism</em> from <var class="Arg">L1</var> to <var class="Arg">L2</var>, and <code class="keyw">false</code> otherwise. If <var class="Arg">L1</var> or <var class="Arg">L2</var> is not a lattice, then <code class="keyw">false</code> is returned.</p>

<p>A transformation or permutation <var class="Arg">map</var> is a <em>lattice homomorphism</em> if <var class="Arg">map</var> respects meets and joins of every pair of vertices, and <var class="Arg">map</var> fixes every <code class="code">i</code> which is not a vertex of <var class="Arg">L1</var>.</p>

<p><code class="code">IsLatticeHomomorphism</code> returns <code class="keyw">true</code> if the permutation or transformation <var class="Arg">map</var> is a lattice homomorphism from the lattice digraph <var class="Arg">L1</var> to the lattice digraph <var class="Arg">L2</var>.</p>

<p><code class="code">IsLatticeEpimorphism</code> returns <code class="keyw">true</code> if the permutation or transformation <var class="Arg">map</var> is a surjective lattice homomorphism from the lattice digraph <var class="Arg">L1</var> to the lattice digraph <var class="Arg">L2</var>.</p>

<p><code class="code">IsLatticeEmbedding</code> returns <code class="keyw">true</code> if the permutation or transformation <var class="Arg">map</var> is an injective lattice homomorphism from the lattice digraph <var class="Arg">L1</var> to the lattice digraph <var class="Arg">L2</var>. The function <code class="code">IsLatticeMonomorphism</code> is a synonym of <code class="code">IsLatticeEmbedding</code>.</p>

<p><code class="code">IsLatticeEndomorphism</code> returns <code class="keyw">true</code> if the permutation or transformation <var class="Arg">map</var> is an lattice endomorphism of the lattice digraph <var class="Arg">L</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Digraph([[2, 4], [3, 7], [6], [5, 7], [6], [], [6]]);</span>
&lt;immutable digraph with 7 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphRemoveVertex(G, 7);</span>
&lt;immutable digraph with 6 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DigraphReflexiveTransitiveClosure(G);</span>
&lt;immutable preorder digraph with 7 vertices, 22 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphReflexiveTransitiveClosure(D);</span>
&lt;immutable preorder digraph with 6 vertices, 17 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEmbedding(D, G, IdentityTransformation);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLatticeHomomorphism(D, G, IdentityTransformation);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 3], [4], [4], []]);</span>
&lt;immutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := Digraph([[2, 3], [4], [4], [5], []]);</span>
&lt;immutable digraph with 5 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphReflexiveTransitiveClosure(D);</span>
&lt;immutable preorder digraph with 4 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DigraphReflexiveTransitiveClosure(G);</span>
&lt;immutable preorder digraph with 5 vertices, 14 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLatticeEmbedding(D, G, IdentityTransformation);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLatticeMonomorphism(D, G, IdentityTransformation);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := Transformation([1, 2, 3, 4, 4]);</span>
Transformation( [ 1, 2, 3, 4, 4 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLatticeEpimorphism(G, D, f);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLatticeEndomorphism(D, (2, 3));</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap6.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap8.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chapA.html">A</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
