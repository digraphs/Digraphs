<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (digraphs) - Chapter 5: Attributes and operations</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap5"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chapA_mj.html">A</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap6_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap5.html">[MathJax off]</a></p>
<p><a id="X8739F6CD78C90B14" name="X8739F6CD78C90B14"></a></p>
<div class="ChapSects"><a href="chap5_mj.html#X8739F6CD78C90B14">5 <span class="Heading">Attributes and operations</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X7E814B6478F7D015">5.1 <span class="Heading">Vertices and edges</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C45F7D878D896AC">5.1-1 DigraphVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C6F19B57CB2E882">5.1-2 DigraphNrVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7D1C6A4D7ECEC317">5.1-3 DigraphEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X85E1CFDD7E164AD0">5.1-4 DigraphNrEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7BDABAF07917462B">5.1-5 DigraphNrLoops</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X85D5E08280914EE4">5.1-6 DigraphSinks</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7F5C6268839BE98C">5.1-7 DigraphSources</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X785C30378064CF47">5.1-8 DigraphTopologicalSort</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7CA91E4B7904F793">5.1-9 DigraphVertexLabel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7E51F2FE87140B32">5.1-10 DigraphVertexLabels</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X79FAEACC7F438C2F">5.1-11 DigraphEdgeLabel</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C24851087D4A8FB">5.1-12 DigraphEdgeLabels</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7EFAF01B7A155157">5.1-13 DigraphInEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7BECFE6687ECD028">5.1-14 DigraphOutEdges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7BB8ED88835F07B4">5.1-15 IsDigraphEdge</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X848FED0B7B4ACD1F">5.1-16 IsMatching</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7B7A67277B1C9A02">5.1-17 DigraphMaximalMatching</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X78E9847A858788D1">5.1-18 DigraphMaximumMatching</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X7D7CE8328187D0DF">5.2 <span class="Heading">Neighbours and degree</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7DC2CD70830BEE60">5.2-1 AdjacencyMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X87FA0A727CDB060B">5.2-2 CharacteristicPolynomial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8507DC4F794780C1">5.2-3 BooleanAdjacencyMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7AFCE34A7A04D5C1">5.2-4 DigraphAdjacencyFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7FDEBF3279759961">5.2-5 DigraphRange</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7E9880767AE68E00">5.2-6 OutNeighbours</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X85C7AA5A81DA6E11">5.2-7 InNeighbours</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7F5ACE807D1BC2E2">5.2-8 OutDegrees</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7ADDFBFD7A365775">5.2-9 InDegrees</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7A09EB648070276D">5.2-10 OutDegreeOfVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X83315B0186850806">5.2-11 OutNeighboursOfVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C9CD0527CB9E6EF">5.2-12 InDegreeOfVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C0DA18B8291F302">5.2-13 InNeighboursOfVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X83271F607BD809CF">5.2-14 DigraphLoops</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7BEAE1C78267F54D">5.2-15 DegreeMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X865390B08331936B">5.2-16 LaplacianMatrix</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X86424F167BD4F629">5.3 <span class="Heading">Orders</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7DDB33B686B3A2C6">5.3-1 PartialOrderDigraphMeetOfVertices</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X824B9896798530F6">5.3-2 NonUpperSemimodularPair</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X8537F4088400DC48">5.4 <span class="Heading">Reachability and connectivity</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7F16B9EB8398459C">5.4-1 DigraphDiameter</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8104A9D37BCD8A05">5.4-2 DigraphShortestDistance</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X81F99BC67E9D050F">5.4-3 DigraphShortestDistances</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8223718079D98A82">5.4-4 DigraphLongestDistanceFromVertex</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7CB7DDCD84621D38">5.4-5 DigraphDistanceSet</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X79A3DA4078CF3C90">5.4-6 DigraphGirth</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8374B7357EC189C1">5.4-7 DigraphOddGirth</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X84688B337BDDBB09">5.4-8 DigraphUndirectedGirth</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X842FAD6A7B835977">5.4-9 DigraphConnectedComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8484EC557810CD31">5.4-10 DigraphConnectedComponent</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X833ECD6B7A84944C">5.4-11 DigraphStronglyConnectedComponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7EFCB5017D662254">5.4-12 DigraphStronglyConnectedComponent</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7F1B5A2782F598B1">5.4-13 DigraphBicomponents</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7DDE06E47E605DD7">5.4-14 ArticulationPoints</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X84D5A125848BD800">5.4-15 Bridges</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X865590147BD1C507">5.4-16 StrongOrientation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X853D0B0981A33433">5.4-17 DigraphPeriod</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X864A31A8809F61C2">5.4-18 DigraphFloydWarshall</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7FBAB09E7C0BE5CF">5.4-19 IsReachable</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7ECD22877AEA89CC">5.4-20 IsDigraphPath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7F255A2A84CB868C">5.4-21 VerticesReachableFrom</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8039170B82A32257">5.4-22 DigraphPath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X80E9D645843973A6">5.4-23 DigraphShortestPath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C45396C808308C4">5.4-24 DigraphRandomWalk</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X787459247B2005E6">5.4-25 DigraphAbsorptionProbabilities</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7B0A62CF7F6F23E9">5.4-26 DigraphAbsorptionExpectedSteps</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7FE79CB278CE6991">5.4-27 Dominators</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7D66A0FB7F6100FB">5.4-28 DominatorTree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C0416FE7A69CA2C">5.4-29 IteratorOfPaths</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7ECD16838704FAAA">5.4-30 DigraphAllSimpleCircuits</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C735C4E86BDD5F6">5.4-31 DigraphLongestSimpleCircuit</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X870E04307C5F213F">5.4-32 DigraphLayers</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7B2E42327DA118E0">5.4-33 DigraphDegeneracy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X827C2BD17A4547E3">5.4-34 DigraphDegeneracyOrdering</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X863FDFC4839A3B82">5.4-35 HamiltonianPath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X82F30D5681466BC6">5.4-36 NrSpanningTrees</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X79352A8286D1D8F6">5.4-37 DigraphDijkstra</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X794CD6037D4CF58C">5.4-38 DigraphCycleBasis</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X82F900777D677F55">5.5 <span class="Heading">Cayley graphs of groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7A000B1D7CCF7093">5.5-1 GroupOfCayleyDigraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X8528455987D7D2BF">5.5-2 GeneratorsOfCayleyDigraph</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X790FD6647ECCAE3C">5.6 <span class="Heading">Associated semigroups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X87D5C60D7B0C1309">5.6-1 AsSemigroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7C6D5EC27C51066B">5.6-2 AsSemigroup</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5_mj.html#X7E2305528492DDC0">5.7 <span class="Heading">Planarity</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X7DC478637E8C190D">5.7-1 KuratowskiPlanarSubdigraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X78E8F09A8286501B">5.7-2 KuratowskiOuterPlanarSubdigraph</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X84E3947E7D39BA64">5.7-3 PlanarEmbedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X85DFB8C18088711F">5.7-4 OuterPlanarEmbedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5_mj.html#X806D2D6B85E0B269">5.7-5 SubdigraphHomeomorphicToK23</a></span>
</div></div>
</div>

<h3>5 <span class="Heading">Attributes and operations</span></h3>

<p><a id="X7E814B6478F7D015" name="X7E814B6478F7D015"></a></p>

<h4>5.1 <span class="Heading">Vertices and edges</span></h4>

<p><a id="X7C45F7D878D896AC" name="X7C45F7D878D896AC"></a></p>

<h5>5.1-1 DigraphVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphVertices</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of positive integers.</p>

<p>Returns the vertices of the digraph <var class="Arg">digraph</var>.</p>

<p>Note that the vertices of a digraph are always the range of positive integers from <code class="code">1</code> to the number of vertices of the graph, <code class="func">DigraphNrVertices</code> (<a href="chap5_mj.html#X7C6F19B57CB2E882"><span class="RefLink">5.1-2</span></a>). Arbitrary <em>labels</em> can be assigned to the vertices of a digraph; see <code class="func">DigraphVertexLabels</code> (<a href="chap5_mj.html#X7E51F2FE87140B32"><span class="RefLink">5.1-10</span></a>) for more information about this.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "c", "a"]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertices(gr);</span>
[ 1 .. 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([1, 2, 3, 4, 5, 7],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 [1, 2, 2, 4, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 [2, 7, 5, 3, 7]);</span>
&lt;immutable digraph with 6 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertices(gr);</span>
[ 1 .. 6 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertices(RandomDigraph(100));</span>
[ 1 .. 100 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertices(D);</span>
[ 1 .. 3 ]
</pre></div>

<p><a id="X7C6F19B57CB2E882" name="X7C6F19B57CB2E882"></a></p>

<h5>5.1-2 DigraphNrVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphNrVertices</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An non-negative integer.</p>

<p>Returns the number of vertices of the digraph <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "c", "a"]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrVertices(gr);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([1, 2, 3, 4, 5, 7],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 [1, 2, 2, 4, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 [2, 7, 5, 3, 7]);</span>
&lt;immutable digraph with 6 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrVertices(gr);</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrVertices(RandomDigraph(100));</span>
100
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrVertices(D);</span>
3
</pre></div>

<p><a id="X7D1C6A4D7ECEC317" name="X7D1C6A4D7ECEC317"></a></p>

<h5>5.1-3 DigraphEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphEdges</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of lists of two positive integers.</p>

<p>Returns a list of edges of the digraph <var class="Arg">digraph</var>, where each edge is a pair of elements of <code class="func">DigraphVertices</code> (<a href="chap5_mj.html#X7C45F7D878D896AC"><span class="RefLink">5.1-1</span></a>) of the form <code class="code">[source,range]</code>.</p>

<p>The entries of <code class="code">DigraphEdges(</code><var class="Arg">digraph</var><code class="code">)</code> are in one-to-one correspondence with the edges of <var class="Arg">digraph</var>. Hence <code class="code">DigraphEdges(</code><var class="Arg">digraph</var><code class="code">)</code> is duplicate-free if and only if <var class="Arg">digraph</var> contains no multiple edges.</p>

<p>The entries of <code class="code">DigraphEdges</code> are guaranteed to be sorted by their first component (i.e. by the source of each edge), but they are not necessarily then sorted by the second component.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := DigraphFromDiSparse6String(".DaXbOe?EAM@G~");</span>
&lt;immutable multidigraph with 5 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edges := ShallowCopy(DigraphEdges(gr));; Sort(edges);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edges;</span>
[ [ 1, 1 ], [ 1, 3 ], [ 1, 3 ], [ 1, 4 ], [ 1, 5 ], [ 2, 1 ], 
  [ 2, 2 ], [ 2, 3 ], [ 2, 5 ], [ 3, 2 ], [ 3, 4 ], [ 3, 5 ], 
  [ 4, 2 ], [ 4, 4 ], [ 4, 5 ], [ 5, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdges(D);</span>
[ [ 1, 2 ], [ 2, 3 ], [ 3, 1 ] ]
</pre></div>

<p><a id="X85E1CFDD7E164AD0" name="X85E1CFDD7E164AD0"></a></p>

<h5>5.1-4 DigraphNrEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphNrEdges</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer.</p>

<p>Returns the number of edges of the digraph <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 3, 4, 5], [1, 2, 3, 5], [2, 4, 5], [2, 4, 5], [1]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrEdges(gr);</span>
15
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "a", "a"]);</span>
&lt;immutable multidigraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrEdges(gr);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrEdges(D);</span>
3
</pre></div>

<p><a id="X7BDABAF07917462B" name="X7BDABAF07917462B"></a></p>

<h5>5.1-5 DigraphNrLoops</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphNrLoops</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer.</p>

<p>This function returns the number of loops of the digraph <var class="Arg">digraph</var>. See <code class="func">DigraphHasLoops</code> (<a href="chap6_mj.html#X7D92935C7D535187"><span class="RefLink">6.2-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 3], [1, 4], [3, 3, 5], [], [2, 5]]);</span>
&lt;immutable multidigraph with 5 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrLoops(D);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := EmptyDigraph(5);</span>
&lt;immutable empty digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrLoops(D);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(5);</span>
&lt;immutable complete digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrLoops(D);</span>
0
</pre></div>

<p><a id="X85D5E08280914EE4" name="X85D5E08280914EE4"></a></p>

<h5>5.1-6 DigraphSinks</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphSinks</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>This function returns a list of the sinks of the digraph <var class="Arg">digraph</var>. A sink of a digraph is a vertex with out-degree zero. See <code class="func">OutDegreeOfVertex</code> (<a href="chap5_mj.html#X7A09EB648070276D"><span class="RefLink">5.2-10</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[3, 5, 2, 2], [3], [], [5, 2, 5, 3], []]);</span>
&lt;immutable multidigraph with 5 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSinks(gr);</span>
[ 3, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSinks(D);</span>
[  ]
</pre></div>

<p><a id="X7F5C6268839BE98C" name="X7F5C6268839BE98C"></a></p>

<h5>5.1-7 DigraphSources</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphSources</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>This function returns an immutable list of the sources of the digraph <var class="Arg">digraph</var>. A source of a digraph is a vertex with in-degree zero. See <code class="func">InDegreeOfVertex</code> (<a href="chap5_mj.html#X7C9CD0527CB9E6EF"><span class="RefLink">5.2-12</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[3, 5, 2, 2], [3], [], [5, 2, 5, 3], []]);</span>
&lt;immutable multidigraph with 5 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSources(gr);</span>
[ 1, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSources(D);</span>
[  ]
</pre></div>

<p><a id="X785C30378064CF47" name="X785C30378064CF47"></a></p>

<h5>5.1-8 DigraphTopologicalSort</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphTopologicalSort</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of positive integers, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a digraph whose only directed cycles are loops, then <code class="code">DigraphTopologicalSort</code> returns the vertices of <var class="Arg">digraph</var> ordered so that every edge's source appears no earlier in the list than its range. If the digraph <var class="Arg">digraph</var> contains directed cycles of length greater than <span class="SimpleMath">\(1\)</span>, then this operation returns <code class="keyw">fail</code>.</p>

<p>See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of a directed cycle, and the definition of a loop.</p>

<p>The method used for this attribute has complexity <span class="SimpleMath">\(O(m+n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges (counting multiple edges as one) and <span class="SimpleMath">\(n\)</span> is the number of vertices in the digraph.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 3], [], [4, 6], [5], [], [7, 8, 9], [], [], []]);</span>
&lt;immutable digraph with 9 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphTopologicalSort(D);</span>
[ 2, 5, 4, 7, 8, 9, 6, 3, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[2, 3], [3], [4], []]);</span>
&lt;mutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphTopologicalSort(D);</span>
[ 4, 3, 2, 1 ]
</pre></div>

<p><a id="X7CA91E4B7904F793" name="X7CA91E4B7904F793"></a></p>

<h5>5.1-9 DigraphVertexLabel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphVertexLabel</code>( <var class="Arg">digraph</var>, <var class="Arg">i</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetDigraphVertexLabel</code>( <var class="Arg">digraph</var>, <var class="Arg">i</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">digraph</var> is a digraph, then the first operation returns the label of the vertex <var class="Arg">i</var>. The second operation can be used to set the label of the vertex <var class="Arg">i</var> in <var class="Arg">digraph</var> to the arbitrary <strong class="pkg">GAP</strong> object <var class="Arg">obj</var>.</p>

<p>The label of a vertex can be changed an arbitrary number of times. If no label has been set for the vertex <var class="Arg">i</var>, then the default value is <var class="Arg">i</var>.</p>

<p>If <var class="Arg">digraph</var> is a digraph created from a record with a component <code class="code">DigraphVertices</code>, then the labels of the vertices are set to the value of this component.</p>

<p>Induced subdigraphs, and some other operations which create new digraphs from old ones, inherit their labels from their parents.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;DHUEe_");</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 3);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(["a", "b", "c"], [], []);</span>
&lt;immutable empty digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 2);</span>
"b"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphVertexLabel(D, 2, "d");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 2);</span>
"d"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := InducedSubdigraph(D, [1, 2]);</span>
&lt;immutable empty digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 2);</span>
"d"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, ["e", "f", "g"], [], []);</span>
&lt;mutable empty digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 1);</span>
"e"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphVertexLabel(D, 1, "h");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 1);</span>
"h"
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedSubdigraph(D, [1, 2]);</span>
&lt;mutable empty digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabel(D, 1);</span>
"h"
</pre></div>

<p><a id="X7E51F2FE87140B32" name="X7E51F2FE87140B32"></a></p>

<h5>5.1-10 DigraphVertexLabels</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphVertexLabels</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetDigraphVertexLabels</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">digraph</var> is a digraph, then <code class="code">DigraphVertexLabels</code> returns a copy of the labels of the vertices in <var class="Arg">digraph</var>. <code class="code">SetDigraphVertexLabels</code> can be used to set the labels of the vertices in <var class="Arg">digraph</var> to the list of arbitrary <strong class="pkg">GAP</strong> objects <var class="Arg">list</var>, which must be of the same length as the number of vertices of <var class="Arg">digraph</var>.</p>

<p>If the list <var class="Arg">list</var> is immutable, then the vertex labels are set to a mutable copy of <var class="Arg">list</var>. Otherwise, the labels are set to exactly <var class="Arg">list</var>.</p>

<p>The label of a vertex can be changed an arbitrary number of times. If no label has been set for the vertex <var class="Arg">i</var>, then the default value is <var class="Arg">i</var>.</p>

<p>If <var class="Arg">digraph</var> is a digraph created from a record with a component <code class="code">DigraphVertices</code>, then the labels of the vertices are set to the value of this component. As in the above, if the component is immutable then the digraph's vertex labels are set to a mutable copy of <code class="code">DigraphVertices</code>. Otherwise, they are set to exactly <code class="code">DigraphVertices</code>.</p>

<p>Induced subdigraphs, and other operations which create new digraphs from old ones, inherit their labels from their parents.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;DHUEe_");</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ 1 .. 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(["a", "b", "c"], [], []);</span>
&lt;immutable empty digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ "a", "b", "c" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphVertexLabel(D, 2, "d");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ "a", "d", "c" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := InducedSubdigraph(D, [1, 3]);</span>
&lt;immutable empty digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ "a", "c" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, ["e", "f", "g"], [], []);</span>
&lt;mutable empty digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphVertexLabels(D, ["h", "i", "j"]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ "h", "i", "j" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedSubdigraph(D, [1, 3]);</span>
&lt;mutable empty digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphVertexLabels(D);</span>
[ "h", "j" ]
</pre></div>

<p><a id="X79FAEACC7F438C2F" name="X79FAEACC7F438C2F"></a></p>

<h5>5.1-11 DigraphEdgeLabel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphEdgeLabel</code>( <var class="Arg">digraph</var>, <var class="Arg">i</var>, <var class="Arg">j</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetDigraphEdgeLabel</code>( <var class="Arg">digraph</var>, <var class="Arg">i</var>, <var class="Arg">j</var>, <var class="Arg">obj</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">digraph</var> is a digraph without multiple edges, then the first operation returns the label of the edge from vertex <var class="Arg">i</var> to vertex <var class="Arg">j</var>. The second operation can be used to set the label of the edge between vertex <var class="Arg">i</var> and vertex <var class="Arg">j</var> to the arbitrary <strong class="pkg">GAP</strong> object <var class="Arg">obj</var>.</p>

<p>The label of an edge can be changed an arbitrary number of times. If no label has been set for the edge, then the default value is <var class="Arg">1</var>.</p>

<p>Induced subdigraphs, and some other operations which create new digraphs from old ones, inherit their edge labels from their parents. See also <code class="func">DigraphEdgeLabels</code> (<a href="chap5_mj.html#X7C24851087D4A8FB"><span class="RefLink">5.1-12</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;DHUEe_");</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 3, 1);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphEdgeLabel(D, 2, 5, [42]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 2, 5);</span>
[ 42 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := InducedSubdigraph(D, [2, 5]);</span>
&lt;immutable digraph with 2 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 1, 2);</span>
[ 42 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(IsMutableDigraph, 5);</span>
&lt;mutable digraph with 5 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 2, 3);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphEdgeLabel(D, 4, 5, [1729]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 4, 5);</span>
[ 1729 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedSubdigraph(D, [4, 5]);</span>
&lt;mutable digraph with 2 vertices, 1 edge&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabel(D, 1, 2);</span>
[ 1729 ]
</pre></div>

<p><a id="X7C24851087D4A8FB" name="X7C24851087D4A8FB"></a></p>

<h5>5.1-12 DigraphEdgeLabels</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphEdgeLabels</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetDigraphEdgeLabels</code>( <var class="Arg">digraph</var>, <var class="Arg">labels</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SetDigraphEdgeLabels</code>( <var class="Arg">digraph</var>, <var class="Arg">func</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>If <var class="Arg">digraph</var> is a digraph without multiple edges, then <code class="code">DigraphEdgeLabels</code> returns a copy of the labels of the edges in <var class="Arg">digraph</var> as a list of lists <code class="code">labels</code> such that <code class="code">labels[i][j]</code> is the label on the edge from vertex <code class="code">i</code> to vertex <code class="code">OutNeighbours(digraph)[i][j]</code>. <code class="code">SetDigraphEdgeLabels</code> can be used to set the labels of the edges in <var class="Arg">digraph</var> without multiple edges to the list <var class="Arg">labels</var> of lists of arbitrary <strong class="pkg">GAP</strong> objects such that <code class="code">list[i][j]</code> is the label on the edge from vertex <code class="code">i</code> to the vertex <code class="code">OutNeighbours(digraph&gt;[i][j]</code>. Alternatively <code class="code">SetDigraphEdgeLabels</code> can be called with binary function <var class="Arg">func</var> that as its second argument that when passed two vertices <code class="code">i</code> and <code class="code">j</code> returns the label for the edge between vertex <code class="code">i</code> and vertex <code class="code">j</code>.</p>

<p>The label of an edge can be changed an arbitrary number of times. If no label has been set for an edge, then the default value is <code class="code">1</code>.</p>

<p>Induced subdigraphs, and some other operations which create new digraphs from old ones, inherit their labels from their parents.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;DHUEe_");</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1 ], [ 1, 1, 1 ], [ 1 ], [ 1, 1, 1 ], [ 1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphEdgeLabel(D, 2, 1, "d");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1 ], [ "d", 1, 1 ], [ 1 ], [ 1, 1, 1 ], [ 1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := InducedSubdigraph(D, [1, 2, 3]);</span>
&lt;immutable digraph with 3 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1 ], [ "d", 1 ], [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(D);</span>
[ [ 3 ], [ 1, 3 ], [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteBipartiteDigraph(IsMutableDigraph, 2, 3);</span>
&lt;mutable digraph with 5 vertices, 12 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1, 1, 1 ], [ 1, 1, 1 ], [ 1, 1 ], [ 1, 1 ], [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetDigraphEdgeLabel(D, 2, 4, "a");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1, 1, 1 ], [ 1, "a", 1 ], [ 1, 1 ], [ 1, 1 ], [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InducedSubdigraph(D, [1, 2, 3, 4]);</span>
&lt;mutable digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdgeLabels(D);</span>
[ [ 1, 1 ], [ 1, "a" ], [ 1, 1 ], [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbors(D);</span>
[ [ 3, 4 ], [ 3, 4 ], [ 1, 2 ], [ 1, 2 ] ]
</pre></div>

<p><a id="X7EFAF01B7A155157" name="X7EFAF01B7A155157"></a></p>

<h5>5.1-13 DigraphInEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphInEdges</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of edges.</p>

<p><code class="code">DigraphInEdges</code> returns the list of all edges of <var class="Arg">digraph</var> which have <var class="Arg">vertex</var> as their range.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 2], [3, 3], [4, 4], [1, 1]]);</span>
&lt;immutable multidigraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphInEdges(D, 2);</span>
[ [ 1, 2 ], [ 1, 2 ] ]
</pre></div>

<p><a id="X7BECFE6687ECD028" name="X7BECFE6687ECD028"></a></p>

<h5>5.1-14 DigraphOutEdges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphOutEdges</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of edges.</p>

<p><code class="code">DigraphOutEdges</code> returns the list of all edges of <var class="Arg">digraph</var> which have <var class="Arg">vertex</var> as their source.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 2], [3, 3], [4, 4], [1, 1]]);</span>
&lt;immutable multidigraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOutEdges(D, 2);</span>
[ [ 2, 3 ], [ 2, 3 ] ]
</pre></div>

<p><a id="X7BB8ED88835F07B4" name="X7BB8ED88835F07B4"></a></p>

<h5>5.1-15 IsDigraphEdge</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphEdge</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphEdge</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>In the first form, this function returns <code class="keyw">true</code> if and only if the list <var class="Arg">list</var> specifies an edge in the digraph <var class="Arg">digraph</var>. Specifically, this operation returns <code class="keyw">true</code> if <var class="Arg">list</var> is a pair of positive integers where <var class="Arg">list</var><code class="code">[1]</code> is the source and <var class="Arg">list</var><code class="code">[2]</code> is the range of an edge in <var class="Arg">digraph</var>, and <code class="keyw">false</code> otherwise.</p>

<p>The second form simply returns <code class="keyw">true</code> if <code class="code">[<var class="Arg">u</var>, <var class="Arg">v</var>]</code> is an edge in <var class="Arg">digraph</var>, and <code class="keyw">false</code> otherwise.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 2], [6], [], [3], [], [1]]);</span>
&lt;immutable multidigraph with 6 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEdge(D, [1, 1]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEdge(D, [1, 2]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphEdge(D, [1, 8]);</span>
false
</pre></div>

<p><a id="X848FED0B7B4ACD1F" name="X848FED0B7B4ACD1F"></a></p>

<h5>5.1-16 IsMatching</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMatching</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMaximalMatching</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMaximumMatching</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPerfectMatching</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>If <var class="Arg">digraph</var> is a digraph and <var class="Arg">list</var> is a list of pairs of vertices of <var class="Arg">digraph</var>, then <code class="code">IsMatching</code> returns <code class="keyw">true</code> if <var class="Arg">list</var> is a matching of <var class="Arg">digraph</var>. The operation <code class="code">IsMaximalMatching</code> returns <code class="keyw">true</code> if <var class="Arg">list</var> is a maximal matching, <code class="code">IsMaximumMatching</code> returns <code class="keyw">true</code> if <var class="Arg">list</var> is a maximum matching and <code class="code">IsPerfectMatching</code> returns <code class="keyw">true</code> if <var class="Arg">list</var> is a perfect, matching of <var class="Arg">digraph</var>, respectively. Otherwise, each of these operations return <code class="keyw">false</code>.</p>

<p>A <em>matching</em> <code class="code">M</code> of a digraph <var class="Arg">digraph</var> is a subset of the edges of <var class="Arg">digraph</var>, i.e. <code class="code">DigraphEdges(<var class="Arg">digraph</var>)</code>, such that no pair of distinct edges in <code class="code">M</code> are incident to the same vertex of <var class="Arg">digraph</var>. Note that this definition allows a matching to contain loops. See <code class="func">DigraphHasLoops</code> (<a href="chap6_mj.html#X7D92935C7D535187"><span class="RefLink">6.2-1</span></a>). The matching <code class="code">M</code> is <em>maximal</em> if it is contained in no larger matching of the digraph, is <em>maximum</em> if it has the greatest cardinality among all matchings and is <em>perfect</em> if every vertex of the digraph is incident to an edge in the matching. Every maximum or perfect matching is maximal. Note, however, that not every perfect matching of digraphs with loops is maximum.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 2], [1, 2], [2, 3, 4], [3, 5], [1]]);</span>
&lt;immutable digraph with 5 vertices, 10 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMatching(D, [[2, 1], [3, 2]]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edges := [[3, 2]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMatching(D, edges);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximalMatching(D, edges);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edges := [[2, 1], [3, 4]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximalMatching(D, edges);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPerfectMatching(D, edges);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edges := [[1, 2], [3, 3], [4, 5]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPerfectMatching(D, edges);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximumMatching(D, edges);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">edges := [[1, 1], [2, 2], [3, 3], [4, 5]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximumMatching(D, edges);</span>
true
</pre></div>

<p><a id="X7B7A67277B1C9A02" name="X7B7A67277B1C9A02"></a></p>

<h5>5.1-17 DigraphMaximalMatching</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphMaximalMatching</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of pairs of vertices.</p>

<p>This function returns a maximal matching of the digraph <var class="Arg">digraph</var>.</p>

<p>For the definition of a maximal matching, see <code class="func">IsMaximalMatching</code> (<a href="chap5_mj.html#X848FED0B7B4ACD1F"><span class="RefLink">5.1-16</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDiSparse6String(".IeAoXCJU@|SHAe?d");</span>
&lt;immutable digraph with 10 vertices, 13 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := DigraphMaximalMatching(D);; IsMaximalMatching(D, M);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := RandomDigraph(100);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximalMatching(D, DigraphMaximalMatching(D));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 9, 2);</span>
&lt;mutable digraph with 18 vertices, 54 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximalMatching(D, DigraphMaximalMatching(D));</span>
true
</pre></div>

<p><a id="X78E9847A858788D1" name="X78E9847A858788D1"></a></p>

<h5>5.1-18 DigraphMaximumMatching</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphMaximumMatching</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of pairs of vertices.</p>

<p>This function returns a maximum matching of the digraph <var class="Arg">digraph</var>.</p>

<p>For the definition of a maximum matching, see <code class="func">IsMaximumMatching</code> (<a href="chap5_mj.html#X848FED0B7B4ACD1F"><span class="RefLink">5.1-16</span></a>). If <var class="Arg">digraph</var> is bipartite (see <code class="func">IsBipartiteDigraph</code> (<a href="chap6_mj.html#X860CFB0C8665F356"><span class="RefLink">6.2-3</span></a>)), then the algorithm used has complexity <code class="code">O(m*sqrt(n))</code>. Otherwise for general graphs the complexity is <code class="code">O(m*n*log(n))</code>. Here <code class="code">n</code> is the number of vertices and <code class="code">m</code> is the number of edges.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;I@EA_A?AdDp[_c??OO");</span>
&lt;immutable digraph with 10 vertices, 23 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := DigraphMaximumMatching(D);; IsMaximalMatching(D, M);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(M);</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[5, 6, 7, 8], [6, 7, 8], [7, 8], [8], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 [], [], [], []]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := DigraphMaximumMatching(D);</span>
[ [ 1, 5 ], [ 2, 6 ], [ 3, 7 ], [ 4, 8 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 9, 2);</span>
&lt;mutable digraph with 18 vertices, 54 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := DigraphMaximumMatching(D);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMaximalMatching(D, M);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length(M);</span>
9
</pre></div>

<p><a id="X7D7CE8328187D0DF" name="X7D7CE8328187D0DF"></a></p>

<h4>5.2 <span class="Heading">Neighbours and degree</span></h4>

<p><a id="X7DC2CD70830BEE60" name="X7DC2CD70830BEE60"></a></p>

<h5>5.2-1 AdjacencyMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjacencyMatrix</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AdjacencyMatrixMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A square matrix of non-negative integers.</p>

<p>This function returns the adjacency matrix <code class="code">mat</code> of the digraph <var class="Arg">digraph</var>. The value of the matrix entry <code class="code">mat[i][j]</code> is the number of edges in <var class="Arg">digraph</var> with source <code class="code">i</code> and range <code class="code">j</code>. If <var class="Arg">digraph</var> has no vertices, then the empty list is returned.</p>

<p>The function <code class="code">AdjacencyMatrix</code> returns an immutable list of lists, whereas the function <code class="code">AdjacencyMatrixMutableCopy</code> returns a copy of <code class="code">AdjacencyMatrix</code> that is a mutable list of mutable lists.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 2], [1, 3, 6, 8, 9, 10], [4, 6, 8],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 9], [3, 3], [3, 5, 6, 10], [1, 2, 7],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 10, 5, 6, 10], [1, 3, 4, 5, 8, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 3, 4, 6, 7, 10]]);</span>
&lt;immutable multidigraph with 10 vertices, 44 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := AdjacencyMatrix(gr);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(mat);</span>
[ [  0,  3,  0,  0,  0,  0,  0,  0,  0,  0 ],
  [  1,  0,  1,  0,  0,  1,  0,  1,  1,  1 ],
  [  0,  0,  0,  1,  0,  1,  0,  1,  0,  0 ],
  [  1,  1,  1,  0,  0,  0,  0,  0,  1,  0 ],
  [  0,  0,  2,  0,  0,  0,  0,  0,  0,  0 ],
  [  0,  0,  1,  0,  1,  1,  0,  0,  0,  1 ],
  [  1,  1,  0,  0,  0,  0,  1,  0,  0,  0 ],
  [  1,  1,  1,  0,  1,  1,  0,  0,  0,  2 ],
  [  1,  0,  1,  1,  1,  0,  0,  1,  0,  1 ],
  [  0,  1,  1,  1,  0,  1,  1,  0,  0,  1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(AdjacencyMatrix(D));</span>
[ [  0,  1,  0 ],
  [  0,  0,  1 ],
  [  1,  0,  0 ] ]
</pre></div>

<p><a id="X87FA0A727CDB060B" name="X87FA0A727CDB060B"></a></p>

<h5>5.2-2 CharacteristicPolynomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CharacteristicPolynomial</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A polynomial with integer coefficients.</p>

<p>This function returns the characteristic polynomial of the digraph <var class="Arg">digraph</var>. That is it returns the characteristic polynomial of the adjacency matrix of the digraph <var class="Arg">digraph</var></p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 2], [1, 3, 6, 8, 9, 10], [4, 6, 8],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 9], [3, 3], [3, 5, 6, 10], [1, 2, 7],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 10, 5, 6, 10], [1, 3, 4, 5, 8, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 3, 4, 6, 7, 10]]);</span>
&lt;immutable multidigraph with 10 vertices, 44 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacteristicPolynomial(D);</span>
x_1^10-3*x_1^9-7*x_1^8-x_1^7+14*x_1^6+x_1^5-26*x_1^4+51*x_1^3-10*x_1^2\
+18*x_1-30
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(5);</span>
&lt;immutable complete digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacteristicPolynomial(D);</span>
x_1^5-10*x_1^3-20*x_1^2-15*x_1-4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CharacteristicPolynomial(D);</span>
x_1^3-1
</pre></div>

<p><a id="X8507DC4F794780C1" name="X8507DC4F794780C1"></a></p>

<h5>5.2-3 BooleanAdjacencyMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BooleanAdjacencyMatrix</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BooleanAdjacencyMatrixMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A square matrix of booleans.</p>

<p>If <var class="Arg">digraph</var> is a digraph with a positive number of vertices <code class="code">n</code>, then <code class="code">BooleanAdjacencyMatrix(</code><var class="Arg">digraph</var><code class="code">)</code> returns the boolean adjacency matrix <code class="code">mat</code> of <var class="Arg">digraph</var>. The value of the matrix entry <code class="code">mat[j][i]</code> is <code class="keyw">true</code> if and only if there exists an edge in <var class="Arg">digraph</var> with source <code class="code">j</code> and range <code class="code">i</code>. If <var class="Arg">digraph</var> has no vertices, then the empty list is returned.</p>

<p>Note that the boolean adjacency matrix loses information about multiple edges.</p>

<p>The attribute <code class="code">BooleanAdjacencyMatrix</code> returns an immutable list of immutable lists, whereas the function <code class="code">BooleanAdjacencyMatrixMutableCopy</code> returns a copy of the <code class="code">BooleanAdjacencyMatrix</code> that is a mutable list of mutable lists.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[3, 4], [2, 3], [1, 2, 4], [4]]);</span>
&lt;immutable digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(BooleanAdjacencyMatrix(gr));</span>
[ [  false,  false,   true,   true ],
  [  false,   true,   true,  false ],
  [   true,   true,  false,   true ],
  [  false,  false,  false,   true ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := CycleDigraph(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(BooleanAdjacencyMatrix(gr));</span>
[ [  false,   true,  false,  false ],
  [  false,  false,   true,  false ],
  [  false,  false,  false,   true ],
  [   true,  false,  false,  false ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BooleanAdjacencyMatrix(EmptyDigraph(0));</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(BooleanAdjacencyMatrix(D));</span>
[ [  false,   true,  false ],
  [  false,  false,   true ],
  [   true,  false,  false ] ]
</pre></div>

<p><a id="X7AFCE34A7A04D5C1" name="X7AFCE34A7A04D5C1"></a></p>

<h5>5.2-4 DigraphAdjacencyFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphAdjacencyFunction</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A function.</p>

<p>If <var class="Arg">digraph</var> is a digraph, then <code class="code">DigraphAdjacencyFunction</code> returns a function which takes two integer parameters <code class="code">x, y</code> and returns <code class="keyw">true</code> if there exists an edge from vertex <code class="code">x</code> to vertex <code class="code">y</code> in <var class="Arg">digraph</var> and <code class="keyw">false</code> if not.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph := Digraph([[1, 2], [3], []]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo := DigraphAdjacencyFunction(digraph);</span>
function( u, v ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(1, 1);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(1, 2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(1, 3);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(3, 1);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "a", "a"]);</span>
&lt;immutable multidigraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo := DigraphAdjacencyFunction(gr);</span>
function( u, v ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(1, 2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(3, 2);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(3, 1);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo := DigraphAdjacencyFunction(D);</span>
function( u, v ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(1, 2);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">foo(2, 1);</span>
false
</pre></div>

<p><a id="X7FDEBF3279759961" name="X7FDEBF3279759961"></a></p>

<h5>5.2-5 DigraphRange</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphRange</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphSource</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of positive integers.</p>

<p><code class="code">DigraphRange</code> and <code class="code">DigraphSource</code> return the range and source of the digraph <var class="Arg">digraph</var>. More precisely, position <code class="code">i</code> in <code class="code">DigraphSource(<var class="Arg">digraph</var>)</code> and <code class="code">DigraphRange(<var class="Arg">digraph</var>)</code> give, respectively, the source and range of the <code class="code">i</code>th edge of <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 1, 3, 5], [1, 3, 4], [2, 3], [2], [1, 2, 3, 4]]);</span>
&lt;immutable digraph with 5 vertices, 14 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSource(gr);</span>
[ 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 5, 5, 5, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphRange(gr);</span>
[ 2, 1, 3, 5, 1, 3, 4, 2, 3, 2, 1, 2, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphEdges(gr);</span>
[ [ 1, 2 ], [ 1, 1 ], [ 1, 3 ], [ 1, 5 ], [ 2, 1 ], [ 2, 3 ], 
  [ 2, 4 ], [ 3, 2 ], [ 3, 3 ], [ 4, 2 ], [ 5, 1 ], [ 5, 2 ], 
  [ 5, 3 ], [ 5, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphRange(D);</span>
[ 2, 3, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphSource(D);</span>
[ 1, 2, 3 ]
</pre></div>

<p><a id="X7E9880767AE68E00" name="X7E9880767AE68E00"></a></p>

<h5>5.2-6 OutNeighbours</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighbours</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighbors</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighboursMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighborsMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The adjacencies of a digraph.</p>

<p><code class="code">OutNeighbours</code> returns the list <code class="code">out</code> of out-neighbours of each vertex of the digraph <var class="Arg">digraph</var>. More specifically, a vertex <code class="code">j</code> appears in <code class="code">out[i]</code> each time there exists the edge <code class="code">[i, j]</code> in <var class="Arg">digraph</var>.</p>

<p>The function <code class="code">OutNeighbours</code> returns an immutable list of lists, whereas the function <code class="code">OutNeighboursMutableCopy</code> returns a copy of <code class="code">OutNeighbours</code> which is a mutable list of mutable lists.</p>

<p>Note that the entries of <code class="code">out</code> are not guaranteed to be sorted in any particular order.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "a", "c"]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(gr);</span>
[ [ 2 ], [ 1, 3 ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[1, 2, 3], [2, 1], [3]]);</span>
&lt;immutable digraph with 3 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(gr);</span>
[ [ 1, 2, 3 ], [ 2, 1 ], [ 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := DigraphByAdjacencyMatrix([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 2, 1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 1, 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [0, 0, 1]]);</span>
&lt;immutable multidigraph with 3 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(gr);</span>
[ [ 1, 2, 2, 3 ], [ 1, 2 ], [ 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighboursMutableCopy(gr);</span>
[ [ 1, 2, 2, 3 ], [ 1, 2 ], [ 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighbours(D);</span>
[ [ 2 ], [ 3 ], [ 1 ] ]
</pre></div>

<p><a id="X85C7AA5A81DA6E11" name="X85C7AA5A81DA6E11"></a></p>

<h5>5.2-7 InNeighbours</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighbours</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighbors</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighboursMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighborsMutableCopy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of lists of vertices.</p>

<p><code class="code">InNeighbours</code> returns the list <code class="code">inn</code> of in-neighbours of each vertex of the digraph <var class="Arg">digraph</var>. More specifically, a vertex <code class="code">j</code> appears in <code class="code">inn[i]</code> each time there exists an edge <code class="code">[j,i]</code> in <var class="Arg">digraph</var>.</p>

<p>The function <code class="code">InNeighbours</code> returns an immutable list of lists, whereas the function <code class="code">InNeighboursMutableCopy</code> returns a copy of <code class="code">InNeighbours</code> which is a mutable list of mutable lists.</p>

<p>Note that the entries of <code class="code">inn</code> are not necessarily sorted into ascending order, particularly if <var class="Arg">digraph</var> was constructed via <code class="func">DigraphByInNeighbours</code> (<a href="chap3_mj.html#X81BC49B57EAADEFB"><span class="RefLink">3.1-11</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph(["a", "b", "c"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["a", "b", "b"],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 ["b", "a", "c"]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighbours(gr);</span>
[ [ 2 ], [ 1 ], [ 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[1, 2, 3], [2, 1], [3]]);</span>
&lt;immutable digraph with 3 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighbours(gr);</span>
[ [ 1, 2 ], [ 1, 2 ], [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := DigraphByAdjacencyMatrix([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 2, 1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [1, 1, 0],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [0, 0, 1]]);</span>
&lt;immutable multidigraph with 3 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighbours(gr);</span>
[ [ 1, 2 ], [ 1, 1, 2 ], [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighboursMutableCopy(gr);</span>
[ [ 1, 2 ], [ 1, 1, 2 ], [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighbours(D);</span>
[ [ 3 ], [ 1 ], [ 2 ] ]
</pre></div>

<p><a id="X7F5ACE807D1BC2E2" name="X7F5ACE807D1BC2E2"></a></p>

<h5>5.2-8 OutDegrees</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutDegrees</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutDegreeSequence</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutDegreeSet</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of non-negative integers.</p>

<p>Given a digraph <var class="Arg">digraph</var> with <span class="SimpleMath">\(n\)</span> vertices, the function <code class="code">OutDegrees</code> returns an immutable list <code class="code">out</code> of length <span class="SimpleMath">\(n\)</span>, such that for a vertex <code class="code">i</code> in <var class="Arg">digraph</var>, the value of <code class="code">out[i]</code> is the out-degree of vertex <code class="code">i</code>. See <code class="func">OutDegreeOfVertex</code> (<a href="chap5_mj.html#X7A09EB648070276D"><span class="RefLink">5.2-10</span></a>).</p>

<p>The function <code class="code">OutDegreeSequence</code> returns the same list, after it has been sorted into non-increasing order.</p>

<p>The function <code class="code">OutDegreeSet</code> returns the same list, sorted into increasing order with duplicate entries removed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 3, 2, 2], [], [2, 1], []]);</span>
&lt;immutable multidigraph with 4 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegrees(D);</span>
[ 4, 0, 2, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeSequence(D);</span>
[ 4, 2, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeSet(D);</span>
[ 0, 2, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegrees(D);</span>
[ 1, 1, 1 ]
</pre></div>

<p><a id="X7ADDFBFD7A365775" name="X7ADDFBFD7A365775"></a></p>

<h5>5.2-9 InDegrees</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InDegrees</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InDegreeSequence</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InDegreeSet</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of non-negative integers.</p>

<p>Given a digraph <var class="Arg">digraph</var> with <span class="SimpleMath">\(n\)</span> vertices, the function <code class="code">InDegrees</code> returns an immutable list <code class="code">inn</code> of length <span class="SimpleMath">\(n\)</span>, such that for a vertex <code class="code">i</code> in <var class="Arg">digraph</var>, the value of <code class="code">inn[i]</code> is the in-degree of vertex <code class="code">i</code>. See <code class="func">InDegreeOfVertex</code> (<a href="chap5_mj.html#X7C9CD0527CB9E6EF"><span class="RefLink">5.2-12</span></a>).</p>

<p>The function <code class="code">InDegreeSequence</code> returns the same list, after it has been sorted into non-increasing order.</p>

<p>The function <code class="code">InDegreeSet</code> returns the same list, sorted into increasing order with duplicate entries removed.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 3, 2, 2, 4], [], [2, 1, 4], []]);</span>
&lt;immutable multidigraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegrees(D);</span>
[ 2, 3, 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeSequence(D);</span>
[ 3, 2, 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeSet(D);</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegrees(D);</span>
[ 1, 1, 1 ]
</pre></div>

<p><a id="X7A09EB648070276D" name="X7A09EB648070276D"></a></p>

<h5>5.2-10 OutDegreeOfVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutDegreeOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: The non-negative integer.</p>

<p>This operation returns the out-degree of the vertex <var class="Arg">vertex</var> in the digraph <var class="Arg">digraph</var>. The out-degree of <var class="Arg">vertex</var> is the number of edges in <var class="Arg">digraph</var> whose source is <var class="Arg">vertex</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 1], [1, 4], [2, 2, 4, 2], [1, 1, 2, 2, 1, 2, 2]]);</span>
&lt;immutable multidigraph with 4 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeOfVertex(D, 1);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeOfVertex(D, 2);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeOfVertex(D, 3);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutDegreeOfVertex(D, 4);</span>
7
</pre></div>

<p><a id="X83315B0186850806" name="X83315B0186850806"></a></p>

<h5>5.2-11 OutNeighboursOfVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighboursOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OutNeighborsOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>This operation returns the list <code class="code">out</code> of vertices of the digraph <var class="Arg">digraph</var>. A vertex <code class="code">i</code> appears in the list <code class="code">out</code> each time there exists an edge with source <var class="Arg">vertex</var> and range <code class="code">i</code> in <var class="Arg">digraph</var>; in particular, this means that <code class="code">out</code> may contain duplicates.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 3], [1, 3, 4], [2, 2, 3], [1, 1, 2, 2, 1, 2, 2]]);</span>
&lt;immutable multidigraph with 4 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighboursOfVertex(D, 1);</span>
[ 2, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OutNeighboursOfVertex(D, 3);</span>
[ 2, 2, 3 ]
</pre></div>

<p><a id="X7C9CD0527CB9E6EF" name="X7C9CD0527CB9E6EF"></a></p>

<h5>5.2-12 InDegreeOfVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InDegreeOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A non-negative integer.</p>

<p>This operation returns the in-degree of the vertex <var class="Arg">vertex</var> in the digraph <var class="Arg">digraph</var>. The in-degree of <var class="Arg">vertex</var> is the number of edges in <var class="Arg">digraph</var> whose range is <var class="Arg">vertex</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 1], [1, 4], [2, 2, 4, 2], [1, 1, 2, 2, 1, 2, 2]]);</span>
&lt;immutable multidigraph with 4 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeOfVertex(D, 1);</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeOfVertex(D, 2);</span>
9
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeOfVertex(D, 3);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InDegreeOfVertex(D, 4);</span>
2
</pre></div>

<p><a id="X7C0DA18B8291F302" name="X7C0DA18B8291F302"></a></p>

<h5>5.2-13 InNeighboursOfVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighboursOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InNeighborsOfVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of positive vertices.</p>

<p>This operation returns the list <code class="code">inn</code> of vertices of the digraph <var class="Arg">digraph</var>. A vertex <code class="code">i</code> appears in the list <code class="code">inn</code> each time there exists an edge with source <code class="code">i</code> and range <var class="Arg">vertex</var> in <var class="Arg">digraph</var>; in particular, this means that <code class="code">inn</code> may contain duplicates.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 2, 3], [1, 3, 4], [2, 2, 3], [1, 1, 2, 2, 1, 2, 2]]);</span>
&lt;immutable multidigraph with 4 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighboursOfVertex(D, 1);</span>
[ 2, 4, 4, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InNeighboursOfVertex(D, 2);</span>
[ 1, 1, 3, 3, 4, 4, 4, 4 ]
</pre></div>

<p><a id="X83271F607BD809CF" name="X83271F607BD809CF"></a></p>

<h5>5.2-14 DigraphLoops</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphLoops</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>If <var class="Arg">digraph</var> is a digraph, then <code class="code">DigraphLoops</code> returns the list consisting of the <code class="func">DigraphVertices</code> (<a href="chap5_mj.html#X7C45F7D878D896AC"><span class="RefLink">5.1-1</span></a>) of <var class="Arg">digraph</var> at which there is a loop. See <code class="func">DigraphHasLoops</code> (<a href="chap6_mj.html#X7D92935C7D535187"><span class="RefLink">6.2-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], []]);</span>
&lt;immutable digraph with 3 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphHasLoops(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLoops(D);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5], [1], [2, 4, 3], [4], [2, 1]]);</span>
&lt;immutable digraph with 5 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLoops(D);</span>
[ 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[1], [1]]);</span>
&lt;mutable digraph with 2 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLoops(D);</span>
[ 1 ]
</pre></div>

<p><a id="X7BEAE1C78267F54D" name="X7BEAE1C78267F54D"></a></p>

<h5>5.2-15 DegreeMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DegreeMatrix</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A square matrix of non-negative integers.</p>

<p>Returns the out-degree matrix <code class="code">mat</code> of the digraph <var class="Arg">digraph</var>. The value of the <code class="code">i</code>th diagonal matrix entry is the out-degree of the vertex <code class="code">i</code> in <var class="Arg">digraph</var>. All off-diagonal entries are <code class="code">0</code>. If <var class="Arg">digraph</var> has no vertices, then the empty list is returned.</p>

<p>See <code class="func">OutDegrees</code> (<a href="chap5_mj.html#X7F5ACE807D1BC2E2"><span class="RefLink">5.2-8</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 2, 3], [4], [1, 3, 4], []]);</span>
&lt;immutable digraph with 4 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(DegreeMatrix(D));</span>
[ [  3,  0,  0,  0 ],
  [  0,  1,  0,  0 ],
  [  0,  0,  3,  0 ],
  [  0,  0,  0,  0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(DegreeMatrix(D));</span>
[ [  1,  0,  0,  0,  0 ],
  [  0,  1,  0,  0,  0 ],
  [  0,  0,  1,  0,  0 ],
  [  0,  0,  0,  1,  0 ],
  [  0,  0,  0,  0,  1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DegreeMatrix(EmptyDigraph(0));</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(DegreeMatrix(D));</span>
[ [  1,  0,  0 ],
  [  0,  1,  0 ],
  [  0,  0,  1 ] ]
</pre></div>

<p><a id="X865390B08331936B" name="X865390B08331936B"></a></p>

<h5>5.2-16 LaplacianMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LaplacianMatrix</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A square matrix of integers.</p>

<p>Returns the out-degree Laplacian matrix <code class="code">mat</code> of the digraph <var class="Arg">digraph</var>. The out-degree Laplacian matrix is defined as <code class="code">DegreeMatrix(digraph) - AdjacencyMatrix(digraph)</code>. If <var class="Arg">digraph</var> has no vertices, then the empty list is returned.</p>

<p>See <code class="func">DegreeMatrix</code> (<a href="chap5_mj.html#X7BEAE1C78267F54D"><span class="RefLink">5.2-15</span></a>) and <code class="func">AdjacencyMatrix</code> (<a href="chap5_mj.html#X7DC2CD70830BEE60"><span class="RefLink">5.2-1</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[1, 2, 3], [4], [1, 3, 4], []]);</span>
&lt;immutable digraph with 4 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(LaplacianMatrix(gr));</span>
[ [   2,  -1,  -1,   0 ],
  [   0,   1,   0,  -1 ],
  [  -1,   0,   2,  -1 ],
  [   0,   0,   0,   0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LaplacianMatrix(EmptyDigraph(0));</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(LaplacianMatrix(D));</span>
[ [   1,  -1,   0 ],
  [   0,   1,  -1 ],
  [  -1,   0,   1 ] ]
</pre></div>

<p><a id="X86424F167BD4F629" name="X86424F167BD4F629"></a></p>

<h4>5.3 <span class="Heading">Orders</span></h4>

<p><a id="X7DDB33B686B3A2C6" name="X7DDB33B686B3A2C6"></a></p>

<h5>5.3-1 PartialOrderDigraphMeetOfVertices</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PartialOrderDigraphMeetOfVertices</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PartialOrderDigraphJoinOfVertices</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A positive integer or <code class="keyw">fail</code></p>

<p>If the first argument is a partial order digraph <code class="func">IsPartialOrderDigraph</code> (<a href="chap6_mj.html#X82BAE6D37D49A145"><span class="RefLink">6.4-2</span></a>) then these operations return the meet, or the join, of the two input vertices. If the meet (or join) is does not exist then <code class="keyw">fail</code> is returned. The meet (or join) is guaranteed to exist when the first argument satisfies <code class="func">IsMeetSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.4-3</span></a>) (or <code class="func">IsJoinSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.4-3</span></a>)) - see the documentation for these properties for the definition of the meet (or the join).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [1, 2], [1, 3], [1, 2, 3, 4]]);</span>
&lt;immutable digraph with 4 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphMeetOfVertices(D, 2, 3);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphJoinOfVertices(D, 2, 3);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphMeetOfVertices(D, 1, 2);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphJoinOfVertices(D, 3, 4);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [2], [1, 2, 3], [1, 2, 4]]);</span>
&lt;immutable digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphMeetOfVertices(D, 3, 4);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphJoinOfVertices(D, 3, 4);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphMeetOfVertices(D, 1, 2);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PartialOrderDigraphJoinOfVertices(D, 1, 2);</span>
fail
</pre></div>

<p><a id="X824B9896798530F6" name="X824B9896798530F6"></a></p>

<h5>5.3-2 NonUpperSemimodularPair</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NonUpperSemimodularPair</code>( <var class="Arg">D</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NonLowerSemimodularPair</code>( <var class="Arg">D</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A pair of vertices or <code class="keyw">fail</code>.</p>

<p><code class="code">NonUpperSemimodularPair</code> returns a pair of vertices in the digraph <var class="Arg">D</var> that witnesses the fact that <var class="Arg">D</var> does not represent an upper semimodular lattice, if such a pair exists.</p>

<p>If the digraph <var class="Arg">D</var> does not satisfy <code class="func">IsLatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.4-3</span></a>), then an error is given. Otherwise if the digraph <var class="Arg">D</var> does satisfy <code class="func">IsLatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.4-3</span></a>), then either a non-upper semimodular pair of vertices is returned, or <code class="keyw">fail</code> is returned if no such pair exists (meaning that <var class="Arg">D</var> is an upper semimodular lattice.</p>

<p><code class="code">NonLowerSemimodularPair</code> behaves in the analogous way to <code class="code">NonUpperSemimodularPair</code> with respect to lower semimodularity.</p>

<p>See <code class="func">IsUpperSemimodularDigraph</code> (<a href="chap6_mj.html#X7DEDCD177E5AE824"><span class="RefLink">6.4-5</span></a>) and <code class="func">IsLowerSemimodularDigraph</code> (<a href="chap6_mj.html#X7DEDCD177E5AE824"><span class="RefLink">6.4-5</span></a>) for the definition of upper semimodularity of a lattice.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">"&amp;M~~sc`lYUZO__KIBboC_@h?U_?_GL?A_?c");</span>
&lt;immutable digraph with 14 vertices, 66 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NonLowerSemimodularPair(D);</span>
[ 10, 9 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NonUpperSemimodularPair(D);</span>
fail
</pre></div>

<p><a id="X8537F4088400DC48" name="X8537F4088400DC48"></a></p>

<h4>5.4 <span class="Heading">Reachability and connectivity</span></h4>

<p><a id="X7F16B9EB8398459C" name="X7F16B9EB8398459C"></a></p>

<h5>5.4-1 DigraphDiameter</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDiameter</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer or <code class="code">fail</code>.</p>

<p>This function returns the diameter of the digraph <var class="Arg">digraph</var>.</p>

<p>If a digraph <var class="Arg">digraph</var> is strongly connected and has at least 1 vertex, then the <em>diameter</em> is the maximum shortest distance between any pair of distinct vertices. Otherwise then the diameter of <var class="Arg">digraph</var> is undefined, and this function returns the value <code class="code">fail</code>.</p>

<p>See <code class="func">DigraphShortestDistances</code> (<a href="chap5_mj.html#X81F99BC67E9D050F"><span class="RefLink">5.4-3</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [4, 5], [5], [1, 2, 3, 4, 5]]);</span>
&lt;immutable digraph with 5 vertices, 10 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDiameter(D);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(2);</span>
&lt;immutable chain digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDiameter(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsStronglyConnectedDigraph(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 6, 2);</span>
&lt;mutable digraph with 12 vertices, 36 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDiameter(D);</span>
4
</pre></div>

<p><a id="X8104A9D37BCD8A05" name="X8104A9D37BCD8A05"></a></p>

<h5>5.4-2 DigraphShortestDistance</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphShortestDistance</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphShortestDistance</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphShortestDistance</code>( <var class="Arg">digraph</var>, <var class="Arg">list1</var>, <var class="Arg">list2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An integer or <code class="keyw">fail</code></p>

<p>If there is a directed path in the digraph <var class="Arg">digraph</var> between vertex <var class="Arg">u</var> and vertex <var class="Arg">v</var>, then this operation returns the length of the shortest such directed path. If no such directed path exists, then this operation returns <code class="keyw">fail</code>. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of a directed path.</p>

<p>If the second form is used, then <var class="Arg">list</var> should be a list of length two, containing two positive integers which correspond to the vertices <var class="Arg">u</var> and <var class="Arg">v</var>.</p>

<p>Note that as usual, a vertex is considered to be at distance 0 from itself .</p>

<p>If the third form is used, then <var class="Arg">list1</var> and <var class="Arg">list2</var> are both lists of vertices. The shortest directed path between <var class="Arg">list1</var> and <var class="Arg">list2</var> is then the length of the shortest directed path which starts with a vertex in <var class="Arg">list1</var> and terminates at a vertex in <var class="Arg">list2</var>, if such directed path exists. If <var class="Arg">list1</var> and <var class="Arg">list2</var> have non-empty intersection, the operation returns <code class="code">0</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [1, 4], [1, 3], [5]]);</span>
&lt;immutable digraph with 5 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistance(D, 1, 3);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistance(D, [3, 3]);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistance(D, 5, 2);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistance(D, [1, 2], [4, 5]);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistance(D, [1, 3], [3, 5]);</span>
0
</pre></div>

<p><a id="X81F99BC67E9D050F" name="X81F99BC67E9D050F"></a></p>

<h5>5.4-3 DigraphShortestDistances</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphShortestDistances</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A square matrix.</p>

<p>If <var class="Arg">digraph</var> is a digraph with <span class="SimpleMath">\(n\)</span> vertices, then this function returns an <span class="SimpleMath">\(n \times n\)</span> matrix <code class="code">mat</code>, where each entry is either a non-negative integer, or <code class="keyw">fail</code>. If <span class="SimpleMath">\(n = 0\)</span>, then an empty list is returned.</p>

<p>If there is a directed path from vertex <code class="code">i</code> to vertex <code class="code">j</code>, then the value of <code class="code">mat[i][j]</code> is the length of the shortest such directed path. If no such directed path exists, then the value of <code class="code">mat[i][j]</code> is <code class="code">fail</code>. We use the convention that the distance from every vertex to itself is <code class="code">0</code>, i.e. <code class="code">mat[i][i] = 0</code> for all vertices <code class="code">i</code>.</p>

<p>The method used in this function is a version of the Floyd-Warshall algorithm, and has complexity <span class="SimpleMath">\(O(n^3)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 2], [3], [1, 2], [4]]);</span>
&lt;immutable digraph with 4 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := DigraphShortestDistances(D);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintArray(mat);</span>
[ [     0,     1,     2,  fail ],
  [     2,     0,     1,  fail ],
  [     1,     1,     0,  fail ],
  [  fail,  fail,  fail,     0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestDistances(D);</span>
[ [ 0, 1, 2 ], [ 2, 0, 1 ], [ 1, 2, 0 ] ]
</pre></div>

<p><a id="X8223718079D98A82" name="X8223718079D98A82"></a></p>

<h5>5.4-4 DigraphLongestDistanceFromVertex</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphLongestDistanceFromVertex</code>( <var class="Arg">digraph</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An integer, or <code class="keyw">infinity</code>.</p>

<p>If <var class="Arg">digraph</var> is a digraph and <var class="Arg">v</var> is a vertex in <var class="Arg">digraph</var>, then this operation returns the length of the longest directed walk in <var class="Arg">digraph</var> which begins at vertex <var class="Arg">v</var>. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definitions of directed walk, directed cycle, and loop.</p>


<ul>
<li><p>If there exists a directed walk starting at vertex <var class="Arg">v</var> which traverses a loop or a directed cycle, then we consider there to be a walk of infinite length from <var class="Arg">v</var> (realised by repeatedly traversing the loop/directed cycle), and so the result is <code class="keyw">infinity</code>. To disallow walks using loops, try using <code class="func">DigraphRemoveLoops</code> (<a href="chap3_mj.html#X79324AF7818C0C02"><span class="RefLink">3.3-25</span></a>):</p>

<p><code class="code">DigraphLongestDistanceFromVertex(DigraphRemoveLoops(<var class="Arg">digraph</var>,<var class="Arg">v</var>))</code>.</p>

</li>
<li><p>Otherwise, if all directed walks starting at vertex <var class="Arg">v</var> have finite length, then the length of the longest such walk is returned.</p>

</li>
</ul>
<p>Note that the result is <code class="code">0</code> if and only if <var class="Arg">v</var> is a sink of <var class="Arg">digraph</var>. See <code class="func">DigraphSinks</code> (<a href="chap5_mj.html#X85D5E08280914EE4"><span class="RefLink">5.1-6</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3, 4], [], [5], [], [6]]);</span>
&lt;immutable digraph with 6 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestDistanceFromVertex(D, 1);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestDistanceFromVertex(D, 3);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">3 in DigraphSinks(D);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestDistanceFromVertex(D, 6);</span>
infinity
</pre></div>

<p><a id="X7CB7DDCD84621D38" name="X7CB7DDCD84621D38"></a></p>

<h5>5.4-5 DigraphDistanceSet</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDistanceSet</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var>, <var class="Arg">distance</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDistanceSet</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var>, <var class="Arg">distances</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices</p>

<p>This operation returns the list of all vertices in digraph <var class="Arg">digraph</var> such that the shortest distance to a vertex <var class="Arg">vertex</var> is <var class="Arg">distance</var> or is in the list <var class="Arg">distances</var>.</p>

<p><var class="Arg">digraph</var> should be a digraph, <var class="Arg">vertex</var> should be a positive integer, <var class="Arg">distance</var> should be a non-negative integer, and <var class="Arg">distances</var> should be a list of non-negative integers.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [1, 4], [1, 3]]);</span>
&lt;immutable digraph with 4 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDistanceSet(D, 2, [1, 2]);</span>
[ 3, 1, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDistanceSet(D, 3, 1);</span>
[ 1, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDistanceSet(D, 2, 0);</span>
[ 2 ]
</pre></div>

<p><a id="X79A3DA4078CF3C90" name="X79A3DA4078CF3C90"></a></p>

<h5>5.4-6 DigraphGirth</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphGirth</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer, or <code class="keyw">infinity</code>.</p>

<p>This attribute returns the <em>girth</em> of the digraph <var class="Arg">digraph</var>. The <em>girth</em> of a digraph is the length of its shortest simple circuit. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definitions of simple circuit, directed cycle, and loop.</p>

<p>If <var class="Arg">digraph</var> has no directed cycles, then this function will return <code class="keyw">infinity</code>. If <var class="Arg">digraph</var> contains a loop, then this function will return <code class="code">1</code>.</p>

<p>In the worst case, the method used in this function is a version of the Floyd-Warshall algorithm, and has complexity <code class="code">O(<var class="Arg">n</var> ^ 3)</code>, where <var class="Arg">n</var> is the number of vertices in <var class="Arg">digraph</var>. If the digraph has known automorphisms [see <code class="func">DigraphGroup</code> (<a href="chap7_mj.html#X803ACEDA7BBAC5B3"><span class="RefLink">7.2-10</span></a>)], then the performance is likely to be better.</p>

<p>For symmetric digraphs, see also <code class="func">DigraphUndirectedGirth</code> (<a href="chap5_mj.html#X84688B337BDDBB09"><span class="RefLink">5.4-8</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [1]]);</span>
&lt;immutable digraph with 2 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGirth(D);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 3], [3], [4], []]);</span>
&lt;immutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGirth(D);</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 3], [3], [4], [1]]);</span>
&lt;immutable digraph with 4 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGirth(D);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 6, 2);</span>
&lt;mutable digraph with 12 vertices, 36 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphGirth(D);</span>
2
</pre></div>

<p><a id="X8374B7357EC189C1" name="X8374B7357EC189C1"></a></p>

<h5>5.4-7 DigraphOddGirth</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphOddGirth</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer, or <code class="keyw">infinity</code>.</p>

<p>This attribute returns the <em>odd girth</em> of the digraph <var class="Arg">digraph</var>. The <em>odd girth</em> of a digraph is the length of its shortest simple circuit of odd length. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definitions of simple circuit, directed cycle, and loop.</p>

<p>If <var class="Arg">digraph</var> has no directed cycles of odd length, then this function will return <code class="keyw">infinity</code>, even if <var class="Arg">digraph</var> has a directed cycle of even length. If <var class="Arg">digraph</var> contains a loop, then this function will return <code class="code">1</code>.</p>

<p>See also <code class="func">DigraphGirth</code> (<a href="chap5_mj.html#X79A3DA4078CF3C90"><span class="RefLink">5.4-6</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3, 1], [1]]);</span>
&lt;immutable digraph with 3 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOddGirth(D);</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(4);</span>
&lt;immutable cycle digraph with 4 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOddGirth(D);</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [], [3], [4]]);</span>
&lt;immutable digraph with 5 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOddGirth(D);</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 4);</span>
&lt;mutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDisjointUnion(D, CycleDigraph(5));</span>
&lt;mutable digraph with 9 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphOddGirth(D);</span>
5
</pre></div>

<p><a id="X84688B337BDDBB09" name="X84688B337BDDBB09"></a></p>

<h5>5.4-8 DigraphUndirectedGirth</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphUndirectedGirth</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer or <code class="keyw">infinity</code>.</p>

<p>If <var class="Arg">digraph</var> is a symmetric digraph, then this function returns the girth of <var class="Arg">digraph</var> when treated as an undirected graph (i.e. each pair of edges <span class="SimpleMath">\([i, j]\)</span> and <span class="SimpleMath">\([j, i]\)</span> is treated as a single edge between <span class="SimpleMath">\(i\)</span> and <span class="SimpleMath">\(j\)</span>).</p>

<p>The <em>girth</em> of an undirected graph is the length of its shortest simple cycle, i.e. the shortest non-trivial path starting and ending at the same vertex and passing through no vertex or edge more than once.</p>

<p>If <var class="Arg">digraph</var> has no cycles, then this function will return <code class="keyw">infinity</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 4], [1, 3], [2, 4], [1, 3]]);</span>
&lt;immutable digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphUndirectedGirth(D);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [1, 3], [2]]);</span>
&lt;immutable digraph with 3 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphUndirectedGirth(D);</span>
infinity
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [], [4], [3]]);</span>
&lt;immutable digraph with 4 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphUndirectedGirth(D);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 9, 2);</span>
&lt;mutable digraph with 18 vertices, 54 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphUndirectedGirth(D);</span>
5
</pre></div>

<p><a id="X842FAD6A7B835977" name="X842FAD6A7B835977"></a></p>

<h5>5.4-9 DigraphConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphConnectedComponents</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphNrConnectedComponents</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A record.</p>

<p>This function returns the record <code class="code">wcc</code> corresponding to the weakly connected components of the digraph <var class="Arg">digraph</var>. Two vertices of <var class="Arg">digraph</var> are in the same weakly connected component whenever they are equal, or there exists a directed path (ignoring the orientation of edges) between them. More formally, two vertices are in the same weakly connected component of <var class="Arg">digraph</var> if and only if they are in the same strongly connected component (see <code class="func">DigraphStronglyConnectedComponents</code> (<a href="chap5_mj.html#X833ECD6B7A84944C"><span class="RefLink">5.4-11</span></a>)) of the <code class="func">DigraphSymmetricClosure</code> (<a href="chap3_mj.html#X874883DD7DD450C4"><span class="RefLink">3.3-12</span></a>) of <var class="Arg">digraph</var>.</p>

<p>The set of weakly connected components is a partition of the vertex set of <var class="Arg">digraph</var>.</p>

<p>The record <code class="code">wcc</code> has 2 components: <code class="code">comps</code> and <code class="code">id</code>. The component <code class="code">comps</code> is a list of the weakly connected components of <var class="Arg">digraph</var> (each of which is a list of vertices). The component <code class="code">id</code> is a list such that the vertex <code class="code">i</code> is an element of the weakly connected component <code class="code">comps[id[i]]</code>.</p>

<p>The method used in this function has complexity <span class="SimpleMath">\(O(m+n)\)</span>, where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> is the number of vertices in the digraph.</p>

<p><code class="code">DigraphNrConnectedComponents(<var class="Arg">digraph</var>)</code> is simply a shortcut for <code class="code">Length(DigraphConnectedComponents(<var class="Arg">digraph</var>).comps)</code>, and is no more efficient.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[2], [3, 1], []]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponents(gr);</span>
rec( comps := [ [ 1, 2, 3 ] ], id := [ 1, 1, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[1], [1, 2], []]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponents(gr);</span>
rec( comps := [ [ 1, 2 ], [ 3 ] ], id := [ 1, 1, 2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrConnectedComponents(gr);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := EmptyDigraph(0);</span>
&lt;immutable empty digraph with 0 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponents(gr);</span>
rec( comps := [  ], id := [  ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 2);</span>
&lt;mutable digraph with 2 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := CycleDigraph(3);</span>
&lt;immutable cycle digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDisjointUnion(D, G);</span>
&lt;mutable digraph with 5 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponents(D);</span>
rec( comps := [ [ 1, 2 ], [ 3, 4, 5 ] ], id := [ 1, 1, 2, 2, 2 ] )
</pre></div>

<p><a id="X8484EC557810CD31" name="X8484EC557810CD31"></a></p>

<h5>5.4-10 DigraphConnectedComponent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphConnectedComponent</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>If <var class="Arg">vertex</var> is a vertex in the digraph <var class="Arg">digraph</var>, then this operation returns the connected component of <var class="Arg">vertex</var> in <var class="Arg">digraph</var>. See <code class="func">DigraphConnectedComponents</code> (<a href="chap5_mj.html#X842FAD6A7B835977"><span class="RefLink">5.4-9</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3], [2], [1, 2], [4]]);</span>
&lt;immutable digraph with 4 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponent(D, 3);</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponent(D, 2);</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphConnectedComponent(D, 4);</span>
[ 4 ]
</pre></div>

<p><a id="X833ECD6B7A84944C" name="X833ECD6B7A84944C"></a></p>

<h5>5.4-11 DigraphStronglyConnectedComponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphStronglyConnectedComponents</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphNrStronglyConnectedComponents</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A record.</p>

<p>This function returns the record <code class="code">scc</code> corresponding to the strongly connected components of the digraph <var class="Arg">digraph</var>. Two vertices of <var class="Arg">digraph</var> are in the same strongly connected component whenever they are equal, or there is a directed path from each vertex to the other. The set of strongly connected components is a partition of the vertex set of <var class="Arg">digraph</var>.</p>

<p>The record <code class="code">scc</code> has 2 components: <code class="code">comps</code> and <code class="code">id</code>. The component <code class="code">comps</code> is a list of the strongly connected components of <var class="Arg">digraph</var> (each of which is a list of vertices). The component <code class="code">id</code> is a list such that the vertex <code class="code">i</code> is an element of the strongly connected component <code class="code">comps[id[i]]</code>.</p>

<p>The method used in this function is a non-recursive version of Gabow's Algorithm <a href="chapBib_mj.html#biBGab00">[Gab00]</a> and has complexity <span class="SimpleMath">\(O(m+n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges (counting multiple edges as one) and <span class="SimpleMath">\(n\)</span> is the number of vertices in the digraph.</p>

<p><code class="code">DigraphNrStronglyConnectedComponents(<var class="Arg">digraph</var>)</code> is simply a shortcut for <code class="code">Length(DigraphStronglyConnectedComponents(<var class="Arg">digraph</var>).comps)</code>, and is no more efficient.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[2], [3, 1], []]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponents(gr);</span>
rec( comps := [ [ 3 ], [ 1, 2 ] ], id := [ 2, 2, 1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrStronglyConnectedComponents(gr);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphDisjointUnion(CycleDigraph(4), CycleDigraph(5));</span>
&lt;immutable digraph with 9 vertices, 9 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponents(D);</span>
rec( comps := [ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8, 9 ] ], 
  id := [ 1, 1, 1, 1, 2, 2, 2, 2, 2 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphNrStronglyConnectedComponents(D);</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 2);</span>
&lt;mutable digraph with 2 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := CycleDigraph(3);</span>
&lt;immutable cycle digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDisjointUnion(D, G);</span>
&lt;mutable digraph with 5 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponents(D);</span>
rec( comps := [ [ 1, 2 ], [ 3, 4, 5 ] ], id := [ 1, 1, 2, 2, 2 ] )
</pre></div>

<p><a id="X7EFCB5017D662254" name="X7EFCB5017D662254"></a></p>

<h5>5.4-12 DigraphStronglyConnectedComponent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphStronglyConnectedComponent</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>If <var class="Arg">vertex</var> is a vertex in the digraph <var class="Arg">digraph</var>, then this operation returns the strongly connected component of <var class="Arg">vertex</var> in <var class="Arg">digraph</var>. See <code class="func">DigraphStronglyConnectedComponents</code> (<a href="chap5_mj.html#X833ECD6B7A84944C"><span class="RefLink">5.4-11</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3], [2], [1, 2], [3]]);</span>
&lt;immutable digraph with 4 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponent(D, 3);</span>
[ 1, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponent(D, 2);</span>
[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponent(D, 4);</span>
[ 4 ]
</pre></div>

<p><a id="X7F1B5A2782F598B1" name="X7F1B5A2782F598B1"></a></p>

<h5>5.4-13 DigraphBicomponents</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphBicomponents</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A pair of lists of vertices, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a bipartite digraph, i.e. if it satisfies <code class="func">IsBipartiteDigraph</code> (<a href="chap6_mj.html#X860CFB0C8665F356"><span class="RefLink">6.2-3</span></a>), then <code class="code">DigraphBicomponents</code> returns a pair of bicomponents of <var class="Arg">digraph</var>. Otherwise, <code class="code">DigraphBicomponents</code> returns <code class="keyw">fail</code>.</p>

<p>For a bipartite digraph, the vertices can be partitioned into two non-empty sets such that the source and range of any edge are in distinct sets. The parts of this partition are called <em>bicomponents</em> of <var class="Arg">digraph</var>. Equivalently, a pair of bicomponents of <var class="Arg">digraph</var> consists of the color-classes of a 2-coloring of <var class="Arg">digraph</var>.</p>

<p>For a bipartite digraph with at least 3 vertices, there is a unique pair of bicomponents of bipartite if and only if the digraph is connected. See <code class="func">IsConnectedDigraph</code> (<a href="chap6_mj.html#X83C08C0B7EC1A91F"><span class="RefLink">6.6-3</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(3);</span>
&lt;immutable cycle digraph with 3 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphBicomponents(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(5);</span>
&lt;immutable chain digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphBicomponents(D);</span>
[ [ 1, 3, 5 ], [ 2, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[5], [1, 4], [5], [5], []]);</span>
&lt;immutable digraph with 5 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphBicomponents(D);</span>
[ [ 1, 3, 4 ], [ 2, 5 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteBipartiteDigraph(IsMutableDigraph, 2, 3);</span>
&lt;mutable digraph with 5 vertices, 12 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphBicomponents(D);</span>
[ [ 1, 2 ], [ 3, 4, 5 ] ]
</pre></div>

<p><a id="X7DDE06E47E605DD7" name="X7DDE06E47E605DD7"></a></p>

<h5>5.4-14 ArticulationPoints</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ArticulationPoints</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices.</p>

<p>A connected digraph is <em>biconnected</em> if it is still connected (in the sense of <code class="func">IsConnectedDigraph</code> (<a href="chap6_mj.html#X83C08C0B7EC1A91F"><span class="RefLink">6.6-3</span></a>)) when any vertex is removed. If the digraph <var class="Arg">digraph</var> is not biconnected but is connected, then any vertex <code class="code">v</code> of <var class="Arg">digraph</var> whose removal makes the resulting digraph disconnected is called an <em>articulation point</em>.</p>

<p><code class="code">ArticulationPoints</code> returns a list of the articulation points of <var class="Arg">digraph</var>, if any, and, in particular, returns the empty list if <var class="Arg">digraph</var> is not connected.</p>

<p>Multiple edges are ignored by this method.</p>

<p>The method used in this operation has complexity <span class="SimpleMath">\(O(m+n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> is the number of vertices in the digraph.</p>

<p>If <var class="Arg">D</var> has a bridge (see <code class="func">Bridges</code> (<a href="chap5_mj.html#X84D5A125848BD800"><span class="RefLink">5.4-15</span></a>)), then a node incident to the bridge is an articulation point if and only if it has degree at least <span class="SimpleMath">\(2\)</span>. It follows that if <var class="Arg">D</var> has a bridge and at least <span class="SimpleMath">\(3\)</span> nodes, then at least one of the nodes incident to the bridge is an articulation point. The converse does not hold, there are digraphs with articulation points, but no bridges.</p>

<p>See also <code class="func">IsBiconnectedDigraph</code> (<a href="chap6_mj.html#X838FAF2D825977BE"><span class="RefLink">6.6-4</span></a>) and <code class="func">IsBridgelessDigraph</code> (<a href="chap6_mj.html#X7D2A6572820B7F24"><span class="RefLink">6.6-5</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ArticulationPoints(CycleDigraph(5));</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 7], [3, 5], [4], [2], [6], [1], []]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ArticulationPoints(D);</span>
[ 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ArticulationPoints(ChainDigraph(5));</span>
[ 4, 3, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ArticulationPoints(NullDigraph(5));</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(IsMutableDigraph, 4);</span>
&lt;mutable digraph with 4 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ArticulationPoints(D);</span>
[ 3, 2 ]
</pre></div>

<p><a id="X84D5A125848BD800" name="X84D5A125848BD800"></a></p>

<h5>5.4-15 Bridges</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Bridges</code>( <var class="Arg">D</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A (possibly empty) list of edges.</p>

<p>A connected digraph is <em>2-edge-connected</em> if it is still connected (in the sense of <code class="func">IsConnectedDigraph</code> (<a href="chap6_mj.html#X83C08C0B7EC1A91F"><span class="RefLink">6.6-3</span></a>)) when any edge is removed. If the digraph <var class="Arg">D</var> is not 2-edge-connected but is connected, then any edge <code class="code">[u, v]</code> of <var class="Arg">D</var> whose removal makes the resulting digraph disconnected is called a <em>bridge</em>.</p>

<p><code class="code">Bridges</code> returns a list of the bridges of <var class="Arg">D</var>, if any, and, in particular, returns the empty list if <var class="Arg">D</var> is not connected.</p>

<p>Multiple edges are ignored by this method.</p>

<p>The method used in this operation has complexity <span class="SimpleMath">\(O(m+n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> is the number of vertices in the digraph.</p>

<p>If <var class="Arg">D</var> has a bridge, then a node incident to the bridge is an articulation point (see <code class="func">ArticulationPoints</code> (<a href="chap5_mj.html#X7DDE06E47E605DD7"><span class="RefLink">5.4-14</span></a>)) if and only if it has degree at least <span class="SimpleMath">\(2\)</span>. It follows that if <var class="Arg">D</var> has a bridge and at least <span class="SimpleMath">\(3\)</span> nodes, then at least one of the nodes incident to the bridge is an articulation point. The converse does not hold, there are digraphs with articulation points, but no bridges.</p>

<p>See also <code class="func">IsBiconnectedDigraph</code> (<a href="chap6_mj.html#X838FAF2D825977BE"><span class="RefLink">6.6-4</span></a>) and <code class="func">IsBridgelessDigraph</code> (<a href="chap6_mj.html#X7D2A6572820B7F24"><span class="RefLink">6.6-5</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 5], [1, 3, 4, 5], [2, 4], [2, 3], [1, 2]]);</span>
&lt;immutable digraph with 5 vertices, 12 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Bridges(D);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [4], [2]]);</span>
&lt;immutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Bridges(D);</span>
[ [ 1, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Bridges(ChainDigraph(2));</span>
[ [ 1, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ArticulationPoints(ChainDigraph(2));</span>
[  ]
</pre></div>

<p><a id="X865590147BD1C507" name="X865590147BD1C507"></a></p>

<h5>5.4-16 StrongOrientation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StrongOrientation</code>( <var class="Arg">D</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StrongOrientationAttr</code>( <var class="Arg">D</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A digraph or <code class="keyw">fail</code>.</p>

<p>A <em>strong orientation</em> of a connected symmetric digraph <var class="Arg">D</var> (if it exists) is a strongly connected subdigraph <code class="code">C</code> of <var class="Arg">D</var> such that for every edge <code class="code">[u, v]</code> of <var class="Arg">D</var> either <code class="code">[u, v]</code> or <code class="code">[v, u]</code> is an edge of <code class="code">C</code> but not both. Robbin's Theorem states that a digraph admits a strong orientation if and only if it is bridgeless (see <code class="func">IsBridgelessDigraph</code> (<a href="chap6_mj.html#X7D2A6572820B7F24"><span class="RefLink">6.6-5</span></a>)).</p>

<p>This operation returns a strong orientation of the digraph <var class="Arg">D</var> if <var class="Arg">D</var> is symmetric and <var class="Arg">D</var> admits a strong orientation. If <var class="Arg">D</var> is symmetric but does not admit a strong orientation, then <code class="keyw">fail</code> is returned. If <var class="Arg">D</var> is not symmetric, then an error is given.</p>

<p>If <var class="Arg">D</var> is immutable, <code class="code">StrongOrientation(<var class="Arg">D</var>)</code> returns an immutable digraph, and if <var class="Arg">D</var> is mutable, then <code class="code">StrongOrientation(<var class="Arg">D</var>)</code> returns a mutable digraph.</p>

<p>The method used in this operation has complexity <span class="SimpleMath">\(O(m+n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> is the number of vertices in the digraph.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StrongOrientation(DigraphSymmetricClosure(CycleDigraph(5))) </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">= CycleDigraph(5);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphSymmetricClosure(Digraph(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[[2, 7], [3, 5], [4], [2], [6], [1], []]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBridgelessDigraph(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StrongOrientation(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StrongOrientation(NullDigraph(0));</span>
&lt;immutable empty digraph with 0 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StrongOrientation(DigraphDisjointUnion(CompleteDigraph(3), </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                          CompleteDigraph(3)));</span>
fail
</pre></div>

<p><a id="X853D0B0981A33433" name="X853D0B0981A33433"></a></p>

<h5>5.4-17 DigraphPeriod</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphPeriod</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer.</p>

<p>This function returns the period of the digraph <var class="Arg">digraph</var>.</p>

<p>If a digraph <var class="Arg">digraph</var> has at least one directed cycle, then the period is the greatest positive integer which divides the lengths of all directed cycles of <var class="Arg">digraph</var>. If <var class="Arg">digraph</var> has no directed cycles, then this function returns <span class="SimpleMath">\(0\)</span>. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of a directed cycle.</p>

<p>A digraph with a period of <span class="SimpleMath">\(1\)</span> is said to be <em>aperiodic</em>. See <code class="func">IsAperiodicDigraph</code> (<a href="chap6_mj.html#X80E883967EBE839E"><span class="RefLink">6.6-7</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[6], [1], [2], [3], [4, 4], [5]]);</span>
&lt;immutable multidigraph with 6 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPeriod(D);</span>
6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3, 5], [4], [5], [1, 2]]);</span>
&lt;immutable digraph with 5 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPeriod(D);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(2);</span>
&lt;immutable chain digraph with 2 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPeriod(D);</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAcyclicDigraph(D);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 5, 2);</span>
&lt;mutable digraph with 10 vertices, 30 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPeriod(D);</span>
1
</pre></div>

<p><a id="X864A31A8809F61C2" name="X864A31A8809F61C2"></a></p>

<h5>5.4-18 DigraphFloydWarshall</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphFloydWarshall</code>( <var class="Arg">digraph</var>, <var class="Arg">func</var>, <var class="Arg">nopath</var>, <var class="Arg">edge</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A matrix.</p>

<p>If <var class="Arg">digraph</var> is a digraph with <span class="SimpleMath">\(n\)</span> vertices, then this operation returns an <span class="SimpleMath">\(n \times n\)</span> matrix <code class="code">mat</code> containing the output of a generalised version of the Floyd-Warshall algorithm, applied to <var class="Arg">digraph</var>.</p>

<p>The operation <code class="code">DigraphFloydWarshall</code> is customised by the arguments <var class="Arg">func</var>, <var class="Arg">nopath</var>, and <var class="Arg">edge</var>. The arguments <var class="Arg">nopath</var> and <var class="Arg">edge</var> can be arbitrary <strong class="pkg">GAP</strong> objects. The argument <var class="Arg">func</var> must be a function which accepts 4 arguments: the matrix <code class="code">mat</code>, followed by 3 positive integers. The function <var class="Arg">func</var> is where the work to calculate the desired outcome must be performed.</p>

<p>This method initialises the matrix <code class="code">mat</code> by setting entry <code class="code">mat[i][j]</code> to equal <var class="Arg">edge</var> if there is an edge with source <code class="code">i</code> and range <code class="code">j</code>, and by setting entry <code class="code">mat[i][j]</code> to equal <var class="Arg">nopath</var> otherwise. The final part of <code class="code">DigraphFloydWarshall</code> then calls the function <var class="Arg">func</var> inside three nested for loops, over the vertices of <var class="Arg">digraph</var>:</p>


<div class="example"><pre>
for i in DigraphsVertices(digraph) do
  for j in DigraphsVertices(digraph) do
    for k in DigraphsVertices(digraph) do
      func(mat, i, j, k);
    od;
  od;
od;
</pre></div>

<p>The matrix <code class="code">mat</code> is then returned as the result. An example of using <code class="code">DigraphFloydWarshall</code> to calculate the shortest (non-zero) distances between the vertices of a digraph is shown below:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphFromDigraph6String("&amp;EAHQeDB");</span>
&lt;immutable digraph with 6 vertices, 12 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function(mat, i, j, k)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  if mat[i][k] &lt;&gt; -1 and mat[k][j] &lt;&gt; -1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if (mat[i][j] = -1) or (mat[i][j] &gt; mat[i][k] + mat[k][j]) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      mat[i][j] := mat[i][k] + mat[k][j];</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;</span>
function( mat, i, j, k ) ... end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">shortest_distances := DigraphFloydWarshall(D, func, -1, 1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(shortest_distances);</span>
[ [   3,  -1,  -1,   2,   1,   2 ],
  [   4,   2,   1,   3,   2,   1 ],
  [   3,   1,   2,   2,   1,   2 ],
  [   1,  -1,  -1,   1,   1,   2 ],
  [   2,  -1,  -1,   1,   2,   1 ],
  [   3,  -1,  -1,   2,   1,   1 ] ]
</pre></div>

<p><a id="X7FBAB09E7C0BE5CF" name="X7FBAB09E7C0BE5CF"></a></p>

<h5>5.4-19 IsReachable</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsReachable</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This operation returns <code class="keyw">true</code> if there exists a non-trivial directed walk from vertex <var class="Arg">u</var> to vertex <var class="Arg">v</var> in the digraph <var class="Arg">digraph</var>, and <code class="keyw">false</code> if there does not exist such a directed walk. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of a non-trivial directed walk.</p>

<p>The method for <code class="code">IsReachable</code> has worst case complexity of <span class="SimpleMath">\(O(m + n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> the number of vertices in <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [2, 3]]);</span>
&lt;immutable digraph with 3 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReachable(D, 1, 3);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReachable(D, 2, 1);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReachable(D, 3, 3);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsReachable(D, 1, 1);</span>
false
</pre></div>

<p><a id="X7ECD22877AEA89CC" name="X7ECD22877AEA89CC"></a></p>

<h5>5.4-20 IsDigraphPath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphPath</code>( <var class="Arg">D</var>, <var class="Arg">v</var>, <var class="Arg">a</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDigraphPath</code>( <var class="Arg">D</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>This function returns <code class="keyw">true</code> if the arguments <var class="Arg">v</var> and <var class="Arg">a </var> describe a path in the digraph <var class="Arg">D</var>. A directed path (or directed cycle) of non-zero length <code class="code">n-1</code>, <span class="SimpleMath">\((v_1, e_1, v_2, e_2, ..., e_{n-1}, v_n)\)</span>, is represented by a pair of lists <code class="code">[<var class="Arg">v</var>, <var class="Arg">a</var>]</code> as follows:</p>


<ul>
<li><p><var class="Arg">v</var> is the list <span class="SimpleMath">\([v_1, v_2, ..., v_n]\)</span>.</p>

</li>
<li><p><var class="Arg">a</var> is the list of positive integers <span class="SimpleMath">\([a_1, a_2, ..., a_{n-1}]\)</span> where for each each <span class="SimpleMath">\(i &lt; n\)</span>, <span class="SimpleMath">\(a_i\)</span> is the position of <span class="SimpleMath">\(v_{i+1}\)</span> in <code class="code">OutNeighboursOfVertex(</code><var class="Arg">D</var><code class="code">,</code><span class="SimpleMath">\(v_i\)</span><code class="code">)</code> corresponding to the edge <span class="SimpleMath">\(e_i\)</span>. This can be useful if the position of a vertex in a list of out-neighours is significant, for example in orbit digraphs.</p>

</li>
</ul>
<p>If the arguments to <code class="code">IsDigraphPath</code> are a digraph <var class="Arg">D</var> and list <var class="Arg">list</var>, then this is equivalent to calling <code class="code">IsDigraphPath(<var class="Arg">D</var>, <var class="Arg">list</var>[1], <var class="Arg">list</var>[2])</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, Combinations([1 .. 5]), IsSubset);</span>
&lt;mutable digraph with 32 vertices, 243 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphReflexiveTransitiveReduction(D);</span>
&lt;mutable digraph with 32 vertices, 80 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MakeImmutable(D);</span>
&lt;immutable digraph with 32 vertices, 80 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphPath(D, [32, 31, 33], [1, 1]);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphPath(D, [1], []);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphPath(D, [6, 9, 16, 17], [3, 3, 2]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDigraphPath(D, DigraphPath(D, 6, 1));</span>
true
</pre></div>

<p><a id="X7F255A2A84CB868C" name="X7F255A2A84CB868C"></a></p>

<h5>5.4-21 VerticesReachableFrom</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VerticesReachableFrom</code>( <var class="Arg">digraph</var>, <var class="Arg">root</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VerticesReachableFrom</code>( <var class="Arg">digraph</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list.</p>

<p>This operation returns a list of the vertices <code class="code">v</code>, for which there exists a non-trivial directed walk from the vertex <var class="Arg">root</var>, or any of the list of vertices <var class="Arg">list</var>, to vertex <code class="code">v</code> in the digraph <var class="Arg">digraph</var>. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of a non-trivial directed walk.</p>

<p>The method for <code class="code">VerticesReachableFrom</code> has worst case complexity of <span class="SimpleMath">\(O(m + n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> the number of vertices in <var class="Arg">digraph</var>.</p>

<p>This function returns an error if <var class="Arg">root</var>, or any vertex in <var class="Arg">list</var>, is not a vertices of <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(5);</span>
&lt;immutable complete digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, 1);</span>
[ 1, 2, 3, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, 3);</span>
[ 1, 2, 3, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := EmptyDigraph(5);</span>
&lt;immutable empty digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, 1);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, 3);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, [1, 2, 3, 4]);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, [3, 4, 5]);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(4);</span>
&lt;immutable cycle digraph with 4 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, 1);</span>
[ 1, 2, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, 3);</span>
[ 1, 2, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(5);</span>
&lt;immutable chain digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, 1);</span>
[ 2, 3, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, 3);</span>
[ 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, 5);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">VerticesReachableFrom(D, [3, 4]);</span>
[ 4, 5 ]
</pre></div>

<p><a id="X8039170B82A32257" name="X8039170B82A32257"></a></p>

<h5>5.4-22 DigraphPath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphPath</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A pair of lists, or <code class="keyw">fail</code>.</p>

<p>If there exists a non-trivial directed path (or a non-trivial cycle, in the case that <var class="Arg">u</var> <code class="code">=</code> <var class="Arg">v</var>) from vertex <var class="Arg">u</var> to vertex <var class="Arg">v</var> in the digraph <var class="Arg">digraph</var>, then this operation returns such a directed path (or directed cycle). Otherwise, this operation returns <code class="keyw">fail</code>. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink"><span class="Heading">Definitions</span></span></a> for the definition of a directed path and a directed cycle.</p>

<p>A directed path (or directed cycle) of non-zero length <code class="code">n-1</code>, <span class="SimpleMath">\((v_1, e_1, v_2, e_2, ..., e_{n-1}, v_n)\)</span>, is represented by a pair of lists <code class="code">[v,a]</code> as follows:</p>


<ul>
<li><p><code class="code">v</code> is the list <span class="SimpleMath">\([v_1, v_2, ..., v_n]\)</span>.</p>

</li>
<li><p><code class="code">a</code> is the list of positive integers <span class="SimpleMath">\([a_1, a_2, ..., a_{n-1}]\)</span> where for each each <span class="SimpleMath">\(i &lt; n\)</span>, <span class="SimpleMath">\(a_i\)</span> is the position of <span class="SimpleMath">\(v_{i+1}\)</span> in <code class="code">OutNeighboursOfVertex(</code><var class="Arg">digraph</var><code class="code">,</code><span class="SimpleMath">\(v_i\)</span><code class="code">)</code> corresponding to the edge <span class="SimpleMath">\(e_i\)</span>. This can be useful if the position of a vertex in a list of out-neighours is significant, for example in orbit digraphs.</p>

</li>
</ul>
<p>The method for <code class="code">DigraphPath</code> has worst case complexity of <span class="SimpleMath">\(O(m + n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> the number of vertices in <var class="Arg">digraph</var>.</p>

<p>See also <code class="func">IsDigraphPath</code> (<a href="chap5_mj.html#X7ECD22877AEA89CC"><span class="RefLink">5.4-20</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [2, 3]]);</span>
&lt;immutable digraph with 3 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPath(D, 1, 3);</span>
[ [ 1, 2, 3 ], [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPath(D, 2, 1);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPath(D, 3, 3);</span>
[ [ 3, 3 ], [ 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphPath(D, 1, 1);</span>
fail
</pre></div>

<p><a id="X80E9D645843973A6" name="X80E9D645843973A6"></a></p>

<h5>5.4-23 DigraphShortestPath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphShortestPath</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A pair of lists, or <code class="keyw">fail</code>.</p>

<p>Returns a shortest directed path in the digraph <var class="Arg">digraph</var> from vertex <var class="Arg">u</var> to vertex <var class="Arg">v</var>, if such a path exists. If <code class="code"><var class="Arg">u</var> = <var class="Arg">v</var></code>, then the shortest non-trivial cycle is returned, again, if it exists. Otherwise, this operation returns <code class="keyw">fail</code>. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink"><span class="Heading">Definitions</span></span></a> for the definition of a directed path and a directed cycle.</p>

<p>See <code class="func">DigraphPath</code> (<a href="chap5_mj.html#X8039170B82A32257"><span class="RefLink">5.4-22</span></a>) for details on the output. The method for <code class="code">DigraphShortestPath</code> has worst case complexity of <span class="SimpleMath">\(O(m + n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> the number of vertices in <var class="Arg">digraph</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 2], [3], [2, 4], [1], [2, 4]]);</span>
&lt;immutable digraph with 5 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestPath(D, 5, 1);</span>
[ [ 5, 4, 1 ], [ 2, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestPath(D, 3, 3);</span>
[ [ 3, 2, 3 ], [ 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestPath(D, 5, 5);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphShortestPath(D, 1, 1);</span>
[ [ 1, 1 ], [ 1 ] ]
</pre></div>

<p><a id="X7C45396C808308C4" name="X7C45396C808308C4"></a></p>

<h5>5.4-24 DigraphRandomWalk</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphRandomWalk</code>( <var class="Arg">digraph</var>, <var class="Arg">v</var>, <var class="Arg">t</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A pair of lists.</p>

<p>Returns a directed path corresponding to a <em>random walk</em> in the digraph <var class="Arg">digraph</var>, starting at vertex <var class="Arg">v</var> and having length no more than <var class="Arg">t</var>.</p>

<p>A random walk is defined as follows. The path begins at <var class="Arg">v</var>, and at each step it follows a random edge leaving the current vertex. It continues through the digraph in this way until it has traversed <var class="Arg">t</var> edges, or until it reaches a vertex with no out-edges (a <em>sink</em>) and therefore cannot continue.</p>

<p>The output has the same form as that of <code class="func">DigraphPath</code> (<a href="chap5_mj.html#X8039170B82A32257"><span class="RefLink">5.4-22</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 2], [3], [2, 4], [1], [2, 4]]);                </span>
&lt;immutable digraph with 5 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphRandomWalk(D, 1, 4);</span>
[ [ 1, 2, 3, 2, 3 ], [ 2, 1, 1, 1 ] ]
</pre></div>

<p><a id="X787459247B2005E6" name="X787459247B2005E6"></a></p>

<h5>5.4-25 DigraphAbsorptionProbabilities</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphAbsorptionProbabilities</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A matrix of rational numbers.</p>

<p>A random walk of infinite length through a finite digraph may pass through several different strongly connected components (SCCs). However, with probability 1 it must eventually reach an SCC which it can never leave, because the SCC has no out-edges leading to other SCCs. We may say that such an SCC has <em>absorbed</em> the random walk, and we can calculate the probability of each SCC absorbing a walk starting at a given vertex.</p>

<p><code class="code">DigraphAbsorptionProbabilities</code> returns an <span class="SimpleMath">\(m \times n\)</span> matrix <code class="code">mat</code>, where <span class="SimpleMath">\(m\)</span> is the number of vertices in <code class="code">digraph</code> and <span class="SimpleMath">\(n\)</span> is the number of strongly connected components. Each entry <code class="code">mat[i][j]</code> is a rational number representing the probability that an unbounded random walk starting at vertex <code class="code">i</code> will be absorbed by strongly connected component <code class="code">j</code> – that is, the probability that it will reach the component and never leave.</p>

<p>Strongly connected components are indexed in the order given by <code class="func">DigraphStronglyConnectedComponents</code> (<a href="chap5_mj.html#X833ECD6B7A84944C"><span class="RefLink">5.4-11</span></a>). See also <code class="func">DigraphRandomWalk</code> (<a href="chap5_mj.html#X7C45396C808308C4"><span class="RefLink">5.4-24</span></a>) and <code class="func">DigraphAbsorptionExpectedSteps</code> (<a href="chap5_mj.html#X7B0A62CF7F6F23E9"><span class="RefLink">5.4-26</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[2, 3, 4], [3], [2], []]);</span>
&lt;immutable digraph with 4 vertices, 5 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphStronglyConnectedComponents(gr).comps;</span>
[ [ 2, 3 ], [ 4 ], [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAbsorptionProbabilities(gr);</span>
[ [ 2/3, 1/3, 0 ], [ 1, 0, 0 ], [ 1, 0, 0 ], [ 0, 1, 0 ] ]
</pre></div>

<p><a id="X7B0A62CF7F6F23E9" name="X7B0A62CF7F6F23E9"></a></p>

<h5>5.4-26 DigraphAbsorptionExpectedSteps</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphAbsorptionExpectedSteps</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of rational numbers.</p>

<p>A random walk of unbounded length through a finite digraph may pass through several different strongly connected components (SCCs). However, with probability 1 it must eventually reach an SCC which it can never leave, because the SCC has no out-edges leading to other SCCs. When this happens, we say the walk has been <em>absorbed</em>.</p>

<p><code class="code">DigraphAbsorptionExpectedSteps</code> returns a list <code class="code">L</code> with length equal to the number of vertices of <var class="Arg">digraph</var>, where <code class="code">L[v]</code> is the expected number of steps a random walk starting at vertex <code class="code">v</code> should take before it is absorbed – that is, the expected number of steps to reach an SCC that it can never leave.</p>

<p>See also <code class="func">DigraphRandomWalk</code> (<a href="chap5_mj.html#X7C45396C808308C4"><span class="RefLink">5.4-24</span></a>) and <code class="func">DigraphAbsorptionProbabilities</code> (<a href="chap5_mj.html#X787459247B2005E6"><span class="RefLink">5.4-25</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[2], [3, 4], [], [2]]);</span>
&lt;immutable digraph with 4 vertices, 4 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAbsorptionExpectedSteps(gr);</span>
[ 4, 3, 0, 4 ]
</pre></div>

<p><a id="X7FE79CB278CE6991" name="X7FE79CB278CE6991"></a></p>

<h5>5.4-27 Dominators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Dominators</code>( <var class="Arg">digraph</var>, <var class="Arg">root</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list of lists.</p>

<p><code class="code">Dominators</code> takes a <var class="Arg">digraph</var> and a root <var class="Arg">root</var> and returns the dominators of each vertex with respect to the root. The output is returned as a list of length <code class="code">DigraphNrVertices(<var class="Arg">Digraph</var>)</code>, whose <var class="Arg">i</var>th entry is a list with the dominators of vertex <var class="Arg">i</var> of the <var class="Arg">digraph</var>. If there is no path from the root to a specific vertex, the output will contain a hole in the corresponding position. The <em>dominators</em> of a vertex <span class="SimpleMath">\(u\)</span> are the vertices that are contained in every path from the <span class="SimpleMath">\(root\)</span> to <span class="SimpleMath">\(u\)</span>, not including <span class="SimpleMath">\(u\)</span> itself. The method for this operation is an implementation of an algorithm by Thomas Lengauer and Robert Endre Tarjan <a href="chapBib_mj.html#biBLT79">[LT79]</a>. The complexity of this algorithm is <span class="SimpleMath">\(O(mlog n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> is the number of nodes in the subdigraph induced by the nodes in <var class="Arg">digraph</var> reachable from <var class="Arg">root</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3, 6], [2, 4], [1], [], [3]]);</span>
&lt;immutable digraph with 6 vertices, 7 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dominators(D, 1);</span>
[ , [ 1 ], [ 2, 1 ], [ 3, 2, 1 ],, [ 2, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dominators(D, 2);</span>
[ [ 4, 3, 2 ],, [ 2 ], [ 3, 2 ],, [ 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dominators(D, 3);</span>
[ [ 4, 3 ], [ 3 ],, [ 3 ],, [ 2, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dominators(D, 4);</span>
[ [ 4 ], [ 1, 4 ], [ 2, 1, 4 ],,, [ 2, 1, 4 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dominators(D, 5);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dominators(D, 6);</span>
[ [ 4, 3, 6 ], [ 3, 6 ], [ 6 ], [ 3, 6 ] ]
</pre></div>

<p><a id="X7D66A0FB7F6100FB" name="X7D66A0FB7F6100FB"></a></p>

<h5>5.4-28 DominatorTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DominatorTree</code>( <var class="Arg">digraph</var>, <var class="Arg">root</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A record.</p>

<p><code class="code">DominatorTree</code> takes a <var class="Arg">digraph</var> and a <var class="Arg">root</var> vertex and returns a record with the following components:</p>


<dl>
<dt><strong class="Mark">idom</strong></dt>
<dd><p>the immediate dominators of the vertices with respect to the root.</p>

</dd>
<dt><strong class="Mark">preorder</strong></dt>
<dd><p>the preorder values of the vertices defined by the depth first search executed on the digraph.</p>

</dd>
</dl>
<p>The <em>immediate dominator</em> of a vertex <span class="SimpleMath">\(u\)</span> is the unique dominator of <span class="SimpleMath">\(u\)</span> that is dominated by all other dominators of <span class="SimpleMath">\(u\)</span>. The algorithm is an implementation of the fast algorithm written by Thomas Lengauer and Robert Endre Tarjan <a href="chapBib_mj.html#biBLT79">[LT79]</a>. The complexity of this algorithm is <span class="SimpleMath">\(O(mlog n)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges and <span class="SimpleMath">\(n\)</span> is the number of nodes in the subdigraph induced by the nodes in <var class="Arg">digraph</var> reachable from <var class="Arg">root</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 3], [4, 6], [4, 5], [3, 5], [1, 6], [2, 3]]);</span>
&lt;immutable digraph with 6 vertices, 12 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DominatorTree(D, 1);</span>
rec( idom := [ fail, 1, 1, 1, 1, 1 ], 
  preorder := [ 1, 2, 4, 3, 5, 6 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DominatorTree(D, 5);</span>
rec( idom := [ 5, 5, 5, 5, fail, 5 ], 
  preorder := [ 5, 1, 2, 4, 3, 6 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(5);</span>
&lt;immutable complete digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DominatorTree(D, 1);</span>
rec( idom := [ fail, 1, 1, 1, 1 ], preorder := [ 1, 2, 3, 4, 5 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DominatorTree(D, 2);</span>
rec( idom := [ 2, fail, 2, 2, 2 ], preorder := [ 2, 1, 3, 4, 5 ] )
</pre></div>

<p><a id="X7C0416FE7A69CA2C" name="X7C0416FE7A69CA2C"></a></p>

<h5>5.4-29 IteratorOfPaths</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IteratorOfPaths</code>( <var class="Arg">digraph</var>, <var class="Arg">u</var>, <var class="Arg">v</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: An iterator.</p>

<p>If <var class="Arg">digraph</var> is a digraph or a list of adjacencies which defines a digraph - see <code class="func">OutNeighbours</code> (<a href="chap5_mj.html#X7E9880767AE68E00"><span class="RefLink">5.2-6</span></a>) - then this operation returns an iterator of the non-trivial directed paths (or directed cycles, in the case that <var class="Arg">u</var> <code class="code">=</code> <var class="Arg">v</var>) in <var class="Arg">digraph</var> from the vertex <var class="Arg">u</var> to the vertex <var class="Arg">v</var>.</p>

<p>See <code class="func">DigraphPath</code> (<a href="chap5_mj.html#X8039170B82A32257"><span class="RefLink">5.4-22</span></a>) for more information about the representation of a directed path or directed cycle which is used, and see <a href="https://www.gap-system.org/Manuals/doc/ref/chap30_mj.html#X85A3F00985453F95"><span class="RefLink">Reference: Iterators</span></a> for more information about iterators. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink"><span class="Heading">Definitions</span></span></a> for the definition of a directed path and a directed cycle.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 4, 4, 2], [3, 5], [2, 3], [1, 2], [4]]);</span>
&lt;immutable multidigraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iter := IteratorOfPaths(D, 1, 4);</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
[ [ 1, 4 ], [ 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
[ [ 1, 4 ], [ 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
[ [ 1, 2, 5, 4 ], [ 4, 2, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsDoneIterator(iter);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iter := IteratorOfPaths(D, 4, 3);</span>
&lt;iterator&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NextIterator(iter);</span>
[ [ 4, 1, 2, 3 ], [ 1, 4, 1 ] ]
</pre></div>

<p><a id="X7ECD16838704FAAA" name="X7ECD16838704FAAA"></a></p>

<h5>5.4-30 DigraphAllSimpleCircuits</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphAllSimpleCircuits</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of lists of vertices.</p>

<p>If <var class="Arg">digraph</var> is a digraph, then <code class="code">DigraphAllSimpleCircuits</code> returns a list of the <em>simple circuits</em> in <var class="Arg">digraph</var>.</p>

<p>See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of a simple circuit, and related notions. Note that a loop is a simple circuit.</p>

<p>For a digraph without multiple edges, a simple circuit is uniquely determined by its subsequence of vertices. However this is not the case for a multidigraph. The attribute <code class="code">DigraphAllSimpleCircuits</code> ignores multiple edges, and identifies a simple circuit using only its subsequence of vertices. For example, although the simple circuits <span class="SimpleMath">\((v, e, v)\)</span> and <span class="SimpleMath">\((v, e', v)\)</span> (for distinct edges <span class="SimpleMath">\(e\)</span> and <span class="SimpleMath">\(e'\)</span>) are mathematically distinct, <code class="code">DigraphAllSimpleCircuits</code> considers them to be the same.</p>

<p>With this approach, a directed circuit of length <code class="code">n</code> can be determined by a list of its first <code class="code">n</code> vertices. Thus a simple circuit <span class="SimpleMath">\((v_1, e_1, v_2, e_2, ..., e_{n-1}, v_n, e_{n+1}, v_1)\)</span> can be represented as the list <span class="SimpleMath">\([v_1, \ldots, v_n]\)</span>, or any cyclic permutation thereof. For each simple circuit of <var class="Arg">digraph</var>, <code class="code">DigraphAllSimpleCircuits(<var class="Arg">digraph</var>)</code> includes precisely one such list to represent the circuit.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[], [3], [2, 4], [5, 4], [4]]);</span>
&lt;immutable digraph with 5 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAllSimpleCircuits(D);</span>
[ [ 4 ], [ 4, 5 ], [ 2, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(10);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAllSimpleCircuits(D);</span>
[  ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3], [1], [1]]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAllSimpleCircuits(D);</span>
[ [ 1, 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1, 1]]);</span>
&lt;immutable multidigraph with 1 vertex, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAllSimpleCircuits(D);</span>
[ [ 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleDigraph(IsMutableDigraph, 3);</span>
&lt;mutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphAllSimpleCircuits(D);</span>
[ [ 1, 2, 3 ] ]
</pre></div>

<p><a id="X7C735C4E86BDD5F6" name="X7C735C4E86BDD5F6"></a></p>

<h5>5.4-31 DigraphLongestSimpleCircuit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphLongestSimpleCircuit</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of vertices, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a digraph, then <code class="code">DigraphLongestSimpleCircuit</code> returns the longest <em>simple circuit</em> in <var class="Arg">digraph</var>. See Section <a href="chap1_mj.html#X84541F61810C741D"><span class="RefLink">1.1-1</span></a> for the definition of simple circuit, and the definition of length for a simple circuit.</p>

<p>This attribute computes <code class="code">DigraphAllSimpleCircuits(</code><var class="Arg">digraph</var><code class="code">)</code> to find all the simple circuits of <var class="Arg">digraph</var>, and returns one of maximal length. A simple circuit is represented as a list of vertices, in the same way as described in <code class="func">DigraphAllSimpleCircuits</code> (<a href="chap5_mj.html#X7ECD16838704FAAA"><span class="RefLink">5.4-30</span></a>).</p>

<p>If <var class="Arg">digraph</var> has no simple circuits, then this attribute returns <code class="keyw">fail</code>. If <var class="Arg">digraph</var> has multiple simple circuits of maximal length, then this attribute returns one of them.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[], [3], [2, 4], [5, 4], [4]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestSimpleCircuit(D);</span>
[ 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := ChainDigraph(10);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestSimpleCircuit(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3], [1], [1, 4], [1, 1]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestSimpleCircuit(D);</span>
[ 1, 3, 4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 4, 1);</span>
&lt;mutable digraph with 8 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLongestSimpleCircuit(D);</span>
[ 1, 2, 3, 4, 8, 7, 6, 5 ]
</pre></div>

<p><a id="X870E04307C5F213F" name="X870E04307C5F213F"></a></p>

<h5>5.4-32 DigraphLayers</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphLayers</code>( <var class="Arg">digraph</var>, <var class="Arg">vertex</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list.</p>

<p>This operation returns a list <code class="keyw">list</code> such that <code class="keyw">list[i]</code> is the list of vertices whose minimum distance from the vertex <var class="Arg">vertex</var> in <var class="Arg">digraph</var> is <code class="keyw">i - 1</code>. Vertex <var class="Arg">vertex</var> is assumed to be at distance <code class="keyw">0</code> from itself.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphLayers(D, 1);</span>
[ [ 1 ], [ 2, 3, 4 ] ]
</pre></div>

<p><a id="X7B2E42327DA118E0" name="X7B2E42327DA118E0"></a></p>

<h5>5.4-33 DigraphDegeneracy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDegeneracy</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A non-negative integer, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a symmetric digraph without multiple edges - see <code class="func">IsSymmetricDigraph</code> (<a href="chap6_mj.html#X81B3EA7887219860"><span class="RefLink">6.2-14</span></a>) and <code class="func">IsMultiDigraph</code> (<a href="chap6_mj.html#X7BB84CFC7E8B2B26"><span class="RefLink">6.2-11</span></a>) - then this attribute returns the degeneracy of <var class="Arg">digraph</var>.</p>

<p>The degeneracy of a digraph is the least integer <code class="code">k</code> such that every induced of <var class="Arg">digraph</var> contains a vertex whose number of neighbours (excluding itself) is at most <code class="code">k</code>. Note that this means that loops are ignored.</p>

<p>If <var class="Arg">digraph</var> is not symmetric or has multiple edges then this attribute returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphSymmetricClosure(ChainDigraph(5));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracy(D);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracy(D);</span>
4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [2, 4, 5], [3, 4], [2, 3, 4], [2], []]);</span>
&lt;immutable digraph with 6 vertices, 10 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracy(D);</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 10, 3);</span>
&lt;mutable digraph with 20 vertices, 60 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracy(D);</span>
3
</pre></div>

<p><a id="X827C2BD17A4547E3" name="X827C2BD17A4547E3"></a></p>

<h5>5.4-34 DigraphDegeneracyOrdering</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDegeneracyOrdering</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of integers, or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a digraph for which <code class="code">DigraphDegeneracy(</code><var class="Arg">digraph</var><code class="code">)</code> is a non-negative integer <code class="code">k</code> - see <code class="func">DigraphDegeneracy</code> (<a href="chap5_mj.html#X7B2E42327DA118E0"><span class="RefLink">5.4-33</span></a>) - then this attribute returns a degeneracy ordering of the vertices of the vertices of <var class="Arg">digraph</var>.</p>

<p>A degeneracy ordering of <var class="Arg">digraph</var> is a list <code class="code">ordering</code> of the vertices of <var class="Arg">digraph</var> ordered such that for any position <code class="code">i</code> of the list, the vertex <code class="code">ordering[i]</code> has at most <code class="code">k</code> neighbours in later position of the list.</p>

<p>If <code class="code">DigraphDegeneracy(</code><var class="Arg">digraph</var><code class="code">)</code> returns <code class="keyw">fail</code>, then this attribute returns <code class="keyw">fail</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphSymmetricClosure(ChainDigraph(5));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracyOrdering(D);</span>
[ 5, 4, 3, 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(5);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracyOrdering(D);</span>
[ 5, 4, 3, 2, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[1], [2, 4, 5], [3, 4], [2, 3, 4], [2], []]);</span>
&lt;immutable digraph with 6 vertices, 10 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracyOrdering(D);</span>
[ 1, 6, 5, 2, 4, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 3, 1);</span>
&lt;mutable digraph with 6 vertices, 18 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDegeneracyOrdering(D);</span>
[ 6, 5, 4, 1, 3, 2 ]
</pre></div>

<p><a id="X863FDFC4839A3B82" name="X863FDFC4839A3B82"></a></p>

<h5>5.4-35 HamiltonianPath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; HamiltonianPath</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p>Returns a Hamiltonian path if one exists, <code class="keyw">fail</code> if not.</p>

<p>A <em>Hamiltonian path</em> of a digraph with <code class="code">n</code> vertices is directed cycle of length <code class="code">n</code>. If <var class="Arg">digraph</var> is a digraph that contains a Hamiltonian path, then this function returns one, described in the form used by <code class="func">DigraphAllSimpleCircuits</code> (<a href="chap5_mj.html#X7ECD16838704FAAA"><span class="RefLink">5.4-30</span></a>). Note if <var class="Arg">digraph</var> has 0 or 1 vertices, then <code class="code">HamiltonianPath</code> returns <code class="code">[]</code> or <code class="code">[1]</code>, respectively.</p>

<p>The method used in this attribute has the same worst case complexity as <code class="func">DigraphMonomorphism</code> (<a href="chap7_mj.html#X82D0FCD87D47ACA8"><span class="RefLink">7.3-4</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[]]);</span>
&lt;immutable empty digraph with 1 vertex&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HamiltonianPath(D);</span>
[ 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [1]]);</span>
&lt;immutable digraph with 2 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HamiltonianPath(D);</span>
[ 1, 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3], [], [2]]);</span>
&lt;immutable digraph with 3 vertices, 2 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HamiltonianPath(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2], [3], [1]]);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HamiltonianPath(D);</span>
[ 1, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 5, 2);</span>
&lt;mutable digraph with 10 vertices, 30 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HamiltonianPath(D);</span>
fail
</pre></div>

<p><a id="X82F30D5681466BC6" name="X82F30D5681466BC6"></a></p>

<h5>5.4-36 NrSpanningTrees</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NrSpanningTrees</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: An integer.</p>

<p>Returns the number of spanning trees of the symmetric digraph <var class="Arg">digraph</var>. <code class="code">NrSpanningTrees</code> will return an error if <var class="Arg">digraph</var> is not a symmetric digraph.</p>

<p>See <code class="func">IsSymmetricDigraph</code> (<a href="chap6_mj.html#X81B3EA7887219860"><span class="RefLink">6.2-14</span></a>) and <code class="func">IsUndirectedSpanningTree</code> (<a href="chap4_mj.html#X833C3299787E2309"><span class="RefLink">4.1-2</span></a>) for more information.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(5);</span>
&lt;immutable complete digraph with 5 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrSpanningTrees(D);</span>
125
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphSymmetricClosure(CycleDigraph(24));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrSpanningTrees(D);</span>
24
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrSpanningTrees(EmptyDigraph(0));</span>
0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GeneralisedPetersenGraph(IsMutableDigraph, 9, 2);</span>
&lt;mutable digraph with 18 vertices, 54 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">NrSpanningTrees(D);</span>
1134225
</pre></div>

<p><a id="X79352A8286D1D8F6" name="X79352A8286D1D8F6"></a></p>

<h5>5.4-37 DigraphDijkstra</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDijkstra</code>( <var class="Arg">digraph</var>, <var class="Arg">source</var>, <var class="Arg">target</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphDijkstra</code>( <var class="Arg">digraph</var>, <var class="Arg">source</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: Two lists.</p>

<p>If <var class="Arg">digraph</var> is a digraph and <var class="Arg">source</var> and <var class="Arg">target</var> are vertices of <var class="Arg">digraph</var>, then <code class="code">DigraphDijkstra</code> calculates the length of the shortest path from <var class="Arg">source</var> to <var class="Arg">target</var> and returns two lists. Each element of the first list is the distance of the corresponding element from <var class="Arg">source</var>. If a vertex was not visited in the process of calculating the shortest distance to <var class="Arg">target</var> or if there is no path connecting that vertex with <var class="Arg">source</var>, then the corresponding distance is <code class="keyw">infinity</code>. Each element of the second list gives the previous vertex in the shortest path from <var class="Arg">source</var> to the corresponding vertex. For <var class="Arg">source</var> and for any vertices that remained unvisited this will be <code class="code">-1</code>.</p>

<p>If the optional second argument <var class="Arg">target</var> is not present, then <code class="code">DigraphDijkstra</code> returns the shortest path from <var class="Arg">source</var> to every vertex that is reachable from <var class="Arg">source</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := [[0, 1, 1], [0, 0, 1], [0, 0, 0]];</span>
[ [ 0, 1, 1 ], [ 0, 0, 1 ], [ 0, 0, 0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DigraphByAdjacencyMatrix(mat);</span>
&lt;immutable digraph with 3 vertices, 3 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDijkstra(D, 2, 3);</span>
[ [ infinity, 0, 1 ], [ -1, -1, 2 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDijkstra(D, 1, 3);</span>
[ [ 0, 1, 1 ], [ -1, 1, 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DigraphDijkstra(D, 1, 2);</span>
[ [ 0, 1, 1 ], [ -1, 1, 1 ] ]
</pre></div>

<p><a id="X794CD6037D4CF58C" name="X794CD6037D4CF58C"></a></p>

<h5>5.4-38 DigraphCycleBasis</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DigraphCycleBasis</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A list and a list of GF(2) vectors</p>

<p>If <var class="Arg">digraph</var> is a symmetric loopless digraph with no multiple edges, then <code class="code">DigraphCycleBasis</code> calculates the <em>fundamental cycle basis</em> of <var class="Arg">digraph</var> and returns a list of edges and a list of a basis vectors. If <var class="Arg">digraph</var> contains a loop, this function will return an error. If <var class="Arg">digraph</var> is a multi-digraph, then multiple edges incident to the same vertices are treated as a single edge by this function. See <code class="func">IsSymmetricDigraph</code> (<a href="chap6_mj.html#X81B3EA7887219860"><span class="RefLink">6.2-14</span></a>), <code class="func">DigraphHasLoops</code> (<a href="chap6_mj.html#X7D92935C7D535187"><span class="RefLink">6.2-1</span></a>), and <code class="func">IsMultiDigraph</code> (<a href="chap6_mj.html#X7BB84CFC7E8B2B26"><span class="RefLink">6.2-11</span></a>). The first list returned contains the out-neighours that provide the ordering on the edges with the symmetric edges appearing only once; these are the same as <em>OutNeighbours(MaximalAntiSymmetricSubdigraph(G))</em>. See <code class="func">MaximalAntiSymmetricSubdigraph</code> (<a href="chap3_mj.html#X79BA6A66846D5A95"><span class="RefLink">3.3-6</span></a>) <code class="func">OutNeighbours</code> (<a href="chap5_mj.html#X7E9880767AE68E00"><span class="RefLink">5.2-6</span></a>). The second list returned contains the basis vectors of the cycle space of the digraph. These vectors belongs to <span class="SimpleMath">\((GF(2))^m\)</span> where <span class="SimpleMath">\(m\)</span> is the length of the list of edges.</p>

<p>A graph is <em>eulerian</em> if every vertex has an even degree. A <em>cycle space</em> of a graph is a subspace of <span class="SimpleMath">\((GF(2))^m\)</span> representing the set of all <em>eulerian</em> subgraphs without isolated vertices. An eulerian subgraph without isolated vertices can be uniquely identified using the edges that is contains. Therefore, given some ordering on the edges of the graph, a subgraph can be represented by a vector in <span class="SimpleMath">\((GF(2))^m\)</span> where the <span class="SimpleMath">\(i\)</span>-th entry is <span class="SimpleMath">\(1\)</span> if the <span class="SimpleMath">\(i\)</span>-th edge is in the subgraph and <span class="SimpleMath">\(0\)</span> otherwise. In this function, the ordering of the edges is returned as the first list which corresponds to <code class="code">OutNeighbours(MaximalAntiSymmetricSubdigraph(G))</code>. See <code class="func">MaximalAntiSymmetricSubdigraph</code> (<a href="chap3_mj.html#X79BA6A66846D5A95"><span class="RefLink">3.3-6</span></a>) and <code class="func">OutNeighbours</code> (<a href="chap5_mj.html#X7E9880767AE68E00"><span class="RefLink">5.2-6</span></a>). The first basis vector for the complete digraph with 4 vertices shown below represents the edges <code class="code">[1, 2]</code>, <code class="code">[1, 3]</code> and <code class="code">[2, 3]</code> i.e. cycle subgraph between the vertices <code class="code">1</code>, <code class="code">2</code> and <code class="code">3</code> The cycle space is closed under the symmetric difference of the edges of the graph. This nicely corresponds to the addition of vectors in <span class="SimpleMath">\((GF(2))^m\)</span> which makes the vector space formulation of the cycle space very natural.</p>

<p>A <em>cycle basis</em> is a basis of the cycle space. A <em>fundamental cycle basis</em> is a special kind of basis of the cycle space where there is a specific spanning tree (forest, when the graph is disconnected) of the graph and each basis corresponds to the unique cycle created by adding an edge outside the spanning tree of the graph to the spanning tree. In this function, the spanning forest is rooted in the vertex with the smallest label for each connected component of the graph.</p>

<p>The fundamental cycle basis is unique up to reordering of the basis vectors. The number of basis vectors in the fundamental cycle basis is <span class="SimpleMath">\(m - n + c\)</span>, where <span class="SimpleMath">\(m\)</span> is the number of edges, <span class="SimpleMath">\(n\)</span> is the number of vertices, and <span class="SimpleMath">\(c\)</span> is the number of connected components. See <code class="func">DigraphConnectedComponents</code> (<a href="chap5_mj.html#X842FAD6A7B835977"><span class="RefLink">5.4-9</span></a>).</p>

<p>This function performs a depth first traversal of the input digraph with complexity <span class="SimpleMath">\(O(m + n)\)</span> and the complexity of the computation of the basis is <span class="SimpleMath">\(O(m^2)\)</span> where <span class="SimpleMath">\(m\)</span> is the number of edges in the input digraph.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CycleGraph(4);</span>
&lt;immutable symmetric digraph with 4 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">res := DigraphCycleBasis(D);</span>
[ [ [ 2, 4 ], [ 3 ], [ 4 ], [  ] ], [ &lt;a GF2 vector of length 4&gt; ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(res[2][1]);</span>
[ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := CompleteDigraph(4);                                     </span>
&lt;immutable complete digraph with 4 vertices&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">res := DigraphCycleBasis(D);</span>
[ [ [ 2, 3, 4 ], [ 3, 4 ], [ 4 ], [  ] ], 
  [ &lt;a GF2 vector of length 6&gt;, &lt;a GF2 vector of length 6&gt;, 
      &lt;a GF2 vector of length 6&gt; ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(res[2][1]);            </span>
[ Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(res[2][2]);</span>
[ 0*Z(2), Z(2)^0, Z(2)^0, 0*Z(2), 0*Z(2), Z(2)^0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(res[2][3]);</span>
[ Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), 0*Z(2) ]
</pre></div>

<p><a id="X82F900777D677F55" name="X82F900777D677F55"></a></p>

<h4>5.5 <span class="Heading">Cayley graphs of groups</span></h4>

<p><a id="X7A000B1D7CCF7093" name="X7A000B1D7CCF7093"></a></p>

<h5>5.5-1 GroupOfCayleyDigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GroupOfCayleyDigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SemigroupOfCayleyDigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A group or semigroup.</p>

<p>If <var class="Arg">digraph</var> is an immutable Cayley graph of a group <code class="code">G</code> and <var class="Arg">digraph</var> belongs to the category <code class="func">IsCayleyDigraph</code> (<a href="chap3_mj.html#X7E749324800B38A5"><span class="RefLink">3.1-4</span></a>), then <code class="code">GroupOfCayleyDigraph</code> returns <code class="code">G</code>.</p>

<p>If <var class="Arg">digraph</var> is a Cayley graph of a semigroup <code class="code">S</code> and <var class="Arg">digraph</var> belongs to the category <code class="func">IsCayleyDigraph</code> (<a href="chap3_mj.html#X7E749324800B38A5"><span class="RefLink">3.1-4</span></a>), then <code class="code">SemigroupOfCayleyDigraph</code> returns <code class="code">S</code>.</p>

<p>See also <code class="func">GeneratorsOfCayleyDigraph</code> (<a href="chap5_mj.html#X8528455987D7D2BF"><span class="RefLink">5.5-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralGroup(IsPermGroup, 8);</span>
Group([ (1,2,3,4), (2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph := CayleyDigraph(G);</span>
&lt;immutable digraph with 8 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GroupOfCayleyDigraph(digraph) = G;</span>
true
</pre></div>

<p><a id="X8528455987D7D2BF" name="X8528455987D7D2BF"></a></p>

<h5>5.5-2 GeneratorsOfCayleyDigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; GeneratorsOfCayleyDigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list of generators.</p>

<p>If <var class="Arg">digraph</var> is an immutable Cayley graph of a group or semigroup with respect to a set of generators <code class="code">gens</code> and <var class="Arg">digraph</var> belongs to the category <code class="func">IsCayleyDigraph</code> (<a href="chap3_mj.html#X7E749324800B38A5"><span class="RefLink">3.1-4</span></a>), then <code class="code">GeneratorsOfCayleyDigraph</code> return the list of generators <code class="code">gens</code> over which <var class="Arg">digraph</var> is defined.</p>

<p>See also <code class="func">GroupOfCayleyDigraph</code> (<a href="chap5_mj.html#X7A000B1D7CCF7093"><span class="RefLink">5.5-1</span></a>) or <code class="func">SemigroupOfCayleyDigraph</code> (<a href="chap5_mj.html#X7A000B1D7CCF7093"><span class="RefLink">5.5-1</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := DihedralGroup(IsPermGroup, 8);</span>
Group([ (1,2,3,4), (2,4) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph := CayleyDigraph(G);</span>
&lt;immutable digraph with 8 vertices, 16 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfCayleyDigraph(digraph) = GeneratorsOfGroup(G);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">digraph := CayleyDigraph(G, [()]);</span>
&lt;immutable digraph with 8 vertices, 8 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorsOfCayleyDigraph(digraph) = [()];</span>
true</pre></div>

<p><a id="X790FD6647ECCAE3C" name="X790FD6647ECCAE3C"></a></p>

<h4>5.6 <span class="Heading">Associated semigroups</span></h4>

<p><a id="X87D5C60D7B0C1309" name="X87D5C60D7B0C1309"></a></p>

<h5>5.6-1 AsSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsSemigroup</code>( <var class="Arg">filt</var>, <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsMonoid</code>( <var class="Arg">filt</var>, <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A semilattice of partial perms.</p>

<p>The operation <code class="code">AsSemigroup</code> requires that <var class="Arg">filt</var> be equal to <code class="func">IsPartialPermSemigroup</code> (<a href="https://www.gap-system.org/Manuals/doc/ref/chap54_mj.html#X7D161674800B50E0"><span class="RefLink">Reference: IsPartialPermSemigroup</span></a>). If <var class="Arg">digraph</var> is a <code class="func">IsJoinSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.4-3</span></a>) or <code class="func">IsLatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.4-3</span></a>) then <code class="code">AsSemigroup</code> returns a semigroup of partial perms which is isomorphic to the semigroup whose elements are the vertices of <var class="Arg">digraph</var> with the binary operation <code class="func">PartialOrderDigraphJoinOfVertices</code> (<a href="chap5_mj.html#X7DDB33B686B3A2C6"><span class="RefLink">5.3-1</span></a>). If <var class="Arg">digraph</var> satisfies <code class="func">IsMeetSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.4-3</span></a>) but not <code class="func">IsJoinSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.4-3</span></a>) then <code class="code">AsSemigroup</code> returns a semigroup of partial perms which is isomorphic to the semigroup whose elements are the vertices of <var class="Arg">digraph</var> with the binary operation <code class="func">PartialOrderDigraphMeetOfVertices</code> (<a href="chap5_mj.html#X7DDB33B686B3A2C6"><span class="RefLink">5.3-1</span></a>).</p>

<p>The operation <code class="code">AsMonoid</code> behaves similarly to <code class="code">AsSemigroup</code> except that <var class="Arg">filt</var> may also be equal to <code class="func">IsPartialPermMonoid</code> (<a href="https://www.gap-system.org/Manuals/doc/ref/chap54_mj.html#X7D161674800B50E0"><span class="RefLink">Reference: IsPartialPermMonoid</span></a>), <var class="Arg">digraph</var> must satisfy <code class="func">IsLatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.4-3</span></a>), and the output satisfies <code class="func">IsMonoid</code> (<a href="https://www.gap-system.org/Manuals/doc/ref/chap51_mj.html#X861C523483C6248C"><span class="RefLink">Reference: IsMonoid</span></a>).</p>

<p>The output of both of these operations is guaranteed to be of minimal degree (see <code class="func">DegreeOfPartialPermSemigroup</code> (<a href="https://www.gap-system.org/Manuals/doc/ref/chap54_mj.html#X7D7F0BAB82F0D820"><span class="RefLink">Reference: DegreeOfPartialPermSemigroup</span></a>)). Furthermore the <code class="func">GeneratorsOfSemigroup</code> (<a href="https://www.gap-system.org/Manuals/doc/ref/chap51_mj.html#X78147A247963F23B"><span class="RefLink">Reference: GeneratorsOfSemigroup</span></a>) of the output is guaranteed to be the unique generating set of minimal size.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">di := Digraph([[1], [1, 2], [1, 3], [1, 4], [1, 2, 3, 5]]);</span>
&lt;immutable digraph with 5 vertices, 11 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := AsSemigroup(IsPartialPermSemigroup, di);</span>
&lt;partial perm semigroup of rank 3 with 4 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(Elements(S), IsIdempotent);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsInverseSemigroup(S);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(S);</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">di := Digraph([[1], [1, 2], [1, 2, 3]]);</span>
&lt;immutable digraph with 3 vertices, 6 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := AsMonoid(IsPartialPermMonoid, di);</span>
&lt;partial perm monoid of rank 2 with 3 generators&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(M);</span>
3</pre></div>

<p><a id="X7C6D5EC27C51066B" name="X7C6D5EC27C51066B"></a></p>

<h5>5.6-2 AsSemigroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsSemigroup</code>( <var class="Arg">filt</var>, <var class="Arg">Y</var>, <var class="Arg">gps</var>, <var class="Arg">homs</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: A Clifford semigroup of partial perms.</p>

<p>The operation <code class="code">AsSemigroup</code> requires that <var class="Arg">filt</var> be equal to <code class="func">IsPartialPermSemigroup</code> (<a href="https://www.gap-system.org/Manuals/doc/ref/chap54_mj.html#X7D161674800B50E0"><span class="RefLink">Reference: IsPartialPermSemigroup</span></a>). If <var class="Arg">Y</var> is a <code class="func">IsJoinSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.4-3</span></a>) or <code class="func">IsMeetSemilatticeDigraph</code> (<a href="chap6_mj.html#X78D3E17B7F737516"><span class="RefLink">6.4-3</span></a>), <var class="Arg">gps</var> is a list of groups corresponding to each vertex, and <var class="Arg">homs</var> is a list containing for each edge <code class="code">(i, j)</code> in the transitive reduction of <var class="Arg">digraph</var> a triple <code class="code">[i, j, hom]</code> where <code class="code">hom</code> is a group homomorphism from <code class="code">gps[i]</code> to <code class="code">gps[j]</code>, and the diagram of homomorphisms commutes, then <code class="code">AsSemigroup</code> returns a semigroup of partial perms which is isomorphic to the strong semilattice of groups <span class="SimpleMath">\(S[Y; gps; homs]\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G1 := AlternatingGroup(4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G2 := SymmetricGroup(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G3 := SymmetricGroup(3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gr := Digraph([[1, 3], [2, 3], [3]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sgn := function(x)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">if SignPerm(x) = 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">return ();</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">return (1, 2);</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom13 := GroupHomomorphismByFunction(G1, G3, sgn);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom23 := GroupHomomorphismByFunction(G2, G3, sgn);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := AsSemigroup(IsPartialPermSemigroup,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">gr,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[G1, G2, G3], [[1, 3, hom13], [2, 3, hom23]]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size(T);</span>
20
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := GreensDClasses(T);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(D, Size);</span>
[ 6, 12, 2 ]
</pre></div>

<p><a id="X7E2305528492DDC0" name="X7E2305528492DDC0"></a></p>

<h4>5.7 <span class="Heading">Planarity</span></h4>

<p><a id="X7DC478637E8C190D" name="X7DC478637E8C190D"></a></p>

<h5>5.7-1 KuratowskiPlanarSubdigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KuratowskiPlanarSubdigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p><code class="code">KuratowskiPlanarSubdigraph</code> returns the immutable list of lists of out-neighbours of a (not necessarily induced) subdigraph of the digraph <var class="Arg">digraph</var> that witnesses the fact that <var class="Arg">digraph</var> is not planar, or <code class="keyw">fail</code> if <var class="Arg">digraph</var> is planar. In other words, <code class="code">KuratowskiPlanarSubdigraph</code> returns the out-neighbours of a subdigraph of <var class="Arg">digraph</var> that is homeomorphic to the complete graph with <code class="code">5</code> vertices, or to the complete bipartite graph with vertex sets of sizes <code class="code">3</code> and <code class="code">3</code>.</p>

<p>The directions and multiplicities of any edges in <var class="Arg">digraph</var> are ignored when considering whether or not <var class="Arg">digraph</var> is planar.</p>

<p>See also <code class="func">IsPlanarDigraph</code> (<a href="chap6_mj.html#X8606D415858C40AA"><span class="RefLink">6.7-1</span></a>) and <code class="func">SubdigraphHomeomorphicToK33</code> (<a href="chap5_mj.html#X806D2D6B85E0B269"><span class="RefLink">5.7-5</span></a>).</p>

<p>This method uses the reference implementation in <span class="URL"><a href="https://github.com/graph-algorithms/edge-addition-planarity-suite">edge-addition-planarity-suite</a></span> by John Boyer of the algorithms described in <a href="chapBib_mj.html#biBBM06">[BM06]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiPlanarSubdigraph(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 4, 7, 9, 10], [1, 3, 4, 6, 9, 10], [6, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 5, 8, 9], [1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;immutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPlanarDigraph(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiPlanarSubdigraph(D);</span>
[ [ 2, 9, 7 ], [ 3 ], [ 6 ], [ 5, 9 ], [ 6 ], [  ], [ 4 ], 
  [ 7, 9, 3 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiPlanarSubdigraph(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[2, 4, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 3, 4, 6, 9, 10], [6, 10], [2, 5, 8, 9],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;mutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPlanarDigraph(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiPlanarSubdigraph(D);</span>
[ [ 2, 9, 7 ], [ 3 ], [ 6 ], [ 5, 9 ], [ 6 ], [  ], [ 4 ], 
  [ 7, 9, 3 ], [  ], [  ] ]
</pre></div>

<p><a id="X78E8F09A8286501B" name="X78E8F09A8286501B"></a></p>

<h5>5.7-2 KuratowskiOuterPlanarSubdigraph</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KuratowskiOuterPlanarSubdigraph</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p><code class="code">KuratowskiOuterPlanarSubdigraph</code> returns the immutable list of immutable lists of out-neighbours of a (not necessarily induced) subdigraph of the digraph <var class="Arg">digraph</var> that witnesses the fact that <var class="Arg">digraph</var> is not outer planar, or <code class="keyw">fail</code> if <var class="Arg">digraph</var> is outer planar. In other words, <code class="code">KuratowskiOuterPlanarSubdigraph</code> returns the out-neighbours of a subdigraph of <var class="Arg">digraph</var> that is homeomorphic to the complete graph with <code class="code">4</code> vertices, or to the complete bipartite graph with vertex sets of sizes <code class="code">2</code> and <code class="code">3</code>.</p>

<p>The directions and multiplicities of any edges in <var class="Arg">digraph</var> are ignored when considering whether or not <var class="Arg">digraph</var> is outer planar.</p>

<p>See also <code class="func">IsOuterPlanarDigraph</code> (<a href="chap6_mj.html#X8251E8B187E7F059"><span class="RefLink">6.7-2</span></a>), <code class="func">SubdigraphHomeomorphicToK4</code> (<a href="chap5_mj.html#X806D2D6B85E0B269"><span class="RefLink">5.7-5</span></a>), and <code class="func">SubdigraphHomeomorphicToK23</code> (<a href="chap5_mj.html#X806D2D6B85E0B269"><span class="RefLink">5.7-5</span></a>).</p>

<p>This method uses the reference implementation in <span class="URL"><a href="https://github.com/graph-algorithms/edge-addition-planarity-suite">edge-addition-planarity-suite</a></span> by John Boyer of the algorithms described in <a href="chapBib_mj.html#biBBM06">[BM06]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiOuterPlanarSubdigraph(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 4, 7, 9, 10], [1, 3, 4, 6, 9, 10], [6, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 5, 8, 9], [1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;immutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOuterPlanarDigraph(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiOuterPlanarSubdigraph(D);</span>
[ [  ], [  ], [  ], [ 8, 9 ], [  ], [  ], [ 9, 4 ], [ 7, 9 ], [  ], 
  [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiOuterPlanarSubdigraph(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[2, 4, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 3, 4, 6, 9, 10], [6, 10], [2, 5, 8, 9],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;mutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOuterPlanarDigraph(D);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KuratowskiOuterPlanarSubdigraph(D);</span>
[ [  ], [  ], [  ], [ 8, 9 ], [  ], [  ], [ 9, 4 ], [ 7, 9 ], [  ], 
  [  ] ]</pre></div>

<p><a id="X84E3947E7D39BA64" name="X84E3947E7D39BA64"></a></p>

<h5>5.7-3 PlanarEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PlanarEmbedding</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is a planar digraph, then <code class="code">PlanarEmbedding</code> returns the immutable list of lists of out-neighbours of a subdigraph of <var class="Arg">digraph</var> such that each vertex's neighbours are given in clockwise order. If <var class="Arg">digraph</var> is not planar, then <code class="keyw">fail</code> is returned.</p>

<p>The directions and multiplicities of any edges in <var class="Arg">digraph</var> are ignored by <code class="code">PlanarEmbedding</code>.</p>

<p>See also <code class="func">IsPlanarDigraph</code> (<a href="chap6_mj.html#X8606D415858C40AA"><span class="RefLink">6.7-1</span></a>).</p>

<p>This method uses the reference implementation in <span class="URL"><a href="https://github.com/graph-algorithms/edge-addition-planarity-suite">edge-addition-planarity-suite</a></span> by John Boyer of the algorithms described in <a href="chapBib_mj.html#biBBM06">[BM06]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PlanarEmbedding(D);</span>
[ [ 3, 10, 5 ], [ 10, 8, 9 ], [ 4 ], [ 6 ], [ 11, 7 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 4, 7, 9, 10], [1, 3, 4, 6, 9, 10], [6, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 5, 8, 9], [1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;immutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PlanarEmbedding(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PlanarEmbedding(D);</span>
[ [ 3, 10, 5 ], [ 10, 8, 9 ], [ 4 ], [ 6 ], [ 11, 7 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[2, 4, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 3, 4, 6, 9, 10], [6, 10], [2, 5, 8, 9],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;mutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PlanarEmbedding(D);</span>
fail
</pre></div>

<p><a id="X85DFB8C18088711F" name="X85DFB8C18088711F"></a></p>

<h5>5.7-4 OuterPlanarEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OuterPlanarEmbedding</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p>If <var class="Arg">digraph</var> is an outer planar digraph, then <code class="code">OuterPlanarEmbedding</code> returns the immutable list of lists of out-neighbours of a subdigraph of <var class="Arg">digraph</var> such that each vertex's neighbours are given in clockwise order. If <var class="Arg">digraph</var> is not outer planar, then <code class="keyw">fail</code> is returned.</p>

<p>The directions and multiplicities of any edges in <var class="Arg">digraph</var> are ignored by <code class="code">OuterPlanarEmbedding</code>.</p>

<p>See also <code class="func">IsOuterPlanarDigraph</code> (<a href="chap6_mj.html#X8251E8B187E7F059"><span class="RefLink">6.7-2</span></a>).</p>

<p>This method uses the reference implementation in <span class="URL"><a href="https://github.com/graph-algorithms/edge-addition-planarity-suite">edge-addition-planarity-suite</a></span> by John Boyer of the algorithms described in <a href="chapBib_mj.html#biBBM06">[BM06]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[2, 4, 7, 9, 10], [1, 3, 4, 6, 9, 10], [6, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[2, 5, 8, 9], [1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;immutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(CompleteBipartiteDigraph(2, 2));</span>
[ [ 3, 4 ], [ 4, 3 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[2, 4, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 3, 4, 6, 9, 10], [6, 10], [2, 5, 8, 9],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[1, 2, 3, 4, 6, 7, 9, 10], [3, 4, 5, 7, 9, 10],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 4, 5, 6, 9, 10], [3, 4, 5, 7, 9], [2, 3, 5, 6, 7, 8], [3, 5]]);</span>
&lt;mutable digraph with 10 vertices, 50 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OuterPlanarEmbedding(CompleteBipartiteDigraph(2, 2));</span>
[ [ 3, 4 ], [ 4, 3 ], [  ], [  ] ]
</pre></div>

<p><a id="X806D2D6B85E0B269" name="X806D2D6B85E0B269"></a></p>

<h5>5.7-5 SubdigraphHomeomorphicToK23</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubdigraphHomeomorphicToK23</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubdigraphHomeomorphicToK33</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubdigraphHomeomorphicToK4</code>( <var class="Arg">digraph</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: A list or <code class="keyw">fail</code>.</p>

<p>These attributes return the immutable list of lists of out-neighbours of a subdigraph of the digraph <var class="Arg">digraph</var> which is homeomorphic to one of the following: the complete bipartite graph with vertex sets of sizes <code class="code">2</code> and <code class="code">3</code>; the complete bipartite graph with vertex sets of sizes <code class="code">3</code> and <code class="code">3</code>; or the complete graph with <code class="code">4</code> vertices. If <var class="Arg">digraph</var> has no such subdigraphs, then <code class="keyw">fail</code> is returned.</p>

<p>See also <code class="func">IsPlanarDigraph</code> (<a href="chap6_mj.html#X8606D415858C40AA"><span class="RefLink">6.7-1</span></a>) and <code class="func">IsOuterPlanarDigraph</code> (<a href="chap6_mj.html#X8251E8B187E7F059"><span class="RefLink">6.7-2</span></a>) for more details.</p>

<p>This method uses the reference implementation in <span class="URL"><a href="https://github.com/graph-algorithms/edge-addition-planarity-suite">edge-addition-planarity-suite</a></span> by John Boyer of the algorithms described in <a href="chapBib_mj.html#biBBM06">[BM06]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], [1, 7, 11], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 7, 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph([[3, 5, 10], [8, 9, 10], [1, 4], [3, 6], [1, 11], </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;immutable digraph with 11 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(D);</span>
[ [ 3, 10, 5 ], [ 10, 8, 9 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(NullDigraph(0));</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(CompleteDigraph(5));</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(CompleteBipartiteDigraph(3, 3));</span>
[ [ 4, 6, 5 ], [ 4, 5, 6 ], [ 6, 5, 4 ], [  ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(CompleteDigraph(3));</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 7, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 25 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 7, 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(D);</span>
[ [ 3, 5, 10 ], [ 9, 8, 10 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := Digraph(IsMutableDigraph, [[3, 5, 10], [8, 9, 10], [1, 4],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">[3, 6], [1, 11], [4, 7], [6, 8], [2, 7], [2, 11], [1, 2], [5, 9]]);</span>
&lt;mutable digraph with 11 vertices, 24 edges&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(D);</span>
[ [ 3, 10, 5 ], [ 10, 8, 9 ], [ 4 ], [ 6 ], [ 11 ], [ 7 ], [ 8 ], 
  [  ], [ 11 ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(D);</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK23(NullDigraph(0));</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(CompleteDigraph(5));</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK33(CompleteBipartiteDigraph(3, 3));</span>
[ [ 4, 6, 5 ], [ 4, 5, 6 ], [ 6, 5, 4 ], [  ], [  ], [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SubdigraphHomeomorphicToK4(CompleteDigraph(3));</span>
fail
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap6_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chapA_mj.html">A</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
